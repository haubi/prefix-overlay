IRIX patch by Frank Everdij and Stuart Shelton

Added configure check for alloca.h to enable the guards for bug #286943

http://bugs.gentoo.org/show_bug.cgi?id=266494

--- setup.py.orig
+++ setup.py
@@ -1321,6 +1321,14 @@ class PyBuildExt(build_ext):
                 )
             libraries = []
 
+        elif platform.startswith('irix'):
+            macros = dict(                  # IRIX
+                HAVE_SEM_OPEN=1,
+                HAVE_SEM_TIMEDWAIT=0,
+                HAVE_FD_TRANSFER=1,
+                )
+            libraries = []
+
         else:                                   # Linux and other unices
             macros = dict(
                 HAVE_SEM_OPEN=1,
--- Lib/test/test_fileio.py.dist
+++ Lib/test/test_fileio.py
@@ -152,7 +152,8 @@ class OtherFileTests(unittest.TestCase):
                     self.assertEquals(f.writable(), True)
                     if sys.platform != "darwin" and \
                        'bsd' not in sys.platform and \
-                       not sys.platform.startswith('sunos'):
+                       not sys.platform.startswith('sunos') and \
+                       not sys.platform.startswith('irix'):
                         # Somehow /dev/tty appears seekable on some BSDs
                         self.assertEquals(f.seekable(), False)
                     self.assertEquals(f.isatty(), True)
--- Modules/_cursesmodule.c.orig
+++ Modules/_cursesmodule.c
@@ -120,9 +120,6 @@ char *PyCursesVersion = "2.2";
     curses module in other ways.  So the code will just specify 
     explicit prototypes here. */
 extern int setupterm(char *,int,int *);
-#ifdef __sgi
-#include <term.h>
-#endif
 
 #if !defined(HAVE_NCURSES_H) && (defined(sgi) || defined(__sun) || defined(SCO5))
 #define STRICT_SYSV_CURSES       /* Don't use ncurses extensions */
--- Modules/_fileio.c.dist
+++ Modules/_fileio.c
@@ -33,7 +33,7 @@ typedef struct {
 	unsigned int readable : 1;
 	unsigned int writable : 1;
 	signed int seekable : 2; /* -1 means unknown */
-	signed int closefd : 1;
+	unsigned int closefd : 1; /* How can a 1-bit field be signed? */
 	PyObject *weakreflist;
 } PyFileIOObject;
 
--- Modules/mmapmodule.c.orig
+++ Modules/mmapmodule.c
@@ -50,6 +50,10 @@ my_getallocationgranularity (void)
 #include <sys/mman.h>
 #include <sys/stat.h>
 
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+
 #if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
 static int
 my_getpagesize(void)
--- Modules/posixmodule.c.orig
+++ Modules/posixmodule.c
@@ -169,7 +169,9 @@ corresponding Unix manual entries for mo
 extern char        *ctermid_r(char *);
 #endif
 
-#ifndef HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#else
 #if defined(PYCC_VACPP)
 extern int mkdir(char *);
 #else
--- Modules/python.c.orig
+++ Modules/python.c
@@ -3,7 +3,10 @@
 #include "Python.h"
 
 #ifdef __FreeBSD__
-#include <floatingpoint.h>
+# include <floatingpoint.h>
+#endif
+#ifdef __sgi
+# include <sys/fpu.h>
 #endif
 
 int
@@ -20,5 +23,11 @@ main(int argc, char **argv)
 	m = fpgetmask();
 	fpsetmask(m & ~FP_X_OFL);
 #endif
+#ifdef __sgi
+	unsigned int m;
+
+	m = get_fpc_csr();
+	set_fpc_csr(m & ~FPCSR_FLUSH_ZERO);
+#endif
 	return Py_Main(argc, argv);
 }
--- configure.in.orig
+++ configure.in
@@ -1267,7 +1267,7 @@
 # checks for header files
 AC_HEADER_STDC
 AC_CHECK_HEADERS(asm/types.h conio.h curses.h direct.h dlfcn.h errno.h \
-fcntl.h grp.h \
+fcntl.h grp.h alloca.h \
 ieeefp.h io.h langinfo.h libintl.h ncurses.h poll.h process.h pthread.h \
 shadow.h signal.h stdint.h stropts.h termios.h thread.h \
 unistd.h utime.h \
--- Modules/_ctypes/_ctypes.c.orig
+++ Modules/_ctypes/_ctypes.c
@@ -111,11 +111,11 @@ bytes(cdata)
 
 #include <ffi.h>
 #ifdef MS_WIN32
-#include <windows.h>
-#include <malloc.h>
-#ifndef IS_INTRESOURCE
-#define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)
-#endif
+# include <windows.h>
+# include <malloc.h>
+# ifndef IS_INTRESOURCE
+#  define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)
+# endif
 # ifdef _WIN32_WCE
 /* Unlike desktop Windows, WinCE has both W and A variants of
    GetProcAddress, but the default W version is not what we want */
@@ -123,8 +123,11 @@ bytes(cdata)
 #  define GetProcAddress GetProcAddressA
 # endif
 #else
-#include "ctypes_dlfcn.h"
+# include "ctypes_dlfcn.h"
 #endif
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
 #include "ctypes.h"
 
 PyObject *PyExc_ArgError;
@@ -3857,7 +3860,7 @@ CFuncPtr_call(CFuncPtrObject *self, PyOb
 		}
 	}
 
-	result = _CallProc(pProc,
+	result = _CallProc((PPROC)pProc,
 			   callargs,
 #ifdef MS_WIN32
 			   piunk,
--- Modules/_ctypes/_ctypes_test.c.orig
+++ Modules/_ctypes/_ctypes_test.c
@@ -369,8 +369,8 @@ EXPORT(PY_LONG_LONG) last_tf_arg_s;
 EXPORT(unsigned PY_LONG_LONG) last_tf_arg_u;
 
 struct BITS {
-	int A: 1, B:2, C:3, D:4, E: 5, F: 6, G: 7, H: 8, I: 9;
-	short M: 1, N: 2, O: 3, P: 4, Q: 5, R: 6, S: 7;
+	unsigned int A: 1, B:2, C:3, D:4, E: 5, F: 6, G: 7, H: 8, I: 9;
+	unsigned short M: 1, N: 2, O: 3, P: 4, Q: 5, R: 6, S: 7;
 };
 
 DL_EXPORT(void) set_bitfields(struct BITS *bits, char name, int value)
--- Modules/_ctypes/callproc.c.orig
+++ Modules/_ctypes/callproc.c
@@ -73,6 +73,10 @@
 #include <malloc.h>
 #endif
 
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+
 #include <ffi.h>
 #include "ctypes.h"
 
@@ -463,7 +467,7 @@ PyCArg_repr(PyCArgObject *self)
 #ifdef MS_WIN32
 			"<cparam '%c' (%I64d)>",
 #else
-			"<cparam '%c' (%qd)>",
+			"<cparam '%c' (%lld)>",
 #endif
 			self->tag, self->value.q);
 		break;
@@ -813,7 +817,7 @@ static int _call_function_pointer(int fl
 #endif
 		delta =
 #endif
-			ffi_call(&cif, (void *)pProc, resmem, avalues);
+			ffi_call(&cif, FFI_FN(pProc), resmem, avalues);
 #ifdef MS_WIN32
 #ifndef DONT_USE_SEH
 	}
--- Modules/_ctypes/malloc_closure.c.orig
+++ Modules/_ctypes/malloc_closure.c
@@ -5,12 +5,18 @@
 #include <Python.h>
 #include <ffi.h>
 #ifdef MS_WIN32
-#include <windows.h>
+# include <windows.h>
 #else
-#include <sys/mman.h>
-#include <unistd.h>
-# if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
-#  define MAP_ANONYMOUS MAP_ANON
+# include <sys/mman.h>
+# include <unistd.h>
+# if !defined(MAP_ANONYMOUS)
+#  if defined(MAP_ANON)
+#   define MAP_ANONYMOUS MAP_ANON
+#  else /* For open(), O_RDWR, etc. */
+#   include <sys/types.h>
+#   include <sys/stat.h>
+#   include <fcntl.h>
+#  endif
 # endif
 #endif
 #include "ctypes.h"
@@ -37,6 +43,8 @@ int _pagesize;
 static void more_core(void)
 {
 	ITEM *item;
+	int flags = MAP_PRIVATE;
+	int devzero = -1;
 	int count, i;
 
 /* determine the pagesize */
@@ -68,12 +76,24 @@ static void more_core(void)
 	if (item == NULL)
 		return;
 #else
+#ifdef MAP_ANONYMOUS
+		/* BSD way to map anonymous memory */
+		flags |= MAP_ANONYMOUS;
+#else
+		/* SVR4 method to map anonymous memory is to open /dev/zero */
+		devzero = open("/dev/zero", O_RDWR);
+		if (devzero == -1)
+			return;
+#endif
 	item = (ITEM *)mmap(NULL,
 			    count * sizeof(ITEM),
 			    PROT_READ | PROT_WRITE | PROT_EXEC,
-			    MAP_PRIVATE | MAP_ANONYMOUS,
-			    -1,
+			    flags,
+			    devzero,
 			    0);
+	if (devzero != -1)
+		close(devzero);
+
 	if (item == (void *)MAP_FAILED)
 		return;
 #endif
--- Modules/_ctypes/libffi/src/mips/n32.S.orig
+++ Modules/_ctypes/libffi/src/mips/n32.S
@@ -40,7 +40,7 @@
 
 #define SIZEOF_FRAME	( 8 * FFI_SIZEOF_ARG )
 
-	.abicalls
+/*	.abicalls */
 	.text
 	.align	2
 	.globl	ffi_call_N32
@@ -474,7 +474,7 @@ cls_epilogue:	
 .LFE2:	
 	.end	ffi_closure_N32
 
-        .section        .eh_frame,"aw",@progbits
+/*      .section        .eh_frame,"aw",@progbits
 .Lframe1:
         .4byte  .LECIE1-.LSCIE1		# length
 .LSCIE1:
@@ -530,5 +530,6 @@ cls_epilogue:	
 	.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4
 	.align	EH_FRAME_ALIGN
 .LEFDE3:
+*/
 	
 #endif
--- Modules/_ctypes/libffi/src/mips/ffitarget.h.orig
+++ Modules/_ctypes/libffi/src/mips/ffitarget.h
@@ -27,8 +27,13 @@
 #ifndef LIBFFI_TARGET_H
 #define LIBFFI_TARGET_H
 
-#ifdef linux
-#include <asm/sgidefs.h>
+#if defined(linux) || defined (__sgi)
+#  ifdef linux
+#    include <asm/sgidefs.h>
+#  endif
+#  ifdef __sgi
+#    include <sgidefs.h>
+#  endif
 #  ifndef _ABIN32
 #    define _ABIN32 _MIPS_SIM_NABI32
 #  endif
@@ -41,7 +46,7 @@
 #endif
 
 #if !defined(_MIPS_SIM)
--- something is very wrong --
+# error -- something is very wrong --
 #else
 #  if (_MIPS_SIM==_ABIN32 && defined(_ABIN32)) || (_MIPS_SIM==_ABI64 && defined(_ABI64))
 #    define FFI_MIPS_N32
@@ -49,7 +54,7 @@
 #    if (_MIPS_SIM==_ABIO32 && defined(_ABIO32))
 #      define FFI_MIPS_O32
 #    else
--- this is an unsupported platform --
+#     error -- this is an unsupported platform --
 #    endif
 #  endif
 #endif
@@ -145,14 +150,26 @@
 # endif /* _MIPS_SIM==_ABI64 */
 #endif /* !FFI_MIPS_O32 */
 #else /* !LIBFFI_ASM */
-#ifdef FFI_MIPS_O32
+#ifdef __GNUC__
+#  ifdef FFI_MIPS_O32
 /* O32 stack frames have 32bit integer args */
 typedef unsigned int     ffi_arg __attribute__((__mode__(__SI__)));
 typedef signed   int     ffi_sarg __attribute__((__mode__(__SI__)));
-#else
+#  else
 /* N32 and N64 frames have 64bit integer args */
 typedef unsigned int     ffi_arg __attribute__((__mode__(__DI__)));
 typedef signed   int     ffi_sarg __attribute__((__mode__(__DI__)));
+#  endif
+#else
+#  ifdef FFI_MIPS_O32
+/* O32 stack frames have 32bit integer args */
+typedef __uint32_t ffi_arg;
+typedef __int32_t ffi_sarg;
+#  else
+/* N32 and N64 frames have 64bit integer args */
+typedef __uint64_t ffi_arg;
+typedef __int64_t ffi_sarg;
+#  endif
 #endif
 
 typedef enum ffi_abi {
--- Modules/_ctypes/libffi/include/ffi.h.in.orig
+++ Modules/_ctypes/libffi/include/ffi.h.in
@@ -249,12 +249,22 @@ size_t ffi_java_raw_size (ffi_cif *cif);
 
 #if FFI_CLOSURES
 
+#ifdef __sgi
+# pragma pack 8
+#endif
 typedef struct {
   char tramp[FFI_TRAMPOLINE_SIZE];
   ffi_cif   *cif;
   void     (*fun)(ffi_cif*,void*,void**,void*);
   void      *user_data;
+#ifdef __GNUC__
 } ffi_closure __attribute__((aligned (8)));
+#else
+} ffi_closure;
+# ifdef __sgi
+#  pragma pack 0
+# endif
+#endif
 
 void *ffi_closure_alloc (size_t size, void **code);
 void ffi_closure_free (void *);
--- Modules/_ctypes/libffi/include/ffi_common.h.orig
+++ Modules/_ctypes/libffi/include/ffi_common.h
@@ -44,6 +44,14 @@ char *alloca ();
 # endif
 #endif
 
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_SYS_TYPES_H
+#  include <sys/types.h>
+# endif
+#endif
+
 #if defined(FFI_DEBUG)
 #include <stdio.h>
 #endif
@@ -77,6 +85,7 @@ typedef struct
 } extended_cif;
 
 /* Terse sized type definitions.  */
+#if defined(__GNUC__)
 typedef unsigned int UINT8  __attribute__((__mode__(__QI__)));
 typedef signed int   SINT8  __attribute__((__mode__(__QI__)));
 typedef unsigned int UINT16 __attribute__((__mode__(__HI__)));
@@ -85,6 +94,16 @@ typedef unsigned int UINT32 __attribute_
 typedef signed int   SINT32 __attribute__((__mode__(__SI__)));
 typedef unsigned int UINT64 __attribute__((__mode__(__DI__)));
 typedef signed int   SINT64 __attribute__((__mode__(__DI__)));
+#else
+typedef uint8_t  UINT8;
+typedef int8_t   SINT8;
+typedef uint16_t UINT16;
+typedef int16_t  SINT16;
+typedef uint32_t UINT32;
+typedef int32_t  SINT32;
+typedef uint64_t UINT64;
+typedef int64_t  SINT64;
+#endif
 
 typedef float FLOAT32;
 
--- Modules/_ctypes/stgdict.c.orig
+++ Modules/_ctypes/stgdict.c
@@ -8,6 +8,9 @@
 #include <windows.h>
 #include <malloc.h>
 #endif
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
 #include "ctypes.h"
 
 /******************************************************************/
