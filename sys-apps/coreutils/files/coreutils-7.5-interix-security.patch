diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/lib/euidaccess-stat.c coreutils-7.5/lib/euidaccess-stat.c
--- coreutils-7.5.orig/lib/euidaccess-stat.c	2009-08-25 11:33:26 +0200
+++ coreutils-7.5/lib/euidaccess-stat.c	2009-08-25 12:00:07 +0200
@@ -32,6 +32,14 @@
 # define R_OK 4
 #endif
 
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 #include "group-member.h"
 #include "stat-macros.h"
 
@@ -67,7 +75,7 @@
 
   /* The super-user can read and write any file, and execute any file
      that anyone can execute.  */
-  if (euid == 0 && ((mode & X_OK) == 0
+  if (euid == ROOT_UID && ((mode & X_OK) == 0
 		    || (st->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
     return true;
 
diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/lib/euidaccess.c coreutils-7.5/lib/euidaccess.c
--- coreutils-7.5.orig/lib/euidaccess.c	2009-08-25 11:33:26 +0200
+++ coreutils-7.5/lib/euidaccess.c	2009-08-25 11:55:31 +0200
@@ -68,6 +68,50 @@
 
 #endif
 
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+/* On interix, access() is broken, in that it can return success, even
+ * if the questioned bits are not set.
+ * This implementation has been mostly stolen from bash4. */
+static int _itx_access(char* file, int mode)
+{
+	/* emulate using stat, which returns the real bits set */
+	struct stat _st;
+
+	if(stat(file, &_st) != 0)
+		return -1;
+
+	if (getuid() == ROOT_UID)
+	{   
+		/* Root can read or write any file. */
+		if ((mode & X_OK) == 0)
+			return (0);
+
+		/* Root can execute any file that has any one of the execute
+		*      bits set. */
+		if (_st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))
+			return (0);
+	}   
+
+	if (_st.st_uid == getuid())   /* owner */
+		mode <<= 6;
+	else if (getgid() == _st.st_gid || group_member (_st.st_gid))
+		mode <<= 3;
+
+	if (_st.st_mode & mode)
+		return (0);
+
+	errno = EACCES;
+	return (-1);
+}
+
+# define access _itx_access
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 /* Return 0 if the user has permission of type MODE on FILE;
    otherwise, return -1 and set `errno'.
    Like access, except that it uses the effective user and group
@@ -141,7 +185,7 @@
 
   /* The super-user can read and write any file, and execute any file
      that anyone can execute.  */
-  if (euid == 0 && ((mode & X_OK) == 0
+  if (euid == ROOT_UID && ((mode & X_OK) == 0
 		    || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
     return 0;
 
diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/lib/unlinkdir.c coreutils-7.5/lib/unlinkdir.c
--- coreutils-7.5.orig/lib/unlinkdir.c	2009-08-25 11:33:42 +0200
+++ coreutils-7.5/lib/unlinkdir.c	2009-08-25 12:01:38 +0200
@@ -23,6 +23,14 @@
 #include "priv-set.h"
 #include <unistd.h>
 
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 #if ! UNLINK_CANNOT_UNLINK_DIR
 
 /* Return true if we cannot unlink directories, false if we might be
@@ -43,7 +51,7 @@
       cannot = (priv_set_ismember (PRIV_SYS_LINKDIR) == 0);
 # else
       /* In traditional Unix, only root can unlink directories.  */
-      cannot = (geteuid () != 0);
+      cannot = (geteuid () != ROOT_UID);
 # endif
       initialized = true;
     }
diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/lib/write-any-file.c coreutils-7.5/lib/write-any-file.c
--- coreutils-7.5.orig/lib/write-any-file.c	2009-08-25 11:33:42 +0200
+++ coreutils-7.5/lib/write-any-file.c	2009-08-25 12:02:23 +0200
@@ -24,6 +24,14 @@
 
 #include <unistd.h>
 
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 /* Return true if we know that we can write any file, including
    writing directories.  */
 
@@ -40,7 +48,7 @@
       can = (priv_set_ismember (PRIV_FILE_DAC_WRITE) == 1);
 #else
       /* In traditional Unix, only root can unlink directories.  */
-      can = (geteuid () == 0);
+      can = (geteuid () == ROOT_UID);
 #endif
       can_write = can;
       initialized = true;
diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/src/copy.c coreutils-7.5/src/copy.c
--- coreutils-7.5.orig/src/copy.c	2009-08-25 11:34:04 +0200
+++ coreutils-7.5/src/copy.c	2009-08-25 12:03:26 +0200
@@ -65,6 +65,14 @@
 # include <sys/ioctl.h>
 #endif
 
+#ifdef __INTERIX
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 #ifndef HAVE_FCHOWN
 # define HAVE_FCHOWN false
 # define fchown(fd, uid, gid) (-1)
@@ -2294,7 +2302,7 @@
     priv_freeset (pset);
   }
 #else
-  x->chown_privileges = x->owner_privileges = (geteuid () == 0);
+  x->chown_privileges = x->owner_privileges = (geteuid () == ROOT_UID);
 #endif
 }
 
diff -ru -x '*.Po' -x '*.Plo' coreutils-7.5.orig/src/su.c coreutils-7.5/src/su.c
--- coreutils-7.5.orig/src/su.c	2009-08-25 11:34:15 +0200
+++ coreutils-7.5/src/su.c	2009-08-25 13:12:53 +0200
@@ -98,6 +98,15 @@
 # include <paths.h>
 #endif
 
+#ifdef __INTERIX
+# include <interix/security.h>
+# define ROOT_UID 197108
+# define ROOT_GID 131616
+#else
+# define ROOT_UID 0
+# define ROOT_GID 0
+#endif
+
 /* The default PATH for simulated logins to non-superuser accounts.  */
 #ifdef _PATH_DEFPATH
 # define DEFAULT_LOGIN_PATH _PATH_DEFPATH
@@ -116,7 +125,7 @@
 #define DEFAULT_SHELL "/bin/sh"
 
 /* The user to become if none is specified.  */
-#define DEFAULT_USER "root"
+#define DEFAULT_UID ROOT_UID
 
 char *crypt (char const *key, char const *salt);
 char *getusershell (void);
@@ -218,7 +227,7 @@
    or if PW has an empty password.  */
 
 static bool
-correct_password (const struct passwd *pw)
+correct_password (struct passwd *pw)
 {
   char *unencrypted, *encrypted, *correct;
 #if HAVE_GETSPNAM && HAVE_STRUCT_SPWD_SP_PWDP
@@ -232,7 +241,7 @@
 #endif
     correct = pw->pw_passwd;
 
-  if (getuid () == 0 || !correct || correct[0] == '\0')
+  if (getuid () == ROOT_UID || !correct || correct[0] == '\0')
     return true;
 
   unencrypted = getpass (_("Password:"));
@@ -241,9 +250,20 @@
       error (0, 0, _("getpass: cannot open /dev/tty"));
       return false;
     }
+#ifndef __INTERIX
   encrypted = crypt (unencrypted, correct);
   memset (unencrypted, 0, strlen (unencrypted));
   return STREQ (encrypted, correct);
+#else
+  /* on interix, we need the full password to successfully change
+   * the user */
+  if(setuser(pw->pw_name, unencrypted, SU_CHECK) == 0)
+	pw->pw_passwd = xstrdup(unencrypted);
+  else
+    return false;
+
+  return true;
+#endif
 }
 
 /* Update `environ' for the new shell based on PW, with SHELL being
@@ -267,7 +287,7 @@
       xsetenv ("SHELL", shell);
       xsetenv ("USER", pw->pw_name);
       xsetenv ("LOGNAME", pw->pw_name);
-      xsetenv ("PATH", (pw->pw_uid
+      xsetenv ("PATH", (pw->pw_uid != ROOT_UID
 			? DEFAULT_LOGIN_PATH
 			: DEFAULT_ROOT_LOGIN_PATH));
     }
@@ -279,7 +299,7 @@
 	{
 	  xsetenv ("HOME", pw->pw_dir);
 	  xsetenv ("SHELL", shell);
-	  if (pw->pw_uid)
+	  if (pw->pw_uid != ROOT_UID)
 	    {
 	      xsetenv ("USER", pw->pw_name);
 	      xsetenv ("LOGNAME", pw->pw_name);
@@ -291,7 +311,7 @@
 /* Become the user and group(s) specified by PW.  */
 
 static void
-change_identity (const struct passwd *pw)
+change_identity (struct passwd *pw)
 {
 #ifdef HAVE_INITGROUPS
   errno = 0;
@@ -299,10 +319,20 @@
     error (EXIT_FAILURE, errno, _("cannot set groups"));
   endgrent ();
 #endif
+#ifndef __INTERIX
   if (setgid (pw->pw_gid))
     error (EXIT_FAILURE, errno, _("cannot set group id"));
   if (setuid (pw->pw_uid))
     error (EXIT_FAILURE, errno, _("cannot set user id"));
+#else
+  if(setuser(pw->pw_name, pw->pw_passwd, SU_COMPLETE) != 0)
+	error (EXIT_FAILURE, errno, _("cannot set user"));
+
+  /* wipe the stored password */
+  memset(pw->pw_passwd, 0, sizeof(pw->pw_passwd));
+  free(pw->pw_passwd);
+  pw->pw_passwd = xstrdup("*");
+#endif
 }
 
 /* Run SHELL, or DEFAULT_SHELL if SHELL is empty.
@@ -404,7 +434,7 @@
 main (int argc, char **argv)
 {
   int optc;
-  const char *new_user = DEFAULT_USER;
+  const char *new_user = NULL;
   char *command = NULL;
   char *shell = NULL;
   struct passwd *pw;
@@ -465,7 +495,11 @@
   if (optind < argc)
     new_user = argv[optind++];
 
-  pw = getpwnam (new_user);
+  if(new_user)
+    pw = getpwnam (new_user);
+  else 
+    pw = getpwuid(DEFAULT_UID);
+
   if (! (pw && pw->pw_name && pw->pw_name[0] && pw->pw_dir && pw->pw_dir[0]
 	 && pw->pw_passwd))
     error (EXIT_FAILURE, 0, _("user %s does not exist"), new_user);
@@ -502,7 +536,7 @@
 
   if (!shell && !change_environment)
     shell = getenv ("SHELL");
-  if (shell && getuid () != 0 && restricted_shell (pw->pw_shell))
+  if (shell && getuid () != ROOT_UID && restricted_shell (pw->pw_shell))
     {
       /* The user being su'd to has a nonstandard shell, and so is
 	 probably a uucp account or has restricted access.  Don't
