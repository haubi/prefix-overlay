diff -ur lib/mountlist.c lib/mountlist.c
--- lib/mountlist.c	Fri Jan 26 22:16:54 2007
+++ lib/mountlist.c	Sat Dec 29 21:53:20 2007
@@ -339,6 +339,7 @@
    If NEED_FS_TYPE is true, ensure that the file system type fields in
    the returned list are valid.  Otherwise, they might not be.  */
 
+#ifndef __MINT__
 struct mount_entry *
 read_file_system_list (bool need_fs_type)
 {
@@ -883,3 +884,82 @@
     return NULL;
   }
 }
+
+#else /* __MINT__ */
+
+#include <mintbind.h>
+#include <osbind.h>
+#include <sys/statfs.h>
+#include <mint/dcntl.h>
+
+/* get the list of available drives */
+static long
+get_drives(void)
+{
+	long drive_bits;
+	
+	drive_bits = Dsetdrv(Dgetdrv());
+	drive_bits &= ~(1|2); /* exclude all floppies */
+		
+	return drive_bits;
+}
+
+struct mount_entry *
+read_file_system_list (bool need_fs_type)
+{
+	struct mount_entry *mount_list;
+	struct mount_entry *me;
+	struct mount_entry *mtail;
+	struct statfs fsp;
+	struct fs_info info;
+	long drive_bits;
+	int i, j;
+	char lw[] = "a:/", str[25];
+	
+	/* Start the list off with a dummy entry. */
+	me = xmalloc (sizeof (*me));
+	me->me_next = NULL;
+	mount_list = mtail = me;
+	
+	drive_bits = get_drives();
+	for (i = 0; i < 32; i++)
+	{
+		if (drive_bits & (1L << i))
+		{
+			if (i < 26)
+				lw[0] = 'a' + i;
+			else
+				lw[0] = '1' + i - 26;
+			
+			if(statfs(lw, &fsp) == 0)
+			{
+				char name[32];
+
+				me = xmalloc (sizeof (*me));
+				
+				me->me_devname  = xstrdup(lw);
+				me->me_mountdir = xstrdup("u:/");
+				
+				if (lw[0] < 'a')				/* 1: .. 6: */
+					me->me_dev = lw[0] - '1' + 27;
+				else
+					me->me_dev = lw[0] - 'a';
+				
+				get_fsname(lw, NULL, name);
+				me->me_type = xstrdup(name);
+				/* Add to the linked list. */
+				me->me_next = NULL;
+				mtail->me_next = me;
+				mtail = me;
+			}
+		}
+	}
+	
+	/* Free the dummy head. */
+	me = mount_list;
+	mount_list = mount_list->me_next;
+	free(me);
+	return mount_list;
+}
+
+#endif /* __MINT__ */
diff -ur src/df.c src/df.c
--- src/df.c	Sat Jan 13 05:23:36 2007
+++ src/df.c	Mon Dec 24 20:56:36 2007
@@ -300,7 +300,12 @@
      It would be better to report on the unmounted file system,
      but statfs doesn't do that on most systems.  */
   if (!stat_file)
+#ifndef __MINT__
     stat_file = mount_point ? mount_point : disk;
+#else
+    /* MiNT: mount_point is always u:/, so use disk */
+    stat_file = disk;
+#endif
 
   if (get_fs_usage (stat_file, disk, &fsu))
     {
diff -ur src/uptime.c src/uptime.c
--- src/uptime.c	Sat Jan 13 05:23:36 2007
+++ src/uptime.c	Mon Dec 24 20:56:36 2007
@@ -18,6 +18,9 @@
 /* Created by hacking who.c by Kaveh Ghazi ghazi@caip.rutgers.edu.  */
 
 #include <config.h>
+#ifdef __MINT__
+#define HAVE_PROC_UPTIME 1
+#endif
 #include <getopt.h>
 #include <stdio.h>
 
@@ -64,7 +67,11 @@
 #ifdef HAVE_PROC_UPTIME
   FILE *fp;
 
+#ifdef __MINT__
+  fp = fopen ("/kern/uptime", "r");
+#else
   fp = fopen ("/proc/uptime", "r");
+#endif
   if (fp != NULL)
     {
       char buf[BUFSIZ];
diff -ur lib/physmem.c lib/physmem.c
--- lib/physmem.c	Sat Jan 13 05:23:36 2007
+++ lib/physmem.c	Mon Dec 24 20:56:36 2007
@@ -25,6 +25,31 @@
 
 #include <unistd.h>
 
+#ifdef __MINT__
+#include <mint/osbind.h>
+#include <mint/sysctl.h>
+
+static double
+freemem(void)
+{
+  int call[2] = { CTL_HW, HW_FREEPHYSMEM };
+  unsigned long free;
+  unsigned long freesize = sizeof (free);
+  long ret;
+
+  ret = sysctl (call, 2, &free, &freesize, NULL, 0);
+  if (ret == 0)
+    return free / 2;
+  
+  ret = Malloc(-1);
+  if (ret > 0)
+    return ret / 2;
+  
+  /* Guess 1 MB.  */
+  return 1024 * 1024;
+}
+#endif
+
 #if HAVE_SYS_PSTAT_H
 # include <sys/pstat.h>
 #endif
@@ -91,6 +116,10 @@
   }
 #endif
 
+#ifdef __MINT__
+  return freemem();
+#endif
+
 #if HAVE_PSTAT_GETSTATIC
   { /* This works on hpux11.  */
     struct pst_static pss;
@@ -193,6 +222,10 @@
     if (0 <= pages && 0 <= pagesize)
       return pages * pagesize;
   }
+#endif
+
+#ifdef __MINT__
+  return freemem();
 #endif
 
 #if HAVE_PSTAT_GETSTATIC && HAVE_PSTAT_GETDYNAMIC
diff -u lib/fpurge.c.old lib/fpurge.c
--- lib/fpurge.c.old	2008-04-17 10:59:17.000000000 +0100
+++ lib/fpurge.c	2008-05-21 22:49:04.000000000 +0100
@@ -124,6 +124,12 @@
     /* fp->_Buf <= fp->_Next <= fp->_Rend */
     fp->_Rend = fp->_Next;
   return 0;
+# elif defined __MINT__
+  fp->__pushback_bufp = 0;
+  if (fp->__mode.__write)
+    fp->__put_limit = fp->__buffer;
+  fp->__bufp = fp->__get_limit;
+  return 0;
 # else
  #error "Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib."
 # endif
diff -u lib/freadahead.c.old lib/freadahead.c
--- lib/freadahead.c.old	2008-04-17 10:59:17.000000000 +0100
+++ lib/freadahead.c	2008-05-21 23:23:56.000000000 +0100
@@ -90,6 +90,12 @@
 	 + (fp->_Mode & 0x4000 /* _MBYTE */
 	    ? (fp->_Back + sizeof (fp->_Back)) - fp->_Rback
 	    : 0);
+#elif defined __MINT__
+  if (fp->__mode.__write)
+    return 0;
+  if (fp->__pushed_back)
+    return (fp->__get_limit - fp->__pushback_bufp + 1);
+  return (fp->__get_limit - fp->__bufp);
 #else
  #error "Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib."
 #endif
diff -u lib/freading.c.old lib/freading.c
--- lib/freading.c.old	2008-04-17 10:59:17.000000000 +0100
+++ lib/freading.c	2008-05-21 23:25:32.000000000 +0100
@@ -47,6 +47,13 @@
 #elif defined __QNX__               /* QNX */
   return ((fp->_Mode & 0x2 /* _MOPENW */) == 0
 	  || (fp->_Mode & 0x1000 /* _MREAD */) != 0);
+#elif defined __MINT__
+  if (!fp->__mode.__write && fp->__mode.__read)
+    return 1;
+  return (fp->__mode.__read &&
+          fp->__get_limit > fp->__bufp &&
+          fp->__get_limit > fp->__put_limit &&
+          fp->__bufp > fp->__buffer);
 #else
  #error "Please port gnulib freading.c to your platform!"
 #endif
diff -u lib/fseeko.c.old lib/fseeko.c
--- lib/fseeko.c.old	2008-04-19 22:36:52.000000000 +0100
+++ lib/fseeko.c	2008-05-22 10:30:33.000000000 +0100
@@ -107,6 +107,8 @@
   if ((fp->_Mode & _MWRITE ? fp->_Next == fp->_Buf : fp->_Next == fp->_Rend)
       && fp->_Rback == fp->_Back + sizeof (fp->_Back)
       && fp->_Rsave == NULL)
+#elif defined __MINT__
+  if (0)
 #else
   #error "Please port gnulib fseeko.c to your platform! Look at the code in fpurge.c, then report this to bug-gnulib."
 #endif
diff -u lib/fseterr.c.old lib/fseterr.c
--- lib/fseterr.c.old	2008-04-17 10:59:17.000000000 +0100
+++ lib/fseterr.c	2008-05-21 23:29:29.000000000 +0100
@@ -53,6 +53,8 @@
   fp->__modeflags |= __FLAG_ERROR;
 #elif defined __QNX__               /* QNX */
   fp->_Mode |= 0x200 /* _MERR */;
+#elif defined __MINT__
+  fp->__error |= 1;
 #elif 0                             /* unknown  */
   /* Portable fallback, based on an idea by Rich Felker.
      Wow! 6 system calls for something that is just a bit operation!
--- lib/freadptr.c.old	2008-06-10 08:47:50.000000000 +0100
+++ lib/freadptr.c	2008-06-10 08:48:23.000000000 +0100
@@ -85,6 +85,14 @@
     return NULL;
   *sizep = size;
   return (const char *) fp->_Next;
+#elif defined __MINT__
+  if (fp->__mode.__write)
+    return NULL;
+  size = fp->__get_limit - fp->__bufp;
+  if (size == 0)
+    return NULL;
+  *sizep = size;
+  return (const char *) fp->__bufp;
 #else
  #error "Please port gnulib freadptr.c to your platform! Look at the definition of fflush, fread, getc, getc_unlocked on your system, then report this to bug-gnulib."
 #endif
--- lib/freadseek.c.old	2008-06-10 08:51:10.000000000 +0100
+++ lib/freadseek.c	2008-06-10 08:51:36.000000000 +0100
@@ -53,6 +53,8 @@
 # endif
 #elif defined __QNX__               /* QNX */
   fp->_Next += increment;
+#elif defined __MINT__
+  fp->__bufp += increment;
 #else
  #error "Please port gnulib freadseek.c to your platform! Look at the definition of getc, getc_unlocked on your system, then report this to bug-gnulib."
 #endif
--- lib/mgetgroups.c.old	2008-06-10 19:31:44.000000000 +0100
+++ lib/mgetgroups.c	2008-06-10 19:33:17.000000000 +0100
@@ -36,6 +36,9 @@
 static void *
 allocate_groupbuf (int size)
 {
+#ifdef __MINT__
+  return calloc (1, size * sizeof(GETGROUPS_T));
+#else
   if (xalloc_oversized (size, sizeof (GETGROUPS_T)))
     {
       errno = ENOMEM;
@@ -43,6 +46,7 @@
     }
 
   return malloc (size * sizeof (GETGROUPS_T));
+#endif
 }
 
 /* Like getugroups, but store the result in malloc'd storage.
