--- bin/dispatch-conf~	2007-10-01 04:03:02 +0200
+++ bin/dispatch-conf	2007-10-01 04:33:43 +0200
@@ -202,10 +202,10 @@
 		# Interactively process remaining
 		#
 
-        valid_input = "qhtnmlezu"
+		valid_input = "qhtnmlezu"
 
-        for conf in confs:
-            count = count + 1
+		for conf in confs:
+			count = count + 1
 
 			newconf = conf['new']
 			mrgconf = re.sub(r'\._cfg', '._mrg', newconf)
@@ -224,67 +224,67 @@
 				print '>> (%i of %i) -- %s' % (count, len(confs), conf ['current'])
 				print '>> q quit, h help, n next, e edit-new, z zap-new, u use-new\n   m merge, t toggle-merge, l look-merge: ',
 
-                # In some cases getch() will return some spurious characters
-                # that do not represent valid input. If we don't validate the
-                # input then the spurious characters can cause us to jump
-                # back into the above "diff" command immediatly after the user
-                # has exited it (which can be quite confusing and gives an
-                # "out of control" feeling).
-                while True:
-                    c = getch()
-                    if c in valid_input:
-                        break
-
-                if c == 'q':
-                    sys.exit (0)
-                if c == 'h':
-                    self.do_help ()
-                    continue
-                elif c == 't':
-                    if newconf == mrgconf:
-                        newconf = conf['new']
-                    elif os.path.exists(mrgconf):
-                        newconf = mrgconf
-                    continue
-                elif c == 'n':
-                    break
-                elif c == 'm':
-                    merged = SCRATCH_DIR+"/"+os.path.basename(conf['current'])
-                    print
-                    ret = os.system (self.options['merge'] % (merged, conf ['current'], newconf))
-                    if ret:
-                        print "Failure running 'merge' command"
-                        continue
-                    shutil.copyfile(merged, mrgconf)
-                    os.remove(merged)
-                    mystat = os.lstat(conf['new'])
-                    os.chmod(mrgconf, mystat[ST_MODE])
-                    os.chown(mrgconf, mystat[ST_UID], mystat[ST_GID])
-                    newconf = mrgconf
-                    continue
-                elif c == 'l':
-                    show_new_diff = 1
-                    continue
-                elif c == 'e':
-                    if not os.environ.has_key('EDITOR'):
-                        os.environ['EDITOR']='nano'
-                    os.system(os.environ['EDITOR'] + ' ' + newconf)
-                    continue
-                elif c == 'z':
-                    os.unlink(conf['new'])
-                    if os.path.exists(mrgconf):
-                        os.unlink(mrgconf)
-                    break
-                elif c == 'u':
-                    self.replace(newconf, conf ['current'])
-                    self.post_process(conf['current'])
-                    if newconf == mrgconf:
-                        os.unlink(conf['new'])
-                    elif os.path.exists(mrgconf):
-                        os.unlink(mrgconf)
-                    break
-                else:
-                    raise AssertionError("Invalid Input: %s" % c)
+				# In some cases getch() will return some spurious characters
+				# that do not represent valid input. If we don't validate the
+				# input then the spurious characters can cause us to jump
+				# back into the above "diff" command immediatly after the user
+				# has exited it (which can be quite confusing and gives an
+				# "out of control" feeling).
+				while True:
+					c = getch()
+					if c in valid_input:
+						break
+
+				if c == 'q':
+					sys.exit (0)
+				if c == 'h':
+					self.do_help ()
+					continue
+				elif c == 't':
+					if newconf == mrgconf:
+						newconf = conf['new']
+					elif os.path.exists(mrgconf):
+						newconf = mrgconf
+					continue
+				elif c == 'n':
+					break
+				elif c == 'm':
+					merged = SCRATCH_DIR+"/"+os.path.basename(conf['current'])
+					print
+					ret = os.system (self.options['merge'] % (merged, conf ['current'], newconf))
+					if ret:
+						print "Failure running 'merge' command"
+						continue
+					shutil.copyfile(merged, mrgconf)
+					os.remove(merged)
+					mystat = os.lstat(conf['new'])
+					os.chmod(mrgconf, mystat[ST_MODE])
+					os.chown(mrgconf, mystat[ST_UID], mystat[ST_GID])
+					newconf = mrgconf
+					continue
+				elif c == 'l':
+					show_new_diff = 1
+					continue
+				elif c == 'e':
+					if not os.environ.has_key('EDITOR'):
+						os.environ['EDITOR']='nano'
+					os.system(os.environ['EDITOR'] + ' ' + newconf)
+					continue
+				elif c == 'z':
+					os.unlink(conf['new'])
+					if os.path.exists(mrgconf):
+						os.unlink(mrgconf)
+					break
+				elif c == 'u':
+					self.replace(newconf, conf ['current'])
+					self.post_process(conf['current'])
+					if newconf == mrgconf:
+						os.unlink(conf['new'])
+					elif os.path.exists(mrgconf):
+						os.unlink(mrgconf)
+					break
+				else:
+					raise AssertionError("Invalid Input: %s" % c)
 
 		if auto_zapped:
 			print
