Index: pym/portage/dbapi/bintree.py
===================================================================
--- pym/portage/dbapi/bintree.py	(revision 12574)
+++ pym/portage/dbapi/bintree.py	(working copy)
@@ -13,7 +13,7 @@
 from portage.util import ensure_dirs, normalize_path, writemsg, writemsg_stdout
 from portage.versions import best, catpkgsplit, catsplit
 from portage.update import update_dbentries
-from portage.const import EAPI, EAPIPREFIX
+from portage.const import EAPI, EAPIPREFIX, BPREFIX
 
 from portage import dep_expand, listdir, _check_distfile, _movefile
 
@@ -649,7 +649,7 @@
 			from portage.const import CACHE_PATH
 			from urlparse import urlparse
 			urldata = urlparse(base_url)
-			pkgindex_file = os.path.join(CACHE_PATH, "binhost",
+			pkgindex_file = os.path.join(BPREFIX, CACHE_PATH, "binhost",
 				urldata[1] + urldata[2], "Packages")
 			pkgindex = self._new_pkgindex()
 			try:
Index: pym/portage/dbapi/vartree.py
===================================================================
--- pym/portage/dbapi/vartree.py	(revision 12574)
+++ pym/portage/dbapi/vartree.py	(working copy)
@@ -8,7 +8,7 @@
 
 from portage.checksum import perform_md5
 from portage.const import CACHE_PATH, CONFIG_MEMORY_FILE, \
-	PORTAGE_PACKAGE_ATOM, PRIVATE_PATH, VDB_PATH, EPREFIX, EPREFIX_LSTRIP
+	PORTAGE_PACKAGE_ATOM, PRIVATE_PATH, VDB_PATH, EPREFIX, BROOT, EROOTobject, BPREFIX
 from portage.data import portage_gid, portage_uid, secpass, ostype
 from portage.dbapi import dbapi
 from portage.dep import use_reduce, paren_reduce, isvalidatom, \
@@ -216,7 +216,7 @@
 				2. realpath of object if object does not exist.
 
 			"""
-			abs_path = os.path.join(root, obj.lstrip(os.sep))
+			abs_path = os.path.join(root(), obj.lstrip(os.sep))
 			try:
 				object_stat = os.stat(abs_path)
 			except OSError:
@@ -254,7 +254,7 @@
 		and the scanelf binary is not available.
 		"""
 		root = self._root
-		root_len = len(root) - 1
+		root_len = len(root()) - 1
 		self._clear_cache()
 		self._defpath.update(getlibpaths(self._root))
 		libs = self._libs
@@ -279,9 +279,9 @@
 		# have to call scanelf for preserved libs here as they aren't 
 		# registered in NEEDED.ELF.2 files
 		if self._dbapi.plib_registry and self._dbapi.plib_registry.getPreservedLibs():
-			args = [EPREFIX+"/usr/bin/scanelf", "-qF", "%a;%F;%S;%r;%n"]
+			args = [BPREFIX+"/usr/bin/scanelf", "-qF", "%a;%F;%S;%r;%n"]
 			for items in self._dbapi.plib_registry.getPreservedLibs().values():
-				args.extend(os.path.join(root, x.lstrip("." + os.sep)) \
+				args.extend(os.path.join(root(), x.lstrip("." + os.sep)) \
 					for x in items)
 			try:
 				proc = subprocess.Popen(args, stdout=subprocess.PIPE)
@@ -761,7 +761,7 @@
 				2. realpath of object if object does not exist.
 
 			"""
-			abs_path = os.path.join(root, obj.lstrip(os.path.sep))
+			abs_path = os.path.join(root(), obj.lstrip(os.path.sep))
 			try:
 				object_stat = os.stat(abs_path)
 			except OSError:
@@ -799,7 +799,7 @@
 		and the scanmacho binary is not available.
 		"""
 		root = self._root
-		root_len = len(root) - 1
+		root_len = len(root()) - 1
 		self._clear_cache()
 		libs = self._libs
 		obj_key_cache = self._obj_key_cache
@@ -823,9 +823,9 @@
 		# have to call scanmacho for preserved libs here as they aren't 
 		# registered in NEEDED.MACHO.3 files
 		if self._dbapi.plib_registry and self._dbapi.plib_registry.getPreservedLibs():
-			args = [EPREFIX+"/usr/bin/scanmacho", "-qF", "%a;%F;%S;%n"]
+			args = [BPREFIX+"/usr/bin/scanmacho", "-qF", "%a;%F;%S;%n"]
 			for items in self._dbapi.plib_registry.getPreservedLibs().values():
-				args.extend(os.path.join(root, x.lstrip("." + os.sep)) \
+				args.extend(os.path.join(root(), x.lstrip("." + os.sep)) \
 						for x in items)
 			try:
 				proc = subprocess.Popen(args, stdout=subprocess.PIPE)
@@ -1235,7 +1235,7 @@
 		now has a categories property that is generated from the
 		available packages.
 		"""
-		self.root = root[:]
+		self.root = root
 
 		#cache for category directory mtimes
 		self.mtdircache = {}
@@ -1260,14 +1260,14 @@
 			"LICENSE", "PDEPEND", "PROPERTIES", "PROVIDE", "RDEPEND",
 			"repository", "RESTRICT" , "SLOT", "USE"])
 		self._aux_cache_obj = None
-		self._aux_cache_filename = os.path.join(self.root,
-			CACHE_PATH.lstrip(os.path.sep), "vdb_metadata.pickle")
-		self._counter_path = os.path.join(root,
-			CACHE_PATH.lstrip(os.path.sep), "counter")
+		self._aux_cache_filename = os.path.join(self.root(),
+			CACHE_PATH, "vdb_metadata.pickle")
+		self._counter_path = os.path.join(self.root(),
+			CACHE_PATH, "counter")
 
 		try:
 			self.plib_registry = PreservedLibsRegistry(
-				os.path.join(self.root, EPREFIX_LSTRIP, PRIVATE_PATH, "preserved_libs_registry"))
+				os.path.join(self.root(), PRIVATE_PATH, "preserved_libs_registry"))
 		except PermissionDenied:
 			# apparently this user isn't allowed to access PRIVATE_PATH
 			self.plib_registry = None
@@ -1279,7 +1279,7 @@
 		self._owners = self._owners_db(self)
 
 	def getpath(self, mykey, filename=None):
-		rValue = os.path.join(self.root, VDB_PATH, mykey)
+		rValue = os.path.join(self.root(), VDB_PATH, mykey)
 		if filename != None:
 			rValue = os.path.join(rValue, filename)
 		return rValue
@@ -1426,7 +1426,7 @@
 		involve merge or unmerge of packages).
 		"""
 		returnme = []
-		basepath = os.path.join(self.root, VDB_PATH) + os.path.sep
+		basepath = os.path.join(self.root(), VDB_PATH) + os.path.sep
 
 		if use_cache:
 			from portage import listdir
@@ -1517,7 +1517,7 @@
 			return list(self._iter_match(mydep,
 				self.cp_list(mydep.cp, use_cache=use_cache)))
 		try:
-			curmtime = os.stat(self.root+VDB_PATH+"/"+mycat).st_mtime
+			curmtime = os.stat(self.root()+VDB_PATH+"/"+mycat).st_mtime
 		except (IOError, OSError):
 			curmtime=0
 
@@ -1835,7 +1835,7 @@
 		if not hasattr(pkg, "getcontents"):
 			pkg = self._dblink(pkg)
 		root = self.root
-		root_len = len(root) - 1
+		root_len = len(root.root()) - 1
 		new_contents = pkg.getcontents().copy()
 		removed = 0
 
@@ -1845,14 +1845,14 @@
 				relative_filename = filename
 			else:
 				relative_filename = filename[root_len:]
-			contents_key = pkg._match_contents(relative_filename, root)
+			contents_key = pkg._match_contents(relative_filename, root.root())
 			if contents_key:
 				del new_contents[contents_key]
 				removed += 1
 
 		if removed:
 			f = atomic_ofstream(os.path.join(pkg.dbdir, "CONTENTS"))
-			write_contents(new_contents, root, f)
+			write_contents(new_contents, root.root(), f)
 			f.close()
 			pkg._clear_contents_cache()
 
@@ -1875,7 +1875,7 @@
 			self._vardb = vardb
 
 		def add(self, cpv):
-			root_len = len(self._vardb.root)
+			root_len = len(self._vardb.root.root())
 			contents = self._vardb._dblink(cpv).getcontents()
 			pkg_hash = self._hash_pkg(cpv)
 			if not contents:
@@ -2044,18 +2044,18 @@
 
 class vartree(object):
 	"this tree will scan a var/db/pkg database located at root (passed to init)"
-	def __init__(self, root="/", virtual=None, clone=None, categories=None,
+	def __init__(self, root=BROOT, virtual=None, clone=None, categories=None,
 		settings=None):
 		if clone:
 			writemsg("vartree.__init__(): deprecated " + \
 				"use of clone parameter\n", noiselevel=-1)
-			self.root = clone.root[:]
+			self.root = clone.root
 			self.dbapi = copy.deepcopy(clone.dbapi)
 			self.populated = 1
 			from portage import config
 			self.settings = config(clone=clone.settings)
 		else:
-			self.root = root[:]
+			self.root = root
 			if settings is None:
 				from portage import settings
 			self.settings = settings # for key_expand calls
@@ -2091,7 +2091,7 @@
 		except SystemExit, e:
 			raise
 		except Exception, e:
-			mydir = os.path.join(self.root, VDB_PATH, mycpv)
+			mydir = os.path.join(self.root(), VDB_PATH, mycpv)
 			writemsg("\nParse Error reading PROVIDE and USE in '%s'\n" % mydir,
 				noiselevel=-1)
 			if mylines:
@@ -2237,8 +2237,8 @@
 		@type cat: String
 		@param pkg: Package (PV)
 		@type pkg: String
-		@param myroot: Typically ${ROOT}
-		@type myroot: String (Path)
+ 		@param myroot: Typically ${EROOT}
+ 		@type myroot: EROOTobject
 		@param mysettings: Typically portage.config
 		@type mysettings: An instance of portage.config
 		@param treetype: one of ['porttree','bintree','vartree']
@@ -2247,6 +2247,7 @@
 		@type vartree: vartree
 		"""
 		
+		myroot = EROOTobject.ify(myroot, EPREFIX)
 		self.cat = cat
 		self.pkg = pkg
 		self.mycpv = self.cat + "/" + self.pkg
@@ -2260,7 +2261,7 @@
 		self._blockers = blockers
 		self._scheduler = scheduler
 
-		self.dbroot = normalize_path(os.path.join(myroot, VDB_PATH))
+		self.dbroot = normalize_path(os.path.join(myroot(), VDB_PATH))
 		self.dbcatdir = self.dbroot+"/"+cat
 		self.dbpkgdir = self.dbcatdir+"/"+pkg
 		self.dbtmpdir = self.dbcatdir+"/-MERGING-"+pkg
@@ -2354,7 +2355,7 @@
 		normalize_needed = self._normalize_needed
 		contents_split_counts = self._contents_split_counts
 		myroot = self.myroot
-		if myroot == os.path.sep:
+		if myroot == BROOT:
 			myroot = None
 		pos = 0
 		errors = []
@@ -2401,7 +2402,7 @@
 					if not mydat[1].startswith(os.path.sep):
 						mydat[1] = os.path.sep + mydat[1]
 				if myroot:
-					mydat[1] = os.path.join(myroot, mydat[1].lstrip(os.path.sep))
+					mydat[1] = os.path.join(myroot.root(), mydat[1].lstrip(os.path.sep))
 				if mydat[0] == "obj":
 					#format: type, mtime, md5sum
 					pkgfiles[mydat[1]] = [mydat[0], mydat[3], mydat[2]]
@@ -2718,11 +2719,10 @@
 					self.vartree.root, self.settings,
 					vartree=self.vartree, treetype="vartree"))
 
-		dest_root = normalize_path(self.vartree.root).rstrip(os.path.sep) + \
-			os.path.sep
-		dest_root_len = len(dest_root) - 1
+		dest_root = self.vartree.root
+		dest_root_len = len(dest_root.root()) - 1
 
-		conf_mem_file = os.path.join(dest_root, EPREFIX_LSTRIP, CONFIG_MEMORY_FILE)
+		conf_mem_file = os.path.join(self.vartree.root(), CONFIG_MEMORY_FILE)
 		cfgfiledict = grabdict(conf_mem_file)
 		stale_confmem = []
 
@@ -2743,7 +2743,7 @@
 				errno.EEXIST, errno.ENOTEMPTY,
 				errno.EBUSY, errno.ENOENT,
 				errno.ENOTDIR, errno.EISDIR)
-			modprotect = os.path.join(self.vartree.root, "lib/modules/")
+			modprotect = os.path.join(self.vartree.root(), "lib/modules/")
 
 			def unlink(file_name, lstatobj):
 				if bsd_chflags:
@@ -2792,7 +2792,7 @@
 				if lstatobj is None:
 						show_unmerge("---", "!found", file_type, obj)
 						continue
-				if obj.startswith(dest_root):
+				if obj.startswith(dest_root.root()):
 					relative_path = obj[dest_root_len:]
 					is_owned = False
 					for dblnk in others_in_slot:
@@ -2965,7 +2965,7 @@
 		"""
 
 		destfile = normalize_path(
-			os.path.join(destroot, filename.lstrip(os.path.sep)))
+			os.path.join(destroot.root(), filename.lstrip(os.path.sep)))
 
 		pkgfiles = self.getcontents()
 		if pkgfiles and destfile in pkgfiles:
@@ -3048,7 +3048,7 @@
 		installed_instance = self._installed_instance
 		old_contents = installed_instance.getcontents()
 		root = self.myroot
-		root_len = len(root) - 1
+		root_len = len(root()) - 1
 		lib_graph = digraph()
 		path_node_map = {}
 
@@ -3146,7 +3146,7 @@
 		new_contents = self.getcontents().copy()
 		old_contents = self._installed_instance.getcontents()
 		for f in sorted(preserve_paths):
-			f_abs = os.path.join(root, f.lstrip(os.sep))
+			f_abs = os.path.join(root(), f.lstrip(os.sep))
 			contents_entry = old_contents.get(f_abs)
 			if contents_entry is None:
 				# This will probably never happen, but it might if one of the
@@ -3165,14 +3165,14 @@
 				noiselevel=-1)
 			# Add parent directories to contents if necessary.
 			parent_dir = os.path.dirname(f_abs)
-			while len(parent_dir) > len(root):
+			while len(parent_dir) > len(root()):
 				new_contents[parent_dir] = ["dir"]
 				prev = parent_dir
 				parent_dir = os.path.dirname(parent_dir)
 				if prev == parent_dir:
 					break
 		outfile = atomic_ofstream(os.path.join(self.dbtmpdir, "CONTENTS"))
-		write_contents(new_contents, root, outfile)
+		write_contents(new_contents, root.root(), outfile)
 		outfile.close()
 		self._clear_contents_cache()
 
@@ -3198,9 +3198,9 @@
 			node = path_node_map.get(path)
 			if node is None:
 				if ostype == "Darwin":
-					node = LinkageMapMachO._LibGraphNode(path, root)
+					node = LinkageMapMachO._LibGraphNode(path, root())
 				else:
-					node = LinkageMap._LibGraphNode(path, root)
+					node = LinkageMap._LibGraphNode(path, root())
 				alt_path_node = lib_graph.get(node)
 				if alt_path_node is not None:
 					node = alt_path_node
@@ -3296,7 +3296,7 @@
 
 		parent_dirs = set()
 		for obj in files_to_remove:
-			obj = os.path.join(root, obj.lstrip(os.sep))
+			obj = os.path.join(root(), obj.lstrip(os.sep))
 			parent_dirs.add(os.path.dirname(obj))
 			if os.path.islink(obj):
 				obj_type = "sym"
@@ -3347,8 +3347,6 @@
 			scheduler = self._scheduler
 			stopmerge = False
 			collisions = []
-			destroot = normalize_path(destroot).rstrip(os.path.sep) + \
-				os.path.sep
 			showMessage(" %s checking %d files for package collisions\n" % \
 				(colorize("GOOD", "*"), len(mycontents)))
 			for i, f in enumerate(mycontents):
@@ -3360,7 +3358,7 @@
 					scheduler.scheduleYield()
 
 				dest_path = normalize_path(
-					os.path.join(destroot, f.lstrip(os.path.sep)))
+					os.path.join(destroot.root(), f.lstrip(os.path.sep)))
 				try:
 					dest_lstat = os.lstat(dest_path)
 				except EnvironmentError, e:
@@ -3373,7 +3371,7 @@
 						# expects to have a directory.
 						dest_lstat = None
 						parent_path = dest_path
-						while len(parent_path) > len(destroot):
+						while len(parent_path) > len(destroot.root()):
 							parent_path = os.path.dirname(parent_path)
 							try:
 								dest_lstat = os.lstat(parent_path)
@@ -3387,7 +3385,7 @@
 								"unable to find non-directory " + \
 								"parent for '%s'" % dest_path)
 						dest_path = parent_path
-						f = os.path.sep + dest_path[len(destroot):]
+						f = os.path.sep + dest_path[len(destroot.root()):]
 						if f in collisions:
 							continue
 					else:
@@ -3410,7 +3408,7 @@
 					continue
 
 				isowned = False
-				full_path = os.path.join(destroot, f.lstrip(os.path.sep))
+				full_path = os.path.join(destroot.root(), f.lstrip(os.path.sep))
 				for ver in mypkglist:
 					if ver.isowner(f, destroot):
 						isowned = True
@@ -3441,7 +3439,7 @@
 		root = self.myroot
 		inode_map = {}
 		for f in path_iter:
-			path = os.path.join(root, f.lstrip(os.sep))
+			path = os.path.join(root(), f.lstrip(os.sep))
 			try:
 				st = os.lstat(path)
 			except OSError, e:
@@ -3543,8 +3541,8 @@
 		
 		@param srcroot: Typically this is ${D}
 		@type srcroot: String (Path)
-		@param destroot: Path to merge to (usually ${ROOT})
-		@type destroot: String (Path)
+		@param destroot: Path to merge to (usually ${ROOT}${EPREFIX})
+		@type destroot: EROOTobject
 		@param inforoot: root of the vardb entry ?
 		@type inforoot: String (Path)
 		@param myebuild: path to the ebuild that we are processing
@@ -3566,7 +3564,6 @@
 		scheduler = self._scheduler
 
 		srcroot = normalize_path(srcroot).rstrip(os.path.sep) + os.path.sep
-		destroot = normalize_path(destroot).rstrip(os.path.sep) + os.path.sep
 
 		if not os.path.isdir(srcroot):
 			showMessage("!!! Directory Not Found: D='%s'\n" % srcroot,
@@ -3772,7 +3769,7 @@
 
 			for f in collisions:
 				msg.append("\t%s" % \
-					os.path.join(destroot, f.lstrip(os.path.sep)))
+					os.path.join(destroot.root(), f.lstrip(os.path.sep)))
 
 			eerror(msg)
 
@@ -3793,7 +3790,7 @@
 				msg = []
 				msg.append("%s" % cpv)
 				for f in sorted(owned_files):
-					msg.append("\t%s" % os.path.join(destroot,
+					msg.append("\t%s" % os.path.join(destroot.root(),
 						f.lstrip(os.path.sep)))
 				msg.append("")
 				eerror(msg)
@@ -3868,7 +3865,7 @@
 		self.updateprotect()
 
 		#if we have a file containing previously-merged config file md5sums, grab it.
-		conf_mem_file = os.path.join(destroot, EPREFIX_LSTRIP, CONFIG_MEMORY_FILE)
+		conf_mem_file = os.path.join(destroot(), CONFIG_MEMORY_FILE)
 		cfgfiledict = grabdict(conf_mem_file)
 		cfgfiledict_orig = cfgfiledict.copy()
 		if "NOCONFMEM" in self.settings:
@@ -3897,7 +3894,7 @@
 
 		# we do a first merge; this will recurse through all files in our srcroot but also build up a
 		# "second hand" of symlinks to merge later
-		if self.mergeme(srcroot, destroot, outfile, secondhand, EPREFIX_LSTRIP, cfgfiledict, mymtime):
+		if self.mergeme(srcroot, destroot, outfile, secondhand, self.myroot.eprefix_lstrip(), cfgfiledict, mymtime):
 			return 1
 
 		# now, it's time for dealing our second hand; we'll loop until we can't merge anymore.	The rest are
@@ -3963,7 +3960,7 @@
 		# version now since we want to use the temporary
 		# PORTAGE_BIN_PATH that will be removed when we return.
 		reinstall_self = False
-		if self.myroot == "/" and \
+		if self.myroot == BROOT and \
 			match_from_list(PORTAGE_PACKAGE_ATOM, [self.mycpv]):
 			reinstall_self = True
 
@@ -4004,7 +4001,7 @@
 		# since they now belong to this package.
 		self._clear_contents_cache()
 		contents = self.getcontents()
-		destroot_len = len(destroot) - 1
+		destroot_len = len(destroot.root()) - 1
 		for blocker in blockers:
 			self.vartree.dbapi.removeFromContents(blocker, iter(contents),
 				relative_paths=False)
@@ -4060,7 +4057,7 @@
 
 		#update environment settings, library paths. DO NOT change symlinks.
 		env_update(makelinks=(not downgrade),
-			target_root=self.settings["ROOT"], prev_mtimes=prev_mtimes,
+			target_root=self.settings.root, prev_mtimes=prev_mtimes,
 			contents=contents, env=self.settings.environ(),
 			writemsg_level=self._display_merge)
 
@@ -4085,8 +4082,8 @@
 		
 		@param srcroot: Where are we copying files from (usually ${D})
 		@type srcroot: String (Path)
-		@param destroot: Typically ${ROOT}
-		@type destroot: String (Path)
+		@param destroot: Typically ${ROOT}${EPREFIX}
+		@type destroot: EROOTobject
 		@param outfile: File to log operations to
 		@type outfile: File Object
 		@param secondhand: A set of items to merge in pass two (usually
@@ -4111,7 +4108,6 @@
 
 		from os.path import sep, join
 		srcroot = normalize_path(srcroot).rstrip(sep) + sep
-		destroot = normalize_path(destroot).rstrip(sep) + sep
 		
 		# this is supposed to merge a list of files.  There will be 2 forms of argument passing.
 		if isinstance(stufftomerge, basestring):
@@ -4129,7 +4125,7 @@
 				scheduler.scheduleYield()
 
 			mysrc = join(srcroot, offset, x)
-			mydest = join(destroot, offset, x)
+			mydest = join(destroot.root(), offset, x)
 			# myrealdest is mydest without the $ROOT prefix (makes a difference if ROOT!="/")
 			myrealdest = join(sep, offset, x)
 			# stat file once, test using S_* macros many times (faster that way)
@@ -4160,7 +4156,7 @@
 						myto = myto[len(self.settings["D"]):]
 				# myrealto contains the path of the real file to which this symlink points.
 				# we can simply test for existence of this file to see if the target has been merged yet
-				myrealto = normalize_path(os.path.join(destroot, myabsto))
+				myrealto = normalize_path(os.path.join(destroot.root(), myabsto))
 				if mydmode!=None:
 					#destination exists
 					if not stat.S_ISLNK(mydmode):
@@ -4368,7 +4364,7 @@
 		"""
 		if self.vartree.dbapi._categories is not None:
 			self.vartree.dbapi._categories = None
-		if self.myroot == "/" and \
+		if self.myroot == BROOT and \
 			match_from_list(PORTAGE_PACKAGE_ATOM, [self.mycpv]) and \
 			not self.vartree.dbapi.cpv_exists(self.mycpv):
 			settings = self.settings
@@ -4476,7 +4472,7 @@
 	"""
 	Write contents to any file like object. The file will be left open.
 	"""
-	root_len = len(root) - 1
+	root_len = len(root()) - 1
 	for filename in sorted(contents):
 		entry_data = contents[filename]
 		entry_type = entry_data[0]
@@ -4496,7 +4492,7 @@
 def tar_contents(contents, root, tar, protect=None, onProgress=None):
 	from portage.util import normalize_path
 	import tarfile
-	root = normalize_path(root).rstrip(os.path.sep) + os.path.sep
+	root = normalize_path(root.root()).rstrip(os.path.sep) + os.path.sep
 	id_strings = {}
 	maxval = len(contents)
 	curval = 0
@@ -4517,7 +4513,7 @@
 			continue
 		contents_type = contents[path][0]
 		if path.startswith(root):
-			arcname = path[len(root):]
+			arcname = path[len(root()):]
 		else:
 			raise ValueError("invalid root argument: '%s'" % root)
 		live_path = path
Index: pym/portage/dbapi/porttree.py
===================================================================
--- pym/portage/dbapi/porttree.py	(revision 12574)
+++ pym/portage/dbapi/porttree.py	(working copy)
@@ -6,7 +6,7 @@
 
 from portage.cache.cache_errors import CacheError
 from portage.cache.mappings import slot_dict_class
-from portage.const import REPO_NAME_LOC
+from portage.const import REPO_NAME_LOC, EROOTobject, BPREFIX
 from portage.data import portage_gid, secpass
 from portage.dbapi import dbapi
 from portage.dep import use_reduce, paren_reduce, dep_getkey, match_from_list
@@ -409,7 +409,7 @@
 			self.doebuild_settings.reset()
 			mydata = {}
 			myret = doebuild(myebuild, "depend",
-				self.doebuild_settings["ROOT"], self.doebuild_settings,
+				self.doebuild_settings.root, self.doebuild_settings,
 				dbkey=mydata, tree="porttree", mydbapi=self)
 			if myret != os.EX_OK:
 				self._broken_ebuilds.add(myebuild)
@@ -892,12 +892,12 @@
 
 
 class portagetree(object):
-	def __init__(self, root="/", virtual=None, clone=None, settings=None):
+	def __init__(self, root=EROOTobject("/", BPREFIX), virtual=None, clone=None, settings=None):
 		"""
 		Constructor for a PortageTree
 		
-		@param root: ${ROOT}, defaults to '/', see make.conf(5)
-		@type root: String/Path
+		@param root: ${EROOT}, defaults to 'BPREFIX', see make.conf(5)
+		@type root: EROOTobject
 		@param virtual: UNUSED
 		@type virtual: No Idea
 		@param clone: Set this if you want a copy of Clone
Index: pym/portage/__init__.py
===================================================================
--- pym/portage/__init__.py	(revision 12574)
+++ pym/portage/__init__.py	(working copy)
@@ -19,10 +19,9 @@
 	import re
 	import shutil
 	import time
-	try:
-		import cPickle as pickle
-	except ImportError:
-		import pickle
+	# need to use pickle here, since EROOTobject is not unpickleable by
+	# cPickle (global and instance pickles are not supported).
+	import pickle
 
 	import stat
 	import commands
@@ -95,7 +94,7 @@
 		DEPRECATED_PROFILE_FILE, USER_VIRTUALS_FILE, EBUILD_SH_ENV_FILE, \
 		INVALID_ENV_FILE, CUSTOM_MIRRORS_FILE, CONFIG_MEMORY_FILE,\
 		INCREMENTALS, EAPI, MISC_SH_BINARY, REPO_NAME_LOC, REPO_NAME_FILE, \
-		EPREFIX, EPREFIX_LSTRIP, BPREFIX, rootgid
+		EPREFIX, BPREFIX, BROOT, rootgid
 
 	from portage.data import ostype, lchown, userland, secpass, uid, wheelgid, \
 	                         portage_uid, portage_gid, userpriv_groups
@@ -567,13 +566,13 @@
 	env=None, writemsg_level=portage.util.writemsg_level):
 	if target_root is None:
 		global settings
-		target_root = settings["ROOT"]
+		target_root = settings.root
 	if prev_mtimes is None:
 		global mtimedb
 		prev_mtimes = mtimedb["ldpath"]
 	if env is None:
 		env = os.environ
-	envd_dir = os.path.join(target_root, EPREFIX_LSTRIP, "etc", "env.d")
+	envd_dir = os.path.join(target_root(), "etc", "env.d")
 	portage.util.ensure_dirs(envd_dir, mode=0755)
 	fns = listdir(envd_dir, EmptyOnError=1)
 	fns.sort()
@@ -619,6 +618,11 @@
 
 	env = {}
 	specials = {}
+
+	# cross-prefixes source their parents environment, which means it must
+	# be preserved. to do this, we extend all extendable variables with the
+	# previously set value.
+	need_append = {}
 	for var in space_separated:
 		mylist = []
 		for myconfig in config_list:
@@ -629,6 +633,7 @@
 				del myconfig[var] # prepare for env.update(myconfig)
 		if mylist:
 			env[var] = " ".join(mylist)
+			need_append[var] = " "
 		specials[var] = mylist
 
 	for var in colon_separated:
@@ -641,6 +646,7 @@
 				del myconfig[var] # prepare for env.update(myconfig)
 		if mylist:
 			env[var] = ":".join(mylist)
+			need_append[var] = ":"
 		specials[var] = mylist
 
 	for myconfig in config_list:
@@ -648,7 +654,7 @@
 		they won't be overwritten by this dict.update call."""
 		env.update(myconfig)
 
-	ldsoconf_path = os.path.join(target_root, EPREFIX_LSTRIP, "etc", "ld.so.conf")
+	ldsoconf_path = os.path.join(target_root(), "etc", "ld.so.conf")
 	try:
 		myld = open(ldsoconf_path)
 		myldlines=myld.readlines()
@@ -671,7 +677,7 @@
 		#ld.so.conf needs updating and ldconfig needs to be run
 		myfd = atomic_ofstream(ldsoconf_path)
 		myfd.write("# ld.so.conf autogenerated by env-update; make all changes to\n")
-		myfd.write("# contents of "+EPREFIX+"/etc/env.d directory\n")
+		myfd.write("# contents of "+target_root.eprefix()+"/etc/env.d directory\n")
 		for x in specials["LDPATH"]:
 			myfd.write(x+"\n")
 		myfd.close()
@@ -680,11 +686,11 @@
 	# Update prelink.conf if we are prelink-enabled
 	if prelink_capable:
 		newprelink = atomic_ofstream(
-			os.path.join(target_root, EPREFIX_LSTRIP, "etc", "prelink.conf"))
+			os.path.join(target_root(), "etc", "prelink.conf"))
 		newprelink.write("# prelink.conf autogenerated by env-update; make all changes to\n")
-		newprelink.write("# contents of "+EPREFIX+"/etc/env.d directory\n")
+		newprelink.write("# contents of "+target_root.eprefix()+"/etc/env.d directory\n")
 
-		for x in map(lambda x: os.path.join(EPREFIX,x), ["bin","sbin","usr/bin","usr/sbin","lib","usr/lib"]):
+		for x in map(lambda x: os.path.join(target_root.eprefix(),x), ["bin","sbin","usr/bin","usr/sbin","lib","usr/lib"]):
 			newprelink.write("-l "+x+"\n");
 		for x in specials["LDPATH"]+specials["PATH"]+specials["PRELINK_PATH"]:
 			if not x:
@@ -715,7 +721,7 @@
 	mtime_changed = False
 	lib_dirs = set()
 	for lib_dir in portage.util.unique_array(specials["LDPATH"]+['usr/lib','usr/lib64','usr/lib32','lib','lib64','lib32']):
-		x = os.path.join(target_root, EPREFIX_LSTRIP, lib_dir.lstrip(os.sep))
+		x = os.path.join(target_root(), lib_dir.lstrip(os.sep))
 		try:
 			newldpathtime = long(os.stat(x).st_mtime)
 			lib_dirs.add(normalize_path(x))
@@ -757,43 +763,43 @@
 		if not libdir_contents_changed:
 			makelinks = False
 
-	ldconfig = EPREFIX+"/sbin/ldconfig"
+	ldconfig = BPREFIX+"/sbin/ldconfig"
 	if "CHOST" in env and "CBUILD" in env and \
 		env["CHOST"] != env["CBUILD"]:
 		from portage.process import find_binary
 		ldconfig = find_binary("%s-ldconfig" % env["CHOST"])
 
 	# Only run ldconfig as needed
-	if (ld_cache_update or makelinks) and ldconfig and EPREFIX == '':
+	if (ld_cache_update or makelinks) and ldconfig and target_root.eprefix() == '':
 		# ldconfig has very different behaviour between FreeBSD and Linux
 		if ostype=="Linux" or ostype.lower().endswith("gnu"):
 			# We can't update links if we haven't cleaned other versions first, as
 			# an older package installed ON TOP of a newer version will cause ldconfig
 			# to overwrite the symlinks we just made. -X means no links. After 'clean'
 			# we can safely create links.
-			writemsg_level(">>> Regenerating %s/etc/ld.so.cache...\n" % \
-				(target_root + EPREFIX_LSTRIP,))
+			writemsg_level(">>> Regenerating %setc/ld.so.cache...\n" % \
+				(target_root(),))
 			if makelinks:
-				os.system("cd / ; %s -r '%s'" % (ldconfig, target_root))
+				os.system("cd / ; %s -r '%s'" % (ldconfig, target_root.root()))
 			else:
-				os.system("cd / ; %s -X -r '%s'" % (ldconfig, target_root))
+				os.system("cd / ; %s -X -r '%s'" % (ldconfig, target_root.root()))
 		elif ostype in ("FreeBSD","DragonFly"):
 			writemsg_level(">>> Regenerating %svar/run/ld-elf.so.hints...\n" % \
-				target_root + EPREFIX_LSTRIP)
+				target_root())
 			os.system(("cd / ; %s -elf -i " + \
 				"-f '%svar/run/ld-elf.so.hints' '%setc/ld.so.conf'") % \
-				(ldconfig, target_root + EPREFIX_LSTRIP, target_root + EPREFIX_LSTRIP))
+				(ldconfig, target_root(), target_root()))
 
 	del specials["LDPATH"]
 
 	penvnotice  = "# THIS FILE IS AUTOMATICALLY GENERATED BY env-update.\n"
 	penvnotice += "# DO NOT EDIT THIS FILE. CHANGES TO STARTUP PROFILES\n"
 	cenvnotice  = penvnotice[:]
-	penvnotice += "# GO INTO "+EPREFIX+"/etc/profile NOT "+EPREFIX+"/etc/profile.env\n\n"
-	cenvnotice += "# GO INTO "+EPREFIX+"/etc/csh.cshrc NOT "+EPREFIX+"/etc/csh.env\n\n"
+	penvnotice += "# GO INTO "+target_root.eprefix()+"/etc/profile NOT "+target_root.eprefix()+"/etc/profile.env\n\n"
+	cenvnotice += "# GO INTO "+target_root.eprefix()+"/etc/csh.cshrc NOT "+target_root.eprefix()+"/etc/csh.env\n\n"
 
 	#create /etc/profile.env for bash support
-	outfile = atomic_ofstream(os.path.join(target_root, EPREFIX_LSTRIP, "etc", "profile.env"))
+	outfile = atomic_ofstream(os.path.join(target_root(), "etc", "profile.env"))
 	outfile.write(penvnotice)
 
 	env_keys = [ x for x in env if x != "LDPATH" ]
@@ -801,16 +807,26 @@
 	for k in env_keys:
 		v = env[k]
 		if v.startswith('$') and not v.startswith('${'):
-			outfile.write("export %s=$'%s'\n" % (k, v[1:]))
+			outfile.write("export %s=$'%s'" % (k, v[1:]))
 		else:
-			outfile.write("export %s='%s'\n" % (k, v))
+			outfile.write("export %s='%s'" % (k, v))
+
+		if (k in need_append) and (BPREFIX != EPREFIX):
+			outfile.write("\"%s${%s}\"" % (need_append[k], k))
+
+		outfile.write("\n")
 	outfile.close()
 
 	#create /etc/csh.env for (t)csh support
-	outfile = atomic_ofstream(os.path.join(target_root, EPREFIX_LSTRIP, "etc", "csh.env"))
+	outfile = atomic_ofstream(os.path.join(target_root(), "etc", "csh.env"))
 	outfile.write(cenvnotice)
 	for x in env_keys:
-		outfile.write("setenv %s '%s'\n" % (x, env[x]))
+		outfile.write("setenv %s '%s'" % (x, env[x]))
+		
+		if (k in need_append) and (BPREFIX != EPREFIX):
+			outfile.write("\"%s${%s}\"" % (need_append[k], k))
+
+		outfile.write("\n")
 	outfile.close()
 
 	if sleep_for_mtime_granularity:
@@ -1163,6 +1179,7 @@
 
 			self._accept_license = copy.deepcopy(clone._accept_license)
 			self._plicensedict = copy.deepcopy(clone._plicensedict)
+			self.root = clone.root
 		else:
 
 			def check_var_directory(varname, var):
@@ -1172,19 +1189,22 @@
 						noiselevel=-1)
 					raise portage.exception.DirectoryNotFound(var)
 
+			# setting ROOT != / requires setting the config root
+			# explicitly by environment. this is the behaviour as
+			# it was before, so I don't change it.
 			if config_root is None:
-				config_root = EPREFIX
+				if target_root is BROOT:
+					config_root = BROOT
+				else:
+					config_root = const.EROOTobject("/", EPREFIX)
 
-			config_root = normalize_path(os.path.abspath(
-				config_root)).rstrip(os.path.sep) + os.path.sep
+			check_var_directory("PORTAGE_CONFIGROOT", config_root())
 
-			check_var_directory("PORTAGE_CONFIGROOT", config_root)
+			self.depcachedir = os.path.join(BROOT(), DEPCACHE_PATH)
 
-			self.depcachedir = DEPCACHE_PATH
-
 			if not config_profile_path:
 				config_profile_path = \
-					os.path.join(config_root, PROFILE_PATH.lstrip(os.path.sep))
+					os.path.join(config_root(), PROFILE_PATH)
 				if os.path.isdir(config_profile_path):
 					self.profile_path = config_profile_path
 				else:
@@ -1201,7 +1221,7 @@
 			self.module_priority    = ["user","default"]
 			self.modules            = {}
 			self.modules["user"] = getconfig(
-				os.path.join(config_root, MODULES_FILE_PATH.lstrip(os.path.sep)))
+				os.path.join(config_root(), MODULES_FILE_PATH))
 			if self.modules["user"] is None:
 				self.modules["user"] = {}
 			self.modules["default"] = {
@@ -1264,7 +1284,7 @@
 					self.profiles = []
 			if local_config and self.profiles:
 				custom_prof = os.path.join(
-					config_root, CUSTOM_PROFILE_PATH.lstrip(os.path.sep))
+					config_root(), CUSTOM_PROFILE_PATH)
 				if os.path.exists(custom_prof):
 					self.user_profile_dir = custom_prof
 					self.profiles.append(custom_prof)
@@ -1340,7 +1360,7 @@
 			del rawpuseforce
 
 			make_conf = getconfig(
-				os.path.join(config_root, MAKE_CONF_FILE.lstrip(os.path.sep)),
+				os.path.join(config_root(), MAKE_CONF_FILE),
 				tolerant=tolerant, allow_sourcing=True)
 			if make_conf is None:
 				make_conf = {}
@@ -1348,18 +1368,13 @@
 			# Allow ROOT setting to come from make.conf if it's not overridden
 			# by the constructor argument (from the calling environment).
 			if target_root is None and "ROOT" in make_conf:
-				target_root = make_conf["ROOT"]
-				if not target_root.strip():
-					target_root = None
+				target_root = const.EROOTobject(make_conf["ROOT"], EPREFIX)
 			if target_root is None:
-				target_root = "/"
+				target_root = const.EROOTobject("/", EPREFIX)
 
-			target_root = normalize_path(os.path.abspath(
-				target_root)).rstrip(os.path.sep) + os.path.sep
+			portage.util.ensure_dirs(target_root())
+			check_var_directory("EROOT", target_root())
 
-			portage.util.ensure_dirs(target_root + EPREFIX_LSTRIP)
-			check_var_directory("EROOT", target_root + EPREFIX_LSTRIP)
-
 			# The expand_map is used for variable substitution
 			# in getconfig() calls, and the getconfig() calls
 			# update expand_map with the value of each variable
@@ -1377,7 +1392,7 @@
 			# lead to unexpected results.
 			expand_map = {}
 
-			env_d = getconfig(os.path.join(target_root, EPREFIX_LSTRIP, "etc", "profile.env"),
+			env_d = getconfig(os.path.join(target_root(), "etc", "profile.env"),
 				expand=expand_map)
 			# env_d will be None if profile.env doesn't exist.
 			if env_d:
@@ -1434,7 +1449,7 @@
 			self.configdict["defaults"]=self.configlist[-1]
 
 			self.mygcfg = getconfig(
-				os.path.join(config_root, MAKE_CONF_FILE.lstrip(os.path.sep)),
+				os.path.join(config_root(), MAKE_CONF_FILE),
 				tolerant=tolerant, allow_sourcing=True, expand=expand_map)
 			if self.mygcfg is None:
 				self.mygcfg = {}
@@ -1474,21 +1489,22 @@
 					cfg.pop(blacklisted, None)
 			del blacklisted, cfg
 
-			self["PORTAGE_CONFIGROOT"] = config_root
+			self["PORTAGE_CONFIGROOT"] = config_root()
 			self.backup_changes("PORTAGE_CONFIGROOT")
-			self["ROOT"] = target_root
+			self["ROOT"] = target_root.root()
 			self.backup_changes("ROOT")
-			self["EPREFIX"] = EPREFIX
+			self["EPREFIX"] = target_root.eprefix()
 			self.backup_changes("EPREFIX")
-			self["EROOT"] = target_root + EPREFIX_LSTRIP + os.path.sep
+			self["EROOT"] = target_root()
 			self.backup_changes("EROOT")
+			self.root = target_root
 
 			self.pusedict = {}
 			self.pkeywordsdict = {}
 			self._plicensedict = {}
 			self.punmaskdict = {}
-			abs_user_config = os.path.join(config_root,
-				USER_CONFIG_PATH.lstrip(os.path.sep))
+			abs_user_config = os.path.join(config_root(),
+				USER_CONFIG_PATH)
 
 			# locations for "categories" and "arch.list" files
 			locations = [os.path.join(self["PORTDIR"], "profiles")]
@@ -1708,7 +1724,7 @@
 				("sandbox" in self.features or "usersandbox" in self.features):
 				if self.profile_path is not None and \
 					os.path.realpath(self.profile_path) == \
-					os.path.realpath(PROFILE_PATH):
+					os.path.realpath(os.path.join(target_root(), PROFILE_PATH)):
 					""" Don't show this warning when running repoman and the
 					sandbox feature came from a profile that doesn't belong to
 					the user."""
@@ -1725,7 +1741,9 @@
 
 			# inject EPREFIX as it's in no single config file (I hope),
 			# but needs to be available using portageq
-			self["EPREFIX"] = EPREFIX
+			#haubi: isn't this already done above?
+			self["EPREFIX"] = target_root.eprefix()
+			self.root = target_root
 
 			self._init_dirs()
 
@@ -1736,20 +1754,20 @@
 		"""
 		Create a few directories that are critical to portage operation
 		"""
-		if not os.access(self["ROOT"] + EPREFIX_LSTRIP, os.W_OK):
+		if not os.access(self.root(), os.W_OK):
 			return
 
 		#                                     gid, mode, mask, preserve_perms
 		dir_mode_map = {
-			EPREFIX_LSTRIP+"/tmp" : (                  -1, 01777,  0,  True),
-			EPREFIX_LSTRIP+"/var/tmp" : (              -1, 01777,  0,  True),
-			EPREFIX_LSTRIP+"/"+PRIVATE_PATH :(portage_gid, 02750, 02,  False),
-			CACHE_PATH.lstrip(os.path.sep) : (portage_gid,  0755, 02,  False)
+			"tmp" : (                  -1, 01777,  0,  True),
+			"var/tmp" : (              -1, 01777,  0,  True),
+			PRIVATE_PATH   : (portage_gid, 02750, 02,  False),
+			CACHE_PATH     : (portage_gid,  0755, 02,  False)
 		}
 
 		for mypath, (gid, mode, modemask, preserve_perms) \
 			in dir_mode_map.iteritems():
-			mydir = os.path.join(self["ROOT"], mypath)
+			mydir = os.path.join(self.root(), mypath)
 			if preserve_perms and os.path.isdir(mydir):
 				# Only adjust permissions on some directories if
 				# they don't exist yet. This gives freedom to the
@@ -1826,7 +1844,7 @@
 						noiselevel=-1)
 
 		abs_profile_path = os.path.join(self["PORTAGE_CONFIGROOT"],
-			PROFILE_PATH.lstrip(os.path.sep))
+			PROFILE_PATH)
 		if not self.profile_path or (not os.path.islink(abs_profile_path) and \
 			not os.path.exists(os.path.join(abs_profile_path, "parent")) and \
 			os.path.exists(os.path.join(self["PORTDIR"], "profiles"))):
@@ -1836,7 +1854,7 @@
 			writemsg("!!! (You can safely ignore this message when syncing. It's harmless.)\n\n\n")
 
 		abs_user_virtuals = os.path.join(self["PORTAGE_CONFIGROOT"],
-			USER_VIRTUALS_FILE.lstrip(os.path.sep))
+			USER_VIRTUALS_FILE)
 		if os.path.exists(abs_user_virtuals):
 			writemsg("\n!!! /etc/portage/virtuals is deprecated in favor of\n")
 			writemsg("!!! /etc/portage/profile/virtuals. Please move it to\n")
@@ -2524,7 +2542,7 @@
 
 	def reload(self):
 		"""Reload things like /etc/profile.env that can change during runtime."""
-		env_d_filename = os.path.join(self["ROOT"], EPREFIX_LSTRIP, "etc", "profile.env")
+		env_d_filename = os.path.join(self.root(), "etc", "profile.env")
 		self.configdict["env.d"].clear()
 		env_d = getconfig(env_d_filename, expand=False)
 		if env_d:
@@ -2618,7 +2636,7 @@
 		# Do the USE calculation last because it depends on USE_EXPAND.
 		if "auto" in self["USE_ORDER"].split(":"):
 			self.configdict["auto"]["USE"] = autouse(
-				vartree(root=self["ROOT"], categories=self.categories,
+				vartree(root=self.root, categories=self.categories,
 					settings=self),
 				use_cache=use_cache, mysettings=self)
 		else:
@@ -2718,7 +2736,7 @@
 	def getvirtuals(self, myroot=None):
 		"""myroot is now ignored because, due to caching, it has always been
 		broken for all but the first call."""
-		myroot = self["ROOT"]
+		myroot = self.root
 		if self.virtuals:
 			return self.virtuals
 
@@ -3481,7 +3499,7 @@
 	check_config_instance(mysettings)
 
 	custommirrors = grabdict(os.path.join(mysettings["PORTAGE_CONFIGROOT"],
-		CUSTOM_MIRRORS_FILE.lstrip(os.path.sep)), recursive=1)
+		CUSTOM_MIRRORS_FILE), recursive=1)
 
 	mymirrors=[]
 
@@ -3739,7 +3757,6 @@
 					has_space = False
 
 			if distdir_writable and use_locks:
-
 				if locks_in_subdir:
 					lock_file = os.path.join(mysettings["DISTDIR"],
 						locks_in_subdir, myfile)
@@ -4307,7 +4324,7 @@
 							catsplit(cpv)[1] + ".ebuild")
 						# for RESTRICT=fetch, mirror, etc...
 						doebuild_environment(myebuild, "fetch",
-							mysettings["ROOT"], fetch_settings,
+							mysettings.root, fetch_settings,
 							debug, 1, myportdb)
 						uris.update(myportdb.getFetchMap(
 							cpv, mytree=mytree)[myfile])
@@ -4875,9 +4892,9 @@
 		# due to how it's coded... Don't overwrite this so we can use it.
 		mysettings["PORTAGE_DEBUG"] = "1"
 
-	mysettings["EPREFIX"]  = EPREFIX.rstrip(os.path.sep)
-	mysettings["ROOT"]     = myroot
-	mysettings["EROOT"]    = myroot + mysettings["EPREFIX"].lstrip(os.path.sep) + os.path.sep
+	mysettings["EPREFIX"]  = myroot.eprefix()
+	mysettings["ROOT"]     = myroot.root()
+	mysettings["EROOT"]    = myroot()
 	mysettings["STARTDIR"] = getcwd()
 	mysettings["EBUILD"]   = ebuild_path
 	mysettings["O"]        = pkg_dir
@@ -4956,13 +4973,13 @@
 	mysettings["T"] = os.path.join(mysettings["PORTAGE_BUILDDIR"], "temp")
 
 	mysettings["PORTAGE_BASHRC"] = os.path.join(
-		mysettings["PORTAGE_CONFIGROOT"], EBUILD_SH_ENV_FILE.lstrip(os.path.sep))
+		mysettings["PORTAGE_CONFIGROOT"], EBUILD_SH_ENV_FILE)
 	mysettings["EBUILD_EXIT_STATUS_FILE"] = os.path.join(
 		mysettings["PORTAGE_BUILDDIR"], ".exit_status")
 
 	#set up KV variable -- DEP SPEEDUP :: Don't waste time. Keep var persistent.
 	if mydo != "depend" and "KV" not in mysettings:
-		mykv,err1=ExtractKernelVersion(os.path.join(myroot, EPREFIX_LSTRIP, "usr/src/linux"))
+		mykv,err1=ExtractKernelVersion(os.path.join(myroot(), "usr/src/linux"))
 		if mykv:
 			# Regular source tree
 			mysettings["KV"]=mykv
@@ -5300,8 +5317,8 @@
 	@type myebuild: String
 	@param mydo: Phase to run
 	@type mydo: String
-	@param myroot: $ROOT (usually '/', see man make.conf)
-	@type myroot: String
+	@param myroot: $ROOT$EPREFIX (usually '/', see man make.conf)
+	@type myroot: EROOTobject
 	@param mysettings: Portage Configuration
 	@type mysettings: instance of portage.config
 	@param debug: Turns on various debug information (eg, debug for spawn)
@@ -6274,9 +6291,9 @@
 def merge(mycat, mypkg, pkgloc, infloc, myroot, mysettings, myebuild=None,
 	mytree=None, mydbapi=None, vartree=None, prev_mtimes=None, blockers=None,
 	scheduler=None):
-	if not os.access(myroot + EPREFIX_LSTRIP, os.W_OK):
+	if not os.access(myroot(), os.W_OK):
 		writemsg("Permission denied: access('%s', W_OK)\n" %
-				(myroot + EPREFIX_LSTRIP), noiselevel=-1)
+				(myroot(),), noiselevel=-1)
 		return errno.EACCES
 	mylink = dblink(mycat, mypkg, myroot, mysettings, treetype=mytree,
 		vartree=vartree, blockers=blockers, scheduler=scheduler)
@@ -6333,7 +6350,7 @@
 				newsplit.append(x)
 	return newsplit
 
-def _expand_new_virtuals(mysplit, edebug, mydbapi, mysettings, myroot="/",
+def _expand_new_virtuals(mysplit, edebug, mydbapi, mysettings, myroot=const.EROOTobject("/", BPREFIX),
 	trees=None, use_mask=None, use_force=None, **kwargs):
 	"""Recursively expand new-style virtuals so as to collapse one or more
 	levels of indirection.  In dep_zapdeps, new-style virtuals will be assigned
@@ -6709,7 +6726,7 @@
 		return portage.dep.Atom("=" + prefix + expanded + postfix)
 
 def dep_check(depstring, mydbapi, mysettings, use="yes", mode=None, myuse=None,
-	use_cache=1, use_binaries=0, myroot="/", trees=None):
+	use_cache=1, use_binaries=0, myroot=const.EROOTobject("/", BPREFIX), trees=None):
 	"""Takes a depend string and parses the condition."""
 	edebug = mysettings.get("PORTAGE_DEBUG", None) == "1"
 	#check_config_instance(mysettings)
@@ -6864,8 +6881,8 @@
 	mysplit=mykey.split("/")
 	if settings is None:
 		settings = globals()["settings"]
-	virts = settings.getvirtuals("/")
-	virts_p = settings.get_virts_p("/")
+	virts = settings.getvirtuals(BROOT)
+	virts_p = settings.get_virts_p(BROOT)
 	if len(mysplit)==1:
 		if hasattr(mydb, "cp_list"):
 			for x in mydb.categories:
@@ -6890,8 +6907,8 @@
 	mysplit=pkgsplit(myslash[-1])
 	if settings is None:
 		settings = globals()["settings"]
-	virts = settings.getvirtuals("/")
-	virts_p = settings.get_virts_p("/")
+	virts = settings.getvirtuals(BROOT)
+	virts_p = settings.get_virts_p(BROOT)
 	if len(myslash)>2:
 		# this is illegal case.
 		mysplit=[]
@@ -6998,7 +7015,7 @@
 		if os.path.isdir(profdir):
 			locations.append(profdir)
 	locations.append(os.path.join(settings["PORTAGE_CONFIGROOT"],
-		USER_CONFIG_PATH.lstrip(os.path.sep)))
+		USER_CONFIG_PATH))
 	locations.reverse()
 	pmasklists = [(x, grablines(os.path.join(x, "package.mask"), recursive=1)) for x in locations]
 
@@ -7246,7 +7263,7 @@
 			mysettings["PORTAGE_TMPDIR"], "portage", mycat, mypkg)
 		catdir = os.path.dirname(builddir)
 		# if the prefix differs, we copy it to the image after extraction
-		if (buildprefix != EPREFIX):
+		if (buildprefix != myroot.eprefix()):
 			pkgloc = os.path.join(builddir, "work")
 		else:
 			pkgloc = os.path.join(builddir, "image")
@@ -7282,10 +7299,10 @@
 		debug = mysettings.get("PORTAGE_DEBUG", "") == "1"
 
 		# We want to install in "our" prefix, not the binary one
-		mysettings["EPREFIX"] = EPREFIX
+		mysettings["EPREFIX"] = myroot.eprefix()
 		# Store "our" prefix in the vdb.
 		fp = open(os.path.join(infloc, "EPREFIX"), "w")
-		fp.write(EPREFIX+"\n")
+		fp.write(myroot.eprefix()+"\n")
 		fp.close()
 
 		# Eventually we'd like to pass in the saved ebuild env here.
@@ -7307,17 +7324,17 @@
 
 		# the extracted package put everything in buildprefix, so we
 		# just have to move it to the right EPREFIX
-		if buildprefix != EPREFIX:
-			writemsg_stdout(">>> Adjusting Prefix to %s\n" % EPREFIX)
+		if buildprefix != myroot.eprefix():
+			writemsg_stdout(">>> Adjusting Prefix to %s\n" % myroot.eprefix())
 			b = os.path.join(pkgloc, buildprefix.lstrip(os.path.sep))
-			i = os.path.join(builddir, "image", EPREFIX_LSTRIP)
+			i = os.path.join(builddir, "image", myroot.eprefix_lstrip())
 			# make sure the directory structure for EPREFIX is set up in
 			# the image, but avoid the last directory being there,
 			# otherwise chpathtool will complain
 			portage.util.ensure_dirs(i)
 			os.rmdir(i)
 			retval = portage.process.spawn_bash(
-				"chpathtool -q '%s' '%s' '%s' '%s'" % (b, i, buildprefix, EPREFIX),
+				"chpathtool -q '%s' '%s' '%s' '%s'" % (b, i, buildprefix, myroot.eprefix()),
 				env=mysettings.environ())
 			if retval != os.EX_OK:
 				writemsg("!!! Adjusing to Prefix failed!\n", noiselevel=-1)
@@ -7351,7 +7368,7 @@
 				del e
 
 def deprecated_profile_check(settings=None):
-	config_root = "/"
+	config_root = BROOT()
 	if settings is not None:
 		config_root = settings["PORTAGE_CONFIGROOT"]
 	deprecated_profile_file = os.path.join(config_root,
@@ -7430,8 +7447,7 @@
 	global secpass
 	if secpass < 2 or "SANDBOX_ACTIVE" in os.environ:
 		return
-	root = "/"
-	mysettings = trees["/"]["vartree"].settings
+	mysettings = trees[BROOT]["vartree"].settings
 	updpath = os.path.join(mysettings["PORTDIR"], "profiles", "updates")
 
 	try:
@@ -7471,7 +7487,7 @@
 				for msg in errors:
 					writemsg("%s\n" % msg, noiselevel=-1)
 
-		world_file = os.path.join(root, EPREFIX_LSTRIP, WORLD_FILE)
+		world_file = os.path.join(EPREFIX, WORLD_FILE)
 		world_list = grabfile(world_file)
 		world_modified = False
 		for update_cmd in myupd:
@@ -7485,15 +7501,15 @@
 			write_atomic(world_file,
 				"".join("%s\n" % (x,) for x in world_list))
 
-		update_config_files("/",
+		update_config_files(BROOT,
 			mysettings.get("CONFIG_PROTECT","").split(),
 			mysettings.get("CONFIG_PROTECT_MASK","").split(),
 			myupd)
 
-		trees["/"]["bintree"] = binarytree("/", mysettings["PKGDIR"],
+		trees[BROOT]["bintree"] = binarytree(BROOT, mysettings["PKGDIR"],
 			settings=mysettings)
-		vardb = trees["/"]["vartree"].dbapi
-		bindb = trees["/"]["bintree"].dbapi
+		vardb = trees[BROOT]["vartree"].dbapi
+		bindb = trees[BROOT]["bintree"].dbapi
 		if not os.access(bindb.bintree.pkgdir, os.W_OK):
 			bindb = None
 		for update_cmd in myupd:
@@ -7622,9 +7638,9 @@
 		config_incrementals=portage.const.INCREMENTALS)
 	settings.lock()
 
-	myroots = [(settings["ROOT"], settings)]
-	if settings["ROOT"] != "/":
-		settings = config(config_root=None, target_root="/",
+	myroots = [(settings.root, settings)]
+	if settings.root != BROOT:
+		settings = config(config_root=None, target_root=BROOT,
 			config_incrementals=portage.const.INCREMENTALS)
 		# When ROOT != "/" we only want overrides from the calling
 		# environment to apply to the config that's associated
@@ -7646,7 +7662,7 @@
 				backupenv.pop(k, None)
 		settings.regenerate()
 		settings.lock()
-		myroots.append((settings["ROOT"], settings))
+		myroots.append((settings.root, settings))
 
 	for myroot, mysettings in myroots:
 		trees[myroot] = portage.util.LazyItemsDict(trees.get(myroot, None))
@@ -7701,8 +7717,8 @@
 	def _get_target(self):
 		global mtimedb, mtimedbfile, _mtimedb_initialized
 		if not _mtimedb_initialized:
-			mtimedbfile = os.path.join("/",
-				CACHE_PATH.lstrip(os.path.sep), "mtimedb")
+			mtimedbfile = os.path.join(BROOT(),
+				CACHE_PATH, "mtimedb")
 			mtimedb = MtimeDB(mtimedbfile)
 			_mtimedb_initialized = True
 		name = object.__getattribute__(self, '_name')
@@ -7746,22 +7762,22 @@
 	os.umask(022)
 
 	kwargs = {}
-	kwargs["config_root"] = os.environ.get("PORTAGE_CONFIGROOT", EPREFIX + "/")
-	kwargs["target_root"] = os.environ.get("ROOT", "/")
+	kwargs["config_root"] = const.EROOTobject("/", os.environ.get("PORTAGE_CONFIGROOT", BPREFIX + "/"))
+	kwargs["target_root"] = const.EROOTobject(os.environ.get("ROOT", "/"), EPREFIX)
 
 	global _initializing_globals
 	_initializing_globals = True
 	db = create_trees(**kwargs)
 	del _initializing_globals
 
-	settings = db["/"]["vartree"].settings
+	settings = db[const.EROOTobject("/", BPREFIX)]["vartree"].settings
 
 	for myroot in db:
-		if myroot != "/":
+		if myroot != BROOT:
 			settings = db[myroot]["vartree"].settings
 			break
 
-	root = settings["ROOT"]
+	root = settings.root
 
 
 	# ========================================================================
@@ -7777,8 +7793,8 @@
 	thirdpartymirrors = settings.thirdpartymirrors()
 	usedefaults       = settings.use_defs
 	profiledir  = None
-	if os.path.isdir(PROFILE_PATH):
-		profiledir = PROFILE_PATH
+	if os.path.isdir(os.path.join(BROOT(), PROFILE_PATH)):
+		profiledir = os.path.join(BROOT(), PROFILE_PATH)
 	def flushmtimedb(record):
 		writemsg("portage.flushmtimedb() is DEPRECATED\n")
 	# ========================================================================
Index: pym/portage/util.py
===================================================================
--- pym/portage/util.py	(revision 12574)
+++ pym/portage/util.py	(working copy)
@@ -15,7 +15,7 @@
        OperationNotPermitted, PermissionDenied, ReadOnlyFileSystem
 import portage.exception
 from portage.dep import isvalidatom
-from portage.const import EPREFIX, EPREFIX_LSTRIP
+from portage.const import EPREFIX
 
 try:
 	import cPickle as pickle
@@ -1091,7 +1091,7 @@
 		self._dirs = set()
 		for x in self.protect_list:
 			ppath = normalize_path(
-				os.path.join(self.myroot + EPREFIX_LSTRIP, x.lstrip(os.path.sep)))
+				os.path.join(self.myroot(), x.lstrip(os.path.sep)))
 			mystat = None
 			try:
 				if stat.S_ISDIR(os.stat(ppath).st_mode):
@@ -1104,7 +1104,7 @@
 		self.protectmask = []
 		for x in self.mask_list:
 			ppath = normalize_path(
-				os.path.join(self.myroot + EPREFIX_LSTRIP, x.lstrip(os.path.sep)))
+				os.path.join(self.myroot(), x.lstrip(os.path.sep)))
 			mystat = None
 			try:
 				"""Use lstat so that anything, even a broken symlink can be
@@ -1216,7 +1216,7 @@
 	else:
 		# the following is based on the information from ld.so(8)
 		rval = os.environ.get("LD_LIBRARY_PATH", "").split(":")
-		rval.extend(grabfile(os.path.join(root, "etc", "ld.so.conf")))
+		rval.extend(grabfile(os.path.join(root(), "etc", "ld.so.conf")))
 		rval.append("/usr/lib")
 		rval.append("/lib")
 
Index: pym/portage/update.py
===================================================================
--- pym/portage/update.py	(revision 12574)
+++ pym/portage/update.py	(working copy)
@@ -143,14 +143,13 @@
 	protect - list of paths from CONFIG_PROTECT
 	protect_mask - list of paths from CONFIG_PROTECT_MASK
 	update_iter - list of update commands as returned from parse_updates()"""
-	config_root = normalize_path(config_root)
 	update_files = {}
 	file_contents = {}
 	myxfiles = ["package.mask", "package.unmask", \
 		"package.keywords", "package.use"]
 	myxfiles += [os.path.join("profile", x) for x in myxfiles]
-	abs_user_config = os.path.join(config_root,
-		USER_CONFIG_PATH.lstrip(os.path.sep))
+	abs_user_config = os.path.join(config_root(),
+		USER_CONFIG_PATH)
 	recursivefiles = []
 	for x in myxfiles:
 		config_file = os.path.join(abs_user_config, x)
@@ -177,6 +176,19 @@
 				del file_contents[x]
 			continue
 
+	worldlist = grabfile(os.path.join(config_root(), WORLD_FILE))
+	modified = False
+	for update_cmd in update_iter:
+		for pos, atom in enumerate(worldlist):
+			new_atom = update_dbentry(update_cmd, atom)
+			if atom != new_atom:
+				worldlist[pos] = new_atom
+				modified = True
+	if modified:
+		worldlist.sort()
+		write_atomic(os.path.join(config_root(), WORLD_FILE),
+			"\n".join(worldlist)+"\n")
+
 	# update /etc/portage/packages.*
 	ignore_line_re = re.compile(r'^#|^\s*$')
 	for update_cmd in update_iter:
Index: pym/portage/const.py
===================================================================
--- pym/portage/const.py	(revision 12574)
+++ pym/portage/const.py	(working copy)
@@ -11,6 +11,7 @@
 
 # save the original prefix
 BPREFIX = EPREFIX
+
 # pick up EPREFIX from the environment if set
 if "EPREFIX" in os.environ:
 	EPREFIX = os.path.normpath(os.environ["EPREFIX"])
@@ -21,8 +22,44 @@
 # START OF CONSTANTS -- START OF CONSTANTS -- START OF CONSTANTS -- START OF
 # ===========================================================================
 
-EPREFIX_LSTRIP          = EPREFIX.lstrip(os.path.sep)
+class EROOTobject:
+	def ify(root, eprefix):
+		if isinstance(root, EROOTobject):
+			return root
+		return EROOTobject(root, eprefix)
+	ify = staticmethod(ify)
+	def __init__(self, root, eprefix):
+		self.root_ = os.path.normpath(root).rstrip(os.path.sep) + os.path.sep
+		self.eprefix_ = os.path.normpath(eprefix).rstrip(os.path.sep)
+		self.eprefix_lstrip_ = self.eprefix_.lstrip(os.path.sep) + os.path.sep
+		self.eprefix_r_ = self.eprefix_lstrip_ + os.path.sep
+		self.eroot_ = os.path.join(self.root_, self.eprefix_lstrip_).rstrip(os.path.sep) + os.path.sep
+	def __call__(self):
+		return self.eroot_
+	def root(self):
+		return self.root_
+	def eprefix(self):
+		return self.eprefix_
+	def eprefix_lstrip(self):
+		return self.eprefix_lstrip_
+	def eprefix_r(self):
+		return self.eprefix_r_
+	def __str__(self):
+		return self.eroot_.rstrip(os.path.sep)
+	def __repr__(self):
+		return str(self)
+		#return 'ROOT='+self.root_+', EPREFIX='+self.eprefix_
+	def __hash__(self):
+		if (self.eprefix_ == EPREFIX):
+			# compatibility hack for external utils using ["/"] as hash-key
+			return hash(self.root_)
+		return hash(self.eroot_)
+	def __cmp__(self, other):
+		other = EROOTobject.ify(other, EPREFIX)
+		return cmp(self.eroot_, other.eroot_)
 
+BROOT = EROOTobject("/", BPREFIX)
+
 # We have a most confusing situation here, which is most of all pretty
 # weak for protecting us from making mistakes.
 # First there is a config_root (PORTAGE_CONFIGROOT) which can be a path
@@ -36,12 +73,14 @@
 # constants (like VDB_PATH) DO have EPREFIX.
 # Unfortunately this file is ordered quite horrible in this respect.
 
-VDB_PATH                = EPREFIX_LSTRIP+os.path.sep+"var/db/pkg"
+# make sure none of these paths start with os.path.sep - usually "/",
+# as they are used in os.path.join() without lstrip(os.path.sep)
+VDB_PATH                = "var/db/pkg" #haubi: EPREFIX_LSTRIP+os.path.sep+
 PRIVATE_PATH            = "var/lib/portage"
-CACHE_PATH              = EPREFIX+"/var/cache/edb"
+CACHE_PATH              = "var/cache/edb" #haubi: EPREFIX+"/"
 DEPCACHE_PATH           = CACHE_PATH+"/dep"
 
-USER_CONFIG_PATH        = "/etc/portage"
+USER_CONFIG_PATH        = "etc/portage" #haubi: "/"
 MODULES_FILE_PATH       = USER_CONFIG_PATH+"/modules"
 CUSTOM_PROFILE_PATH     = USER_CONFIG_PATH+"/profile"
 GLOBAL_CONFIG_PATH      = DATADIR+"/portage/config"
@@ -51,20 +90,20 @@
 PORTAGE_BIN_PATH        = PORTAGE_BASE_PATH+"/bin"
 PORTAGE_PYM_PATH        = PORTAGE_BASE_PATH+"/pym"
 PORTAGE_PACKAGE_ATOM    = "sys-apps/portage"
-NEWS_LIB_PATH           = EPREFIX+"/var/lib/gentoo"
-PROFILE_PATH            = "/etc/make.profile"
+NEWS_LIB_PATH           = "var/lib/gentoo" #haubi: EPREFIX+"/"
+PROFILE_PATH            = "etc/make.profile" #haubi: "/"
 LOCALE_DATA_PATH        = PORTAGE_BASE_PATH+"/locale"
 
 EBUILD_SH_BINARY        = PORTAGE_BIN_PATH+"/ebuild.sh"
 MISC_SH_BINARY          = PORTAGE_BIN_PATH+"/misc-functions.sh"
-SANDBOX_BINARY          = EPREFIX+"/usr/bin/sandbox"
-FAKEROOT_BINARY         = EPREFIX+"/usr/bin/fakeroot"
+SANDBOX_BINARY          = BPREFIX+"/usr/bin/sandbox" #haubi: EPREFIX+
+FAKEROOT_BINARY         = BPREFIX+"/usr/bin/fakeroot" #haubi: EPREFIX+
 BASH_BINARY             = "bash"
 MOVE_BINARY             = "mv"
 PRELINK_BINARY          = "prelink"
 
 WORLD_FILE              = PRIVATE_PATH + "/world"
-MAKE_CONF_FILE          = "/etc/make.conf"
+MAKE_CONF_FILE          = "etc/make.conf" #haubi: "/"
 MAKE_DEFAULTS_FILE      = PROFILE_PATH + "/make.defaults"
 DEPRECATED_PROFILE_FILE = PROFILE_PATH+"/deprecated"
 USER_VIRTUALS_FILE      = USER_CONFIG_PATH+"/virtuals"
Index: pym/portage/glsa.py
===================================================================
--- pym/portage/glsa.py	(revision 12574)
+++ pym/portage/glsa.py	(working copy)
@@ -28,7 +28,7 @@
 	@rtype:		list
 	@return:	list of glsa IDs
 	"""
-	return grabfile(os.path.join(os.sep, settings["ROOT"], CACHE_PATH.lstrip(os.sep), "glsa"))
+	return grabfile(os.path.join(settings.root(), CACHE_PATH, "glsa"))
 
 
 # TODO: use the textwrap module instead
@@ -646,7 +646,7 @@
 		@returns:	None
 		"""
 		if not self.isApplied():
-			checkfile = open(os.path.join(os.sep, self.config["ROOT"], CACHE_PATH.lstrip(os.sep), "glsa"), "a+")
+			checkfile = open(os.path.join(self.root(), CACHE_PATH, "glsa"), "a+")
 			checkfile.write(self.nr+"\n")
 			checkfile.close()
 		return None
Index: pym/portage/sets/__init__.py
===================================================================
--- pym/portage/sets/__init__.py	(revision 12574)
+++ pym/portage/sets/__init__.py	(working copy)
@@ -8,7 +8,7 @@
 import os
 from ConfigParser import SafeConfigParser, NoOptionError
 from portage import load_mod
-from portage.const import USER_CONFIG_PATH, GLOBAL_CONFIG_PATH
+from portage.const import USER_CONFIG_PATH, GLOBAL_CONFIG_PATH, BROOT
 from portage.exception import PackageSetNotFound
 
 SETPREFIX = "@"
@@ -187,13 +187,13 @@
 	setconfigpaths.append(os.path.join(settings["PORTDIR"], "sets.conf"))
 	setconfigpaths += [os.path.join(x, "sets.conf") for x in settings["PORTDIR_OVERLAY"].split()]
 	setconfigpaths.append(os.path.join(settings["PORTAGE_CONFIGROOT"],
-		USER_CONFIG_PATH.lstrip(os.path.sep), "sets.conf"))
+		USER_CONFIG_PATH, "sets.conf"))
 	return SetConfig(setconfigpaths, settings, trees)
 
 # adhoc test code
 if __name__ == "__main__":
 	import portage
-	sc = load_default_config(portage.settings, portage.db["/"])
+	sc = load_default_config(portage.settings, portage.db[BROOT])
 	l, e = sc.getSets()
 	for x in l:
 		print x+":"
Index: pym/portage/sets/files.py
===================================================================
--- pym/portage/sets/files.py	(revision 12574)
+++ pym/portage/sets/files.py	(working copy)
@@ -7,7 +7,7 @@
 from itertools import chain
 
 from portage.util import grabfile, write_atomic, ensure_dirs, normalize_path
-from portage.const import PRIVATE_PATH, USER_CONFIG_PATH, EPREFIX_LSTRIP
+from portage.const import PRIVATE_PATH, USER_CONFIG_PATH
 from portage.locks import lockfile, unlockfile
 from portage import portage_gid
 from portage.sets.base import PackageSet, EditablePackageSet
@@ -109,7 +109,7 @@
 	
 	def multiBuilder(self, options, settings, trees):
 		rValue = {}
-		directory = options.get("directory", os.path.join(settings["PORTAGE_CONFIGROOT"], USER_CONFIG_PATH.lstrip(os.sep), "sets"))
+		directory = options.get("directory", os.path.join(settings["PORTAGE_CONFIGROOT"], USER_CONFIG_PATH, "sets"))
 		name_pattern = options.get("name_pattern", "${name}")
 		if not "$name" in name_pattern and not "${name}" in name_pattern:
 			raise SetConfigError("name_pattern doesn't include ${name} placeholder")
@@ -156,7 +156,7 @@
 	
 	def multiBuilder(self, options, settings, trees):
 		rValue = {}
-		directory = options.get("directory", os.path.join(settings["PORTAGE_CONFIGROOT"], USER_CONFIG_PATH.lstrip(os.sep)))
+		directory = options.get("directory", os.path.join(settings["PORTAGE_CONFIGROOT"], USER_CONFIG_PATH))
 		name_pattern = options.get("name_pattern", "sets/package_$suffix")
 		if not "$suffix" in name_pattern and not "${suffix}" in name_pattern:
 			raise SetConfigError("name_pattern doesn't include $suffix placeholder")
@@ -175,11 +175,11 @@
 		# most attributes exist twice as atoms and non-atoms are stored in 
 		# separate files
 		self._lock = None
-		self._filename = os.path.join(os.sep, root, EPREFIX_LSTRIP, PRIVATE_PATH.lstrip(os.sep), "world")
+		self._filename = os.path.join(root(), PRIVATE_PATH, "world")
 		self.loader = ItemFileLoader(self._filename, self._validate)
 		self._mtime = None
 		
-		self._filename2 = os.path.join(os.sep, root, EPREFIX_LSTRIP,  PRIVATE_PATH.lstrip(os.sep), "world_sets")
+		self._filename2 = os.path.join(root(), PRIVATE_PATH, "world_sets")
 		self.loader2 = ItemFileLoader(self._filename2, self._validate2)
 		self._mtime2 = None
 		
@@ -282,5 +282,5 @@
 		self.unlock()
 
 	def singleBuilder(self, options, settings, trees):
-		return WorldSet(settings["ROOT"])
+		return WorldSet(settings.root)
 	singleBuilder = classmethod(singleBuilder)
Index: pym/portage/sets/profiles.py
===================================================================
--- pym/portage/sets/profiles.py	(revision 12574)
+++ pym/portage/sets/profiles.py	(working copy)
@@ -8,7 +8,7 @@
 from portage.sets.base import PackageSet
 from portage.sets import get_boolean
 from portage.util import writemsg_level
-from portage.const import EPREFIX
+from portage.const import BPREFIX
 
 __all__ = ["PackagesSystemSet"]
 
@@ -21,7 +21,7 @@
 		self._debug = debug
 		if profile_paths:
 			description = self._profile_paths[-1]
-			if description == EPREFIX+"/etc/portage/profile" and \
+			if description == BPREFIX+"/etc/portage/profile" and \
 				len(self._profile_paths) > 1:
 				description = self._profile_paths[-2]
 		else:
Index: pym/portage/elog/mod_save_summary.py
===================================================================
--- pym/portage/elog/mod_save_summary.py	(revision 12574)
+++ pym/portage/elog/mod_save_summary.py	(working copy)
@@ -6,13 +6,13 @@
 import os, time
 from portage.data import portage_uid, portage_gid
 from portage.util import ensure_dirs, apply_permissions
-from portage.const import EPREFIX
+from portage.const import BPREFIX
 
 def process(mysettings, key, logentries, fulltext):
 	if mysettings["PORT_LOGDIR"] != "":
 		elogdir = os.path.join(mysettings["PORT_LOGDIR"], "elog")
 	else:
-		elogdir = os.path.join(EPREFIX, "var", "log", "portage", "elog")
+		elogdir = os.path.join(BPREFIX, "var", "log", "portage", "elog")
 	ensure_dirs(elogdir, uid=portage_uid, gid=portage_gid, mode=02770)
 
 	# TODO: Locking
Index: pym/portage/elog/mod_echo.py
===================================================================
--- pym/portage/elog/mod_echo.py	(revision 12574)
+++ pym/portage/elog/mod_echo.py	(working copy)
@@ -4,7 +4,7 @@
 # $Id$
 
 from portage.output import EOutput, colorize
-from portage.const import EBUILD_PHASES
+from portage.const import EBUILD_PHASES, BROOT
 
 _items = []
 def process(mysettings, key, logentries, fulltext):
@@ -19,8 +19,8 @@
 	printer = EOutput()
 	for mysettings, key, logentries in _items:
 		root_msg = ""
-		if mysettings["ROOT"] != "/":
-			root_msg = " merged to %s" % mysettings["ROOT"]
+		if mysettings.root != BROOT:
+			root_msg = " merged to %s" % `mysettings.root`
 		print
 		printer.einfo("Messages for package %s%s:" % \
 			(colorize("INFORM", key), root_msg))
Index: pym/portage/elog/mod_save.py
===================================================================
--- pym/portage/elog/mod_save.py	(revision 12574)
+++ pym/portage/elog/mod_save.py	(working copy)
@@ -6,7 +6,7 @@
 import os, time
 from portage.data import portage_uid, portage_gid
 from portage.util import ensure_dirs
-from portage.const import EPREFIX
+from portage.const import BPREFIX
 
 def process(mysettings, key, logentries, fulltext):
 	path = key.replace("/", ":")
@@ -14,7 +14,7 @@
 	if mysettings["PORT_LOGDIR"] != "":
 		elogdir = os.path.join(mysettings["PORT_LOGDIR"], "elog")
 	else:
-		elogdir = os.path.join(EPREFIX, "var", "log", "portage", "elog")
+		elogdir = os.path.join(BPREFIX, "var", "log", "portage", "elog")
 	ensure_dirs(elogdir, uid=portage_uid, gid=portage_gid, mode=02770)
 
 	elogfilename = elogdir+"/"+path+":"+time.strftime("%Y%m%d-%H%M%S", time.gmtime(time.time()))+".log"
Index: pym/portage/elog/mod_mail_summary.py
===================================================================
--- pym/portage/elog/mod_mail_summary.py	(revision 12574)
+++ pym/portage/elog/mod_mail_summary.py	(working copy)
@@ -6,6 +6,7 @@
 import portage.mail, socket, os, time
 from portage.exception import PortageException
 from portage.util import writemsg
+from portage.const import EROOTobject
 from email.MIMEText import MIMEText as TextMessage
 
 _items = {}
@@ -13,7 +14,7 @@
 	global _items
 	header = ">>> Messages generated for package %s by process %d on %s:\n\n" % \
 		(key, os.getpid(), time.strftime("%Y%m%d-%H%M%S %Z", time.localtime(time.time())))
-	config_root = mysettings["PORTAGE_CONFIGROOT"]
+	config_root = EROOTobject("/", mysettings["PORTAGE_CONFIGROOT"])
 	mysettings, items = _items.setdefault(config_root, (mysettings, {}))
 	items[key] = header + fulltext
 
Index: pym/portage/output.py
===================================================================
--- pym/portage/output.py	(revision 12574)
+++ pym/portage/output.py	(working copy)
@@ -11,7 +11,7 @@
 import re
 import shlex
 import sys
-from portage.const import COLOR_MAP_FILE, EPREFIX
+from portage.const import COLOR_MAP_FILE, BROOT
 from portage.util import writemsg
 from portage.exception import CommandNotFound, FileNotFound, \
 	ParseError, PermissionDenied, PortageException
@@ -171,7 +171,7 @@
 	@rtype: dict
 	@return: a dictionary mapping color classes to color codes
 	"""
-	myfile = EPREFIX + COLOR_MAP_FILE
+	myfile = os.path.join(BROOT(), COLOR_MAP_FILE)
 	ansi_code_pattern = re.compile("^[0-9;]*m$")
 	def strip_quotes(token, quotes):
 		if token[0] in quotes and token[0] == token[-1]:
Index: pym/portage/getbinpkg.py
===================================================================
--- pym/portage/getbinpkg.py	(revision 12574)
+++ pym/portage/getbinpkg.py	(working copy)
@@ -14,7 +14,7 @@
 import tempfile
 import base64
 import urllib2
-from portage.const import CACHE_PATH
+from portage.const import CACHE_PATH, BROOT
 
 try:
 	import cPickle as pickle
@@ -474,7 +474,7 @@
 	cache_path = "/var/cache/edb"
 
 	if makepickle is None:
-		makepickle = CACHE_PATH+"/metadata.idx.most_recent"
+		makepickle = os.path.join(BROOT(), CACHE_PATH, "metadata.idx.most_recent")
 
 	try:
 		conn, protocol, address, params, headers = create_conn(baseurl, conn)
@@ -486,7 +486,7 @@
 
 	out = sys.stdout
 	try:
-		metadatafile = open(CACHE_PATH+"/remote_metadata.pickle")
+		metadatafile = open(os.path.join(BROOT(), CACHE_PATH, "remote_metadata.pickle"))
 		metadata = pickle.load(metadatafile)
 		out.write("Loaded metadata pickle.\n")
 		out.flush()
@@ -575,7 +575,7 @@
 					sys.stderr.write("!!! "+str(e)+"\n")
 					sys.stderr.flush()
 			try:
-				metadatafile = open(CACHE_PATH+"/remote_metadata.pickle", "w+")
+				metadatafile = open(os.path.join(BROOT, CACHE_PATH, "remote_metadata.pickle"), "w+")
 				pickle.dump(metadata,metadatafile)
 				metadatafile.close()
 			except SystemExit, e:
@@ -667,7 +667,7 @@
 	try:
 		if "modified" in metadata[baseurl] and metadata[baseurl]["modified"]:
 			metadata[baseurl]["timestamp"] = int(time.time())
-			metadatafile = open(CACHE_PATH+"/remote_metadata.pickle", "w+")
+			metadatafile = open(os.path.join(BROOT, CACHE_PATH, "remote_metadata.pickle"), "w+")
 			pickle.dump(metadata,metadatafile)
 			metadatafile.close()
 		if makepickle:
Index: pym/_emerge/__init__.py
===================================================================
--- pym/_emerge/__init__.py	(revision 12574)
+++ pym/_emerge/__init__.py	(working copy)
@@ -49,7 +49,7 @@
 import portage.xpak, commands, errno, re, socket, time, types
 from portage.output import blue, bold, colorize, darkblue, darkgreen, darkred, green, \
 	nc_len, red, teal, turquoise, xtermTitle, \
-	xtermTitleReset, yellow
+	xtermTitleReset, yellow, darkyellow, purple
 from portage.output import create_color_func
 good = create_color_func("GOOD")
 bad = create_color_func("BAD")
@@ -62,7 +62,7 @@
 import portage.util
 import portage.locks
 import portage.exception
-from portage.const import EPREFIX, BPREFIX, EPREFIX_LSTRIP, EAPIPREFIX
+from portage.const import EPREFIX, BPREFIX, EAPIPREFIX, BROOT
 from portage.data import secpass
 from portage.elog.messages import eerror
 from portage.util import normalize_path as normpath
@@ -258,7 +258,7 @@
 			short_msg = os.environ["HOSTNAME"]+": "+short_msg
 		xtermTitle(short_msg)
 	try:
-		file_path = EPREFIX+"/var/log/emerge.log"
+		file_path = os.path.join(BROOT(), "var/log/emerge.log")
 		mylogfile = open(file_path, "a")
 		portage.util.apply_secpass_permissions(file_path,
 			uid=portage.portage_uid, gid=portage.portage_gid,
@@ -783,7 +783,7 @@
 		self.trees = trees
 		self.settings = settings
 		self.iuse_implicit = tuple(sorted(settings._get_implicit_iuse()))
-		self.root = self.settings["ROOT"]
+		self.root = self.settings.root
 		self.setconfig = setconfig
 		self.sets = self.setconfig.getSets()
 		self.visible_pkgs = PackageVirtualDbapi(self.settings)
@@ -1067,7 +1067,7 @@
 		self._db_keys = mykeys
 		self._pkg_cache = pkg_cache
 		self.dbapi = PackageVirtualDbapi(real_vartree.settings)
-		vdb_path = os.path.join(self.root, portage.VDB_PATH)
+		vdb_path = os.path.join(self.root(), portage.VDB_PATH)
 		try:
 			# At least the parent needs to exist for the lock file.
 			portage.util.ensure_dirs(vdb_path)
@@ -1165,7 +1165,7 @@
 		after one or more packages may have been installed or
 		uninstalled.
 		"""
-		vdb_path = os.path.join(self.root, portage.VDB_PATH)
+		vdb_path = os.path.join(self.root(), portage.VDB_PATH)
 		try:
 			# At least the parent needs to exist for the lock file.
 			portage.util.ensure_dirs(vdb_path)
@@ -1655,7 +1655,7 @@
 		portage.prepare_build_dirs(self.pkg.root, self.settings, 0)
 
 		retval = portage.doebuild(ebuild_path, "fetch",
-			self.settings["ROOT"], self.settings, debug=debug,
+			self.settings.root, self.settings, debug=debug,
 			listonly=self.pretend, fetchonly=1, fetchall=self.fetch_all,
 			mydbapi=portdb, tree="porttree")
 
@@ -2666,15 +2666,15 @@
 
 			msg = " === (%s of %s) Compiling/Packaging (%s::%s)" % \
 				(pkg_count.curval, pkg_count.maxval, pkg.cpv, ebuild_path)
-			short_msg = "emerge: (%s of %s) %s Compile" % \
-				(pkg_count.curval, pkg_count.maxval, pkg.cpv)
+			short_msg = "emerge: (%s of %s) %s Compile - %s" % \
+				(pkg_count.curval, pkg_count.maxval, pkg.cpv, pkg.root_config.settings["ARCH"])
 			logger.log(msg, short_msg=short_msg)
 
 		else:
 			msg = " === (%s of %s) Compiling/Merging (%s::%s)" % \
 				(pkg_count.curval, pkg_count.maxval, pkg.cpv, ebuild_path)
-			short_msg = "emerge: (%s of %s) %s Compile" % \
-				(pkg_count.curval, pkg_count.maxval, pkg.cpv)
+			short_msg = "emerge: (%s of %s) %s Compile - %s" % \
+				(pkg_count.curval, pkg_count.maxval, pkg.cpv, pkg.root_config.settings["ARCH"])
 			logger.log(msg, short_msg=short_msg)
 
 		build = EbuildExecuter(background=self.background, pkg=pkg,
@@ -2938,7 +2938,7 @@
 		self._registered = True
 
 		retval = portage.doebuild(ebuild_path, "depend",
-			settings["ROOT"], settings, debug,
+			settings.root, settings, debug,
 			mydbapi=self.portdb, tree="porttree",
 			fd_pipes=fd_pipes, returnpid=True)
 
@@ -3396,7 +3396,7 @@
 				gid=portage.data.portage_gid, mode=dir_mode)
 
 		# This initializes PORTAGE_LOG_FILE.
-		portage.prepare_build_dirs(self.settings["ROOT"], self.settings, 1)
+		portage.prepare_build_dirs(self.settings.root, self.settings, 1)
 		self._writemsg_level(">>> Extracting info\n")
 
 		pkg_xpak = portage.xpak.tbz2(self._pkg_path)
@@ -3793,13 +3793,15 @@
 					pkg_repo_name = "unknown repo"
 				msg += " from %s" % pkg_repo_name
 
-		if pkg.root != "/":
+		if pkg.root != BROOT:
 			msg += " %s %s" % (preposition, pkg.root)
 
+		msg += " - %s" % (purple(pkg.root_config.settings["ARCH"]))
+
 		if not build_opts.pretend:
 			self.statusMessage(msg)
 			logger.log(" >>> emerge (%s of %s) %s to %s" % \
-				(pkg_count.curval, pkg_count.maxval, pkg.cpv, pkg.root))
+				(pkg_count.curval, pkg_count.maxval, pkg.cpv, `pkg.root`))
 
 		if pkg.type_name == "ebuild":
 
@@ -3894,8 +3896,8 @@
 
 		msg = "%s %s" % (action_desc, colorize("GOOD", pkg.cpv))
 
-		if pkg.root != "/":
-			msg += " %s %s" % (preposition, pkg.root)
+		if pkg.root != BROOT:
+			msg += " %s %s" % (preposition, `pkg.root`)
 
 		if not self.merge.build_opts.fetchonly and \
 			not self.merge.build_opts.pretend and \
@@ -3968,8 +3970,8 @@
 	def __init__(self, myroot, vardb):
 		self._vardb = vardb
 		self._virtuals = vardb.settings.getvirtuals()
-		self._cache_filename = os.path.join(myroot,
-			portage.CACHE_PATH.lstrip(os.path.sep), "vdb_blockers.pickle")
+		self._cache_filename = os.path.join(myroot(),
+			portage.CACHE_PATH, "vdb_blockers.pickle")
 		self._cache_version = "1"
 		self._cache_data = None
 		self._modified = set()
@@ -4161,7 +4163,7 @@
 				finally:
 					portage.dep._dep_check_strict = True
 				if not success:
-					pkg_location = os.path.join(inst_pkg.root,
+					pkg_location = os.path.join(inst_pkg.root(),
 						portage.VDB_PATH, inst_pkg.category, inst_pkg.pf)
 					portage.writemsg("!!! %s/*DEPEND: %s\n" % \
 						(pkg_location, atoms), noiselevel=-1)
@@ -4225,7 +4227,7 @@
 	msg = []
 	if p_status == "nomerge":
 		category, pf = portage.catsplit(p_key)
-		pkg_location = os.path.join(p_root, portage.VDB_PATH, category, pf)
+		pkg_location = os.path.join(p_root(), portage.VDB_PATH, category, pf)
 		msg.append("Portage is unable to process the dependencies of the ")
 		msg.append("'%s' package. " % p_key)
 		msg.append("In order to correct this problem, the package ")
@@ -4383,14 +4385,14 @@
 
 	def __init__(self, settings, trees, myopts, myparams, spinner):
 		self.settings = settings
-		self.target_root = settings["ROOT"]
+		self.target_root = settings.root
 		self.myopts = myopts
 		self.myparams = myparams
 		self.edebug = 0
 		if settings.get("PORTAGE_DEBUG", "") == "1":
 			self.edebug = 1
 		self.spinner = spinner
-		self._running_root = trees["/"]["root_config"]
+		self._running_root = trees[BROOT]["root_config"]
 		self._opts_no_restart = Scheduler._opts_no_restart
 		self.pkgsettings = {}
 		# Maps slot atom to package for each Package added to the graph.
@@ -4830,7 +4832,7 @@
 				return 0
 		return 1
 
-	def _add_dep(self, dep, allow_unsatisfied=False):
+	def _add_dep(self, dep, allow_unsatisfied=False, with_fallback=False):
 		debug = "--debug" in self.myopts
 		buildpkgonly = "--buildpkgonly" in self.myopts
 		nodeps = "--nodeps" in self.myopts
@@ -4854,6 +4856,10 @@
 			return 1
 		dep_pkg, existing_node = self._select_package(dep.root, dep.atom,
 			onlydeps=dep.onlydeps)
+
+		if with_fallback and not dep_pkg:
+			return 2
+
 		if not dep_pkg:
 			if dep.priority.satisfied:
 				# This could be an unecessary build-time dep
@@ -5117,17 +5123,38 @@
 		if removal_action and self.myopts.get("--with-bdeps", "y") == "n":
 			edepend["DEPEND"] = ""
 
+		# do we need (EROOT, DEPEND) too for cross-prefixing?
 		deps = (
-			("/", edepend["DEPEND"],
-				self._priority(buildtime=True, satisfied=bdeps_satisfied)),
-			(myroot, edepend["RDEPEND"], self._priority(runtime=True)),
-			(myroot, edepend["PDEPEND"], self._priority(runtime_post=True))
+			(BROOT, edepend["DEPEND"],
+				self._priority(buildtime=True, satisfied=bdeps_satisfied), False, True),
+			(portage.const.EROOTobject("/", EPREFIX), None,
+				self._priority(buildtime=True, satisfied=bdeps_satisfied), True, False),
+			(myroot, edepend["RDEPEND"], self._priority(runtime=True), False, False),
+			(myroot, edepend["PDEPEND"], self._priority(runtime_post=True), False, False)
 		)
 
 		debug = "--debug" in self.myopts
 		strict = mytype != "installed"
+		fallback = False
+		fallback_depstring = ""
 		try:
-			for dep_root, dep_string, dep_priority in deps:
+			#print "\n * processing package: ", pkg
+			for dep_root, dep_string, dep_priority, is_fallback, fb_exists in deps:
+				#print "   * fallback: " , fallback, " root: ", dep_root, " is_fb: ", is_fallback, " depstr: ", dep_string, " fb_depstr: ", fallback_depstring
+
+				if fallback and not is_fallback:
+					fallback = False
+
+				if not fallback and is_fallback:
+					continue
+
+				if fallback and not dep_string:
+					dep_string = fallback_depstring
+				
+				if fallback:
+					fallback = False
+					fallback_depstring = ""
+
 				if pkg.onlydeps:
 					# Decrease priority so that --buildpkgonly
 					# hasallzeros() works correctly.
@@ -5151,18 +5178,32 @@
 
 				for atom in selected_atoms:
 					try:
-
 						atom = portage.dep.Atom(atom)
 
+						if atom.blocker and pkg.root != dep_root:
+							# handle blocker only on prefixes where the parent is
+							# to be installed.
+							fallback_depstring += " " + str(atom)
+							fallback = True
+							continue
+
 						mypriority = dep_priority.copy()
 						if not atom.blocker and vardb.match(atom):
 							mypriority.satisfied = True
 
-						if not self._add_dep(Dependency(atom=atom,
+						res = self._add_dep(Dependency(atom=atom,
 							blocker=atom.blocker, depth=depth, parent=pkg,
 							priority=mypriority, root=dep_root),
-							allow_unsatisfied=allow_unsatisfied):
+							allow_unsatisfied=allow_unsatisfied,
+							with_fallback=fb_exists)
+
+						if res is 2:
+							fallback_depstring += " " + str(atom)
+							fallback = True
+						elif not res:
 							return 0
+						#else:
+							#print "     * resolved ", atom
 
 					except portage.exception.InvalidAtom, e:
 						show_invalid_depstring_notice(
@@ -5192,6 +5233,7 @@
 			portage.writemsg("!!! Please notify the package maintainer " + \
 				"that atoms must be fully-qualified.\n", noiselevel=-1)
 			return 0
+
 		return 1
 
 	def _priority(self, **kwargs):
@@ -5363,7 +5405,7 @@
 				args.append(PackageArg(arg=x, package=pkg,
 					root_config=root_config))
 			elif x.startswith(os.path.sep):
-				if not x.startswith(myroot):
+				if not x.startswith(myroot.root()):
 					portage.writemsg(("\n\n!!! '%s' does not start with" + \
 						" $ROOT.\n") % x, noiselevel=-1)
 					return 0, []
@@ -5447,7 +5489,7 @@
 			for x in lookup_owners:
 				if not search_for_multiple and os.path.isdir(x):
 					search_for_multiple = True
-				relative_paths.append(x[len(myroot):])
+				relative_paths.append(x[len(myroot.root()):])
 
 			owners = set()
 			for pkg, relative_path in \
@@ -6446,7 +6488,10 @@
 					# packages that are in the graph in order to avoid warning
 					# about those that will be automatically uninstalled during
 					# the merge process or by --depclean.
-					if pkg in final_db:
+					#
+					# Also only warn if the target portage instance is the
+					# same as the one the package has been installed into.
+					if pkg in final_db and pkg.root is self.target_root:
 						if pkg_in_graph and not visible(pkgsettings, pkg):
 							self._masked_installed.add(pkg)
 
@@ -7721,6 +7766,7 @@
 		# Use this set to detect when all the "repoadd" strings are "[0]"
 		# and disable the entire repo display in this case.
 		repoadd_set = set()
+		archadd_set = set()
 
 		for mylist_index in xrange(len(mylist)):
 			x, depth, ordered = mylist[mylist_index]
@@ -7873,6 +7919,7 @@
 
 				verboseadd = ""
 				repoadd = None
+				archadd = None
 
 				if True:
 					# USE flag display
@@ -8024,6 +8071,9 @@
 					if repoadd:
 						repoadd_set.add(repoadd)
 
+					archadd = "for " + purple(pkg.root_config.settings["ARCH"])
+					archadd_set.add(archadd)
+
 				xs = [portage.cpv_getkey(pkg_key)] + \
 					list(portage.catpkgsplit(pkg_key)[2:])
 				if xs[2] == "r0":
@@ -8110,7 +8160,7 @@
 					if ordered:
 						counters.interactive += 1
 
-				if x[1]!="/":
+				if x[1]!=BROOT:
 					if myoldbest:
 						myoldbest +=" "
 					if "--columns" in self.myopts:
@@ -8118,7 +8168,7 @@
 							myprint=addl+" "+indent+pkgprint(pkg_cp)
 							myprint=myprint+darkblue(" "+xs[1]+xs[2])+" "
 							myprint=myprint+myoldbest
-							myprint=myprint+darkgreen("to "+x[1])
+							myprint=myprint+"to " + darkyellow(x[1])
 							verboseadd = None
 						else:
 							if not pkg_merge:
@@ -8135,14 +8185,14 @@
 							if (oldlp-nc_len(myprint)) > 0:
 								myprint=myprint+" "*(oldlp-nc_len(myprint))
 							myprint=myprint+myoldbest
-							myprint += darkgreen("to " + pkg.root)
+							myprint += "to " + darkyellow(`pkg.root`)
 					else:
 						if not pkg_merge:
 							myprint = "[%s] " % pkgprint(pkg_status.ljust(13))
 						else:
 							myprint = "[%s %s] " % (pkgprint(pkg_type), addl)
 						myprint += indent + pkgprint(pkg_key) + " " + \
-							myoldbest + darkgreen("to " + myroot)
+							myoldbest + "to " + darkyellow(`myroot`)
 				else:
 					if "--columns" in self.myopts:
 						if "--quiet" in self.myopts:
@@ -8178,7 +8228,7 @@
 
 				if columns and pkg.operation == "uninstall":
 					continue
-				p.append((myprint, verboseadd, repoadd))
+				p.append((myprint, verboseadd, repoadd, archadd))
 
 				if "--tree" not in self.myopts and \
 					"--quiet" not in self.myopts and \
@@ -8200,8 +8250,11 @@
 				out.write("%s\n" % (x,))
 				continue
 
-			myprint, verboseadd, repoadd = x
+			myprint, verboseadd, repoadd, archadd = x
 
+			if len(archadd_set) > 1:
+				myprint += " " + archadd
+
 			if verboseadd:
 				myprint += " " + verboseadd
 
@@ -8446,7 +8499,7 @@
 				writemsg("\n\n!!! '%s' has invalid PROVIDE: %s\n" % \
 					(pkg_key, str(e)), noiselevel=-1)
 				writemsg("!!! see '%s'\n\n" % os.path.join(
-					root, portage.VDB_PATH, pkg_key, "PROVIDE"), noiselevel=-1)
+					root(), portage.VDB_PATH, pkg_key, "PROVIDE"), noiselevel=-1)
 				del e
 		all_added = []
 		for k in self._sets:
@@ -9727,7 +9780,7 @@
 	_bad_resume_opts = set(["--ask", "--changelog",
 		"--resume", "--skipfirst"])
 
-	_fetch_log = EPREFIX + "/var/log/emerge-fetch.log"
+	_fetch_log = os.path.join(BROOT(), "var/log/emerge-fetch.log")
 
 	class _iface_class(SlotObject):
 		__slots__ = ("dblinkEbuildPhase", "dblinkDisplayMerge",
@@ -9790,7 +9843,7 @@
 		spinner, mergelist, favorites, digraph):
 		PollScheduler.__init__(self)
 		self.settings = settings
-		self.target_root = settings["ROOT"]
+		self.target_root = settings.root
 		self.trees = trees
 		self.myopts = myopts
 		self._spinner = spinner
@@ -9820,7 +9873,7 @@
 
 		# The root where the currently running
 		# portage instance is installed.
-		self._running_root = trees["/"]["root_config"]
+		self._running_root = trees[BROOT]["root_config"]
 		self.edebug = 0
 		if settings.get("PORTAGE_DEBUG", "") == "1":
 			self.edebug = 1
@@ -10464,8 +10517,8 @@
 			printer = portage.output.EOutput()
 			for mysettings, key, logentries in self._failed_pkgs_die_msgs:
 				root_msg = ""
-				if mysettings["ROOT"] != "/":
-					root_msg = " merged to %s" % mysettings["ROOT"]
+				if mysettings.root != BROOT:
+					root_msg = " merged to %s" % mysettings.root()
 				print
 				printer.einfo("Error messages for package %s%s:" % \
 					(colorize("INFORM", key), root_msg))
@@ -10742,7 +10795,7 @@
 		return temp_settings
 
 	def _deallocate_config(self, settings):
-		self._config_pool[settings["ROOT"]].append(settings)
+		self._config_pool[settings.root].append(settings)
 
 	def _main_loop(self):
 
@@ -10892,8 +10945,8 @@
 		pkg = failed_pkg.pkg
 		msg = "%s to %s %s" % \
 			(bad("Failed"), action, colorize("INFORM", pkg.cpv))
-		if pkg.root != "/":
-			msg += " %s %s" % (preposition, pkg.root)
+		if pkg.root != BROOT:
+			msg += " %s %s" % (preposition, `pkg.root`)
 
 		log_path = self._locate_failure_log(failed_pkg)
 		if log_path is not None:
@@ -11269,7 +11322,7 @@
 			pkg_cache[cpv] = pkg
 		return pkg
 
-	vdb_path = os.path.join(settings["ROOT"], portage.VDB_PATH)
+	vdb_path = os.path.join(settings.root(), portage.VDB_PATH)
 	try:
 		# At least the parent needs to exist for the lock file.
 		portage.util.ensure_dirs(vdb_path)
@@ -11340,7 +11393,7 @@
 	
 					sp_absx_len = len(sp_absx)
 	
-					vdb_path = os.path.join(settings["ROOT"], portage.VDB_PATH)
+					vdb_path = os.path.join(settings.root(), portage.VDB_PATH)
 					vdb_len  = len(vdb_path)
 	
 					sp_vdb     = vdb_path.split("/")
@@ -11373,10 +11426,10 @@
 		newline=""
 		if (not "--quiet" in myopts):
 			newline="\n"
-		if settings["ROOT"] != "/":
+		if settings.root != BROOT:
 			writemsg_level(darkgreen(newline+ \
 				">>> Using system located in ROOT tree %s\n" % \
-				settings["ROOT"]))
+				`settings.root`))
 
 		if (("--pretend" in myopts) or ("--ask" in myopts)) and \
 			not ("--quiet" in myopts):
@@ -11722,7 +11775,7 @@
 			emergelog(xterm_titles, "=== Unmerging... ("+y+")")
 			mysplit = y.split("/")
 			#unmerge...
-			retval = portage.unmerge(mysplit[0], mysplit[1], settings["ROOT"],
+			retval = portage.unmerge(mysplit[0], mysplit[1], settings.root,
 				mysettings, unmerge_action not in ["clean","prune"],
 				vartree=vartree, ldpath_mtimes=ldpath_mtimes,
 				scheduler=scheduler)
@@ -11743,7 +11796,7 @@
 
 def chk_updated_info_files(root, infodirs, prev_mtimes, retval):
 
-	if os.path.exists(EPREFIX+"/usr/bin/install-info"):
+	if os.path.exists(os.path.join(BROOT(), "usr/bin/install-info")):
 		out = portage.output.EOutput()
 		regen_infodirs=[]
 		for z in infodirs:
@@ -11803,7 +11856,7 @@
 									raise
 								del e
 					processed_count += 1
-					myso=commands.getstatusoutput("LANG=C LANGUAGE=C "+EPREFIX+"/usr/bin/install-info --dir-file="+inforoot+"/dir "+inforoot+"/"+x)[1]
+					myso=commands.getstatusoutput("LANG=C LANGUAGE=C "+BROOT()+"usr/bin/install-info --dir-file="+inforoot+"/dir "+inforoot+"/"+x)[1]
 					existsstr="already exists, for file `"
 					if myso!="":
 						if re.search(existsstr,myso):
@@ -11859,7 +11912,7 @@
 	portdb = trees["porttree"].dbapi
 	vardb = trees["vartree"].dbapi
 	NEWS_PATH = os.path.join("metadata", "news")
-	UNREAD_PATH = os.path.join(target_root, NEWS_LIB_PATH, "news")
+	UNREAD_PATH = os.path.join(target_root(), NEWS_LIB_PATH, "news")
 	newsReaderDisplay = False
 	update = "--pretend" not in myopts
 
@@ -12022,7 +12075,7 @@
 		# If vdb state has not changed then there's nothing else to do.
 		sys.exit(retval)
 
-	vdb_path = os.path.join(target_root, portage.VDB_PATH)
+	vdb_path = os.path.join(target_root(), portage.VDB_PATH)
 	portage.util.ensure_dirs(vdb_path)
 	vdb_lock = None
 	if os.access(vdb_path, os.W_OK) and not "--pretend" in myopts:
@@ -12031,14 +12084,14 @@
 	if vdb_lock:
 		try:
 			if "noinfo" not in settings.features:
-				chk_updated_info_files(target_root + EPREFIX,
+				chk_updated_info_files(target_root(),
 					infodirs, info_mtimes, retval)
 			mtimedb.commit()
 		finally:
 			if vdb_lock:
 				portage.locks.unlockdir(vdb_lock)
 
-	chk_updated_cfg_files(target_root + EPREFIX, config_protect)
+	chk_updated_cfg_files(target_root, config_protect)
 	
 	display_news_notification(root_config, myopts)
 	if retval in (None, os.EX_OK) or (not "--pretend" in myopts):
@@ -12052,7 +12105,7 @@
 		#number of directories with some protect files in them
 		procount=0
 		for x in config_protect:
-			x = os.path.join(target_root, x.lstrip(os.path.sep))
+			x = os.path.join(target_root(), x.lstrip(os.path.sep))
 			if not os.access(x, os.W_OK):
 				# Avoid Permission denied errors generated
 				# later by `find`.
@@ -12244,7 +12297,7 @@
 				"control (contains %s).\n!!! Aborting rsync sync.\n") % \
 				(myportdir, vcs_dir), level=logging.ERROR, noiselevel=-1)
 			return 1
-		if not os.path.exists(EPREFIX+"/usr/bin/rsync"):
+		if not os.path.exists(os.path.join(BROOT(), "usr/bin/rsync")):
 			print "!!! /usr/bin/rsync does not exist, so rsync support is disabled."
 			print "!!! Type \"emerge net-misc/rsync\" to enable rsync support."
 			sys.exit(1)
@@ -12424,7 +12477,7 @@
 			if mytimestamp != 0 and "--quiet" not in myopts:
 				print ">>> Checking server timestamp ..."
 
-			rsynccommand = [EPREFIX+"/usr/bin/rsync"] + rsync_opts + extra_rsync_opts
+			rsynccommand = [BROOT()+"usr/bin/rsync"] + rsync_opts + extra_rsync_opts
 
 			if "--debug" in myopts:
 				print rsynccommand
@@ -12575,7 +12628,7 @@
 				out.eerror(line)
 			sys.exit(exitcode)
 	elif syncuri[:6]=="cvs://":
-		if not os.path.exists(EPREFIX+"/usr/bin/cvs"):
+		if not os.path.exists(os.path.join(BROOT(), "usr/bin/cvs")):
 			print "!!! cvs does not exist, so CVS support is disabled."
 			print "!!! Type \"emerge dev-util/cvs\" to enable CVS support."
 			sys.exit(1)
@@ -12609,7 +12662,7 @@
 				sys.exit(retval)
 		dosyncuri = syncuri
 	elif syncuri[:11]=="svn+http://" or syncuri[:6]=="svn://" or syncuri[:12]=="svn+https://":
-		if not os.path.exists(EPREFIX+"/usr/bin/svn"):
+		if not os.path.exists(os.path.join(BROOT(), "usr/bin/svn")):
 			print "!!! svn does not exist, so SVN support is disabled."
 			print "!!! Type \"emerge dev-util/subversion\" to enable SVN support."
 			sys.exit(1)
@@ -12667,8 +12720,8 @@
 
 	# Reload the whole config from scratch.
 	settings, trees, mtimedb = load_emerge_config(trees=trees)
-	root_config = trees[settings["ROOT"]]["root_config"]
-	portdb = trees[settings["ROOT"]]["porttree"].dbapi
+	root_config = trees[settings.root]["root_config"]
+	portdb = trees[settings.root]["porttree"].dbapi
 
 	if os.path.exists(myportdir+"/metadata/cache") and updatecache_flg:
 		action_metadata(settings, portdb, myopts)
@@ -12677,24 +12730,24 @@
 		mtimedb.commit()
 		# Reload the whole config from scratch.
 		settings, trees, mtimedb = load_emerge_config(trees=trees)
-		portdb = trees[settings["ROOT"]]["porttree"].dbapi
-		root_config = trees[settings["ROOT"]]["root_config"]
+		portdb = trees[settings.root]["porttree"].dbapi
+		root_config = trees[settings.root]["root_config"]
 
 	mybestpv = portdb.xmatch("bestmatch-visible",
 		portage.const.PORTAGE_PACKAGE_ATOM)
 	mypvs = portage.best(
-		trees[settings["ROOT"]]["vartree"].dbapi.match(
+		trees[settings.root]["vartree"].dbapi.match(
 		portage.const.PORTAGE_PACKAGE_ATOM))
 
-	chk_updated_cfg_files(EPREFIX, settings.get("CONFIG_PROTECT","").split())
+	chk_updated_cfg_files(BROOT, settings.get("CONFIG_PROTECT","").split())
 
 	if myaction != "metadata":
-		if os.access(portage.USER_CONFIG_PATH + EPREFIX + "/bin/post_sync", os.X_OK):
+		if os.access(os.path.join(BROOT(), portage.USER_CONFIG_PATH, "/bin/post_sync"), os.X_OK):
 			retval = portage.process.spawn(
-				[os.path.join(portage.USER_CONFIG_PATH, EPREFIX_LSTRIP, "bin", "post_sync"),
+				[os.path.join(BROOT(), portage.USER_CONFIG_PATH, "bin", "post_sync"),
 				dosyncuri], env=settings.environ())
 			if retval != os.EX_OK:
-				print red(" * ")+bold("spawn failed of "+ portage.USER_CONFIG_PATH + EPREFIX + "/bin/post_sync")
+				print red(" * ")+bold("spawn failed of "+ BROOT() + portage.USER_CONFIG_PATH + "/bin/post_sync")
 
 	if(mybestpv != mypvs) and not "--quiet" in myopts:
 		print
@@ -12938,7 +12991,7 @@
 		sys.exit(1)
 	print
 	try:
-		pkgs = trees[settings["ROOT"]]["vartree"].dbapi.match(myfiles[0])
+		pkgs = trees[settings.root]["vartree"].dbapi.match(myfiles[0])
 	except portage.exception.AmbiguousPackageName, e:
 		# Multiple matches thrown from cpv_expand
 		pkgs = e.args[0]
@@ -12976,23 +13029,23 @@
 	else:
 		print "Configuring pkg..."
 	print
-	ebuildpath = trees[settings["ROOT"]]["vartree"].dbapi.findname(pkg)
+	ebuildpath = trees[settings.root]["vartree"].dbapi.findname(pkg)
 	mysettings = portage.config(clone=settings)
-	vardb = trees[mysettings["ROOT"]]["vartree"].dbapi
+	vardb = trees[mysettings.root]["vartree"].dbapi
 	debug = mysettings.get("PORTAGE_DEBUG") == "1"
-	retval = portage.doebuild(ebuildpath, "config", mysettings["ROOT"],
+	retval = portage.doebuild(ebuildpath, "config", mysettings.root,
 		mysettings,
 		debug=(settings.get("PORTAGE_DEBUG", "") == 1), cleanup=True,
-		mydbapi=trees[settings["ROOT"]]["vartree"].dbapi, tree="vartree")
+		mydbapi=trees[settings.root]["vartree"].dbapi, tree="vartree")
 	if retval == os.EX_OK:
-		portage.doebuild(ebuildpath, "clean", mysettings["ROOT"],
+		portage.doebuild(ebuildpath, "clean", mysettings.root,
 			mysettings, debug=debug, mydbapi=vardb, tree="vartree")
 	print
 
 def action_info(settings, trees, myopts, myfiles):
-	print getportageversion(settings["PORTDIR"], settings["ROOT"],
+	print getportageversion(settings["PORTDIR"], settings.root,
 		settings.profile_path, settings["CHOST"],
-		trees[settings["ROOT"]]["vartree"].dbapi)
+		trees[settings.root]["vartree"].dbapi)
 	header_width = 65
 	header_title = "System Settings"
 	if myfiles:
@@ -13033,7 +13086,7 @@
 
 	for x in myvars:
 		if portage.isvalidatom(x):
-			pkg_matches = trees["/"]["vartree"].dbapi.match(x)
+			pkg_matches = trees[BROOT]["vartree"].dbapi.match(x)
 			pkg_matches = [portage.catpkgsplit(cpv)[1:] for cpv in pkg_matches]
 			pkg_matches.sort(portage.pkgcmp)
 			pkgs = []
@@ -13048,7 +13101,7 @@
 		else:
 			print "%-20s %s" % (x+":", "[NOT VALID]")
 
-	libtool_vers = ",".join(trees["/"]["vartree"].dbapi.match("sys-devel/libtool"))
+	libtool_vers = ",".join(trees[BROOT]["vartree"].dbapi.match("sys-devel/libtool"))
 
 	if "--verbose" in myopts:
 		myvars=settings.keys()
@@ -13100,8 +13153,8 @@
 	# See if we can find any packages installed matching the strings
 	# passed on the command line
 	mypkgs = []
-	vardb = trees[settings["ROOT"]]["vartree"].dbapi
-	portdb = trees[settings["ROOT"]]["porttree"].dbapi
+	vardb = trees[settings.root]["vartree"].dbapi
+	portdb = trees[settings.root]["porttree"].dbapi
 	for x in myfiles:
 		mypkgs.extend(vardb.match(x))
 
@@ -13167,9 +13220,9 @@
 			if not ebuildpath or not os.path.exists(ebuildpath):
 				out.ewarn("No ebuild found for '%s'" % pkg)
 				continue
-			portage.doebuild(ebuildpath, "info", pkgsettings["ROOT"],
+			portage.doebuild(ebuildpath, "info", pkgsettings.root,
 				pkgsettings, debug=(settings.get("PORTAGE_DEBUG", "") == 1),
-				mydbapi=trees[settings["ROOT"]]["vartree"].dbapi,
+				mydbapi=trees[settings.root]["vartree"].dbapi,
 				tree="vartree")
 
 def action_search(root_config, myopts, myfiles, spinner):
@@ -13222,7 +13275,7 @@
 			portage.writemsg_stdout(colorize("WARN", " * ") + x)
 
 	xterm_titles = "notitles" not in settings.features
-	myroot = settings["ROOT"]
+	myroot = settings.root
 	root_config = trees[myroot]["root_config"]
 	getSetAtoms = root_config.setconfig.getSetAtoms
 	vardb = trees[myroot]["vartree"].dbapi
@@ -14118,7 +14171,7 @@
 			portage.writemsg("\n!!! %s\n" % str(e), noiselevel=-1)
 			return 1
 		except portage.exception.PackageSetNotFound, e:
-			root_config = trees[settings["ROOT"]]["root_config"]
+			root_config = trees[settings.root]["root_config"]
 			display_missing_pkg_set(root_config, e.value)
 			return 1
 		if show_spinner:
@@ -14157,7 +14210,7 @@
 					mergecount += 1
 
 			if mergecount==0:
-				sets = trees[settings["ROOT"]]["root_config"].sets
+				sets = trees[settings.root]["root_config"].sets
 				world_candidates = None
 				if "--noreplace" in myopts and \
 					not oneshot and favorites:
@@ -14277,7 +14330,7 @@
 						if settings.get("PORTAGE_DEBUG", "") == "1":
 							edebug = 1
 						retval = portage.doebuild(
-							y, "digest", settings["ROOT"], tmpsettings, edebug,
+							y, "digest", settings.root, tmpsettings, edebug,
 							("--pretend" in myopts),
 							mydbapi=trees[pkgline[1]]["porttree"].dbapi,
 							tree="porttree")
@@ -14296,15 +14349,18 @@
 		if retval == os.EX_OK and not (buildpkgonly or fetchonly or pretend):
 			if "yes" == settings.get("AUTOCLEAN"):
 				portage.writemsg_stdout(">>> Auto-cleaning packages...\n")
-				unmerge(trees[settings["ROOT"]]["root_config"],
+				unmerge(trees[settings.root]["root_config"],
 					myopts, "clean", [],
 					ldpath_mtimes, autoclean=1)
 			else:
 				portage.writemsg_stdout(colorize("WARN", "WARNING:")
 					+ " AUTOCLEAN is disabled.  This can cause serious"
 					+ " problems due to overlapping packages.\n")
-			trees[settings["ROOT"]]["vartree"].dbapi.plib_registry.pruneNonExisting()
+			trees[settings.root]["vartree"].dbapi.plib_registry.pruneNonExisting()
 
+		if merge_count and not (buildpkgonly or fetchonly or pretend):
+			root_config = trees[settings.root]["root_config"]
+			post_emerge(root_config, myopts, mtimedb, retval)
 		return retval
 
 def multiple_actions(action1, action2):
@@ -14519,6 +14575,8 @@
 		v = os.environ.get(envvar, None)
 		if v and v.strip():
 			kwargs[k] = v
+ 	if "target_root" in kwargs:
+ 		kwargs["target_root"] = portage.const.EROOTobject(kwargs["target_root"], EPREFIX)
 	trees = portage.create_trees(trees=trees, **kwargs)
 
 	for root, root_trees in trees.iteritems():
@@ -14526,14 +14584,14 @@
 		setconfig = load_default_config(settings, root_trees)
 		root_trees["root_config"] = RootConfig(settings, root_trees, setconfig)
 
-	settings = trees["/"]["vartree"].settings
+	settings = trees[BROOT]["vartree"].settings
 
 	for myroot in trees:
-		if myroot != "/":
+		if myroot != BROOT:
 			settings = trees[myroot]["vartree"].settings
 			break
 
-	mtimedbfile = os.path.join("/", portage.CACHE_PATH.lstrip(os.path.sep), "mtimedb")
+	mtimedbfile = os.path.join(BROOT(), portage.CACHE_PATH, "mtimedb")
 	mtimedb = portage.MtimeDB(mtimedbfile)
 	
 	return settings, trees, mtimedb
@@ -14941,7 +14999,7 @@
 	# Portage needs to ensure a sane umask for the files it creates.
 	os.umask(022)
 	settings, trees, mtimedb = load_emerge_config()
-	portdb = trees[settings["ROOT"]]["porttree"].dbapi
+	portdb = trees[settings.root]["porttree"].dbapi
 	rval = profile_check(trees, myaction, myopts)
 	if rval != os.EX_OK:
 		return rval
@@ -14950,7 +15008,7 @@
 		mtimedb.commit()
 		# Reload the whole config from scratch.
 		settings, trees, mtimedb = load_emerge_config(trees=trees)
-		portdb = trees[settings["ROOT"]]["porttree"].dbapi
+		portdb = trees[settings.root]["porttree"].dbapi
 
 	xterm_titles = "notitles" not in settings.features
 
@@ -14965,7 +15023,7 @@
 		# Reload the whole config from scratch so that the portdbapi internal
 		# config is updated with new FEATURES.
 		settings, trees, mtimedb = load_emerge_config(trees=trees)
-		portdb = trees[settings["ROOT"]]["porttree"].dbapi
+		portdb = trees[settings.root]["porttree"].dbapi
 
 	for myroot in trees:
 		mysettings =  trees[myroot]["vartree"].settings
@@ -15140,9 +15198,9 @@
 			spinner.update = spinner.update_basic
 
 	if "--version" in myopts:
-		print getportageversion(settings["PORTDIR"], settings["ROOT"],
+		print getportageversion(settings["PORTDIR"], settings.root,
 			settings.profile_path, settings["CHOST"],
-			trees[settings["ROOT"]]["vartree"].dbapi)
+			trees[settings.root]["vartree"].dbapi)
 		return 0
 	elif "--help" in myopts:
 		_emerge.help.help(myaction, myopts, portage.output.havecolor)
@@ -15259,7 +15317,7 @@
 	# SEARCH action
 	elif "search"==myaction:
 		validate_ebuild_environment(trees)
-		action_search(trees[settings["ROOT"]]["root_config"],
+		action_search(trees[settings.root]["root_config"],
 			myopts, myfiles, spinner)
 	elif myaction in ("clean", "unmerge") or \
 		(myaction == "prune" and "--nodeps" in myopts):
@@ -15289,7 +15347,7 @@
 	elif myaction in ("depclean", "info", "prune"):
 
 		# Ensure atoms are valid before calling unmerge().
-		vardb = trees[settings["ROOT"]]["vartree"].dbapi
+		vardb = trees[settings.root]["vartree"].dbapi
 		valid_atoms = []
 		for x in myfiles:
 			if is_valid_package_atom(x):
Index: cnf/Makefile.in
===================================================================
--- cnf/Makefile.in	(revision 12574)
+++ cnf/Makefile.in	(working copy)
@@ -32,7 +32,7 @@
 	$(INSTALL) -d -m 755 -o "$(portageuser)" -g "$(portagegroup)" $(DESTDIR)$(sysconfdir)
 	$(INSTALL_cnfsubst) $(srcdir)/dispatch-conf.conf $(DESTDIR)$(sysconfdir)/dispatch-conf.conf
 	$(INSTALL_cnfsubst) $(srcdir)/etc-update.conf $(DESTDIR)$(sysconfdir)/etc-update.conf
-	( cd $(DESTDIR)$(sysconfdir) && ln -s $(DESTDIR)$(datadir)/portage/config/make.globals )
+	( cd $(DESTDIR)$(sysconfdir) && ln -fs $(DESTDIR)$(datadir)/portage/config/make.globals )
 	
 distdir:
 	$(list_sourcedir) | while read f \
Index: bin/fix-db.py
===================================================================
--- bin/fix-db.py	(revision 12574)
+++ bin/fix-db.py	(working copy)
@@ -20,7 +20,7 @@
 import portage.const
 
 
-mylog = open(portage.const.EPREFIX+"/var/log/emerge_fix-db.log", "a")
+mylog = open(portage.const.BROOT()+"/var/log/emerge_fix-db.log", "a")
 def writemsg(msg):
 	if msg[-1] != '\n':
 		msg += "\n"
@@ -30,7 +30,7 @@
 	mylog.flush()
 
 def fix_global_counter(value):
-	myf = open(portage.const.EPREFIX+"/var/cache/edb/counter")
+	myf = open(portage.const.BROOT()+"/var/cache/edb/counter")
 	newvalue = value+1000
 	myf.write(str(newvalue))
 	myf.flush()
@@ -42,14 +42,14 @@
 times = {}
 
 try:
-	real_counter = long(open(portage.const.EPREFIX+"/var/cache/edb/counter").read())
+	real_counter = long(open(portage.const.BROOT()+"/var/cache/edb/counter").read())
 except SystemExit, e:
 	raise  # This needs to be propogated
 except:
 	writemsg("ERROR: Real counter is invalid.\n")
 	real_counter = 0
 
-vardbdir = root+VDB_PATH+"/"
+vardbdir = root()+VDB_PATH+"/"
 for cat in os.listdir(vardbdir):
 	catdir = vardbdir+cat+"/"
 	if not os.path.isdir(catdir):
Index: bin/repoman
===================================================================
--- bin/repoman	(revision 12574)
+++ bin/repoman	(working copy)
@@ -497,17 +497,17 @@
 repoman_settings = portage.config(local_config=False,
 	config_incrementals=portage.const.INCREMENTALS)
 trees = portage.create_trees()
-trees["/"]["porttree"].settings = repoman_settings
-portdb = trees["/"]["porttree"].dbapi
+trees[portage.const.BROOT]["porttree"].settings = repoman_settings
+portdb = trees[portage.const.BROOT]["porttree"].dbapi
 portdb.mysettings = repoman_settings
-setconfig = load_default_config(repoman_settings, trees["/"])
-root_config = RootConfig(repoman_settings, trees["/"], setconfig)
+setconfig = load_default_config(repoman_settings, trees[portage.const.BROOT])
+root_config = RootConfig(repoman_settings, trees[portage.const.BROOT], setconfig)
 # We really only need to cache the metadata that's necessary for visibility
 # filtering. Anything else can be discarded to reduce memory consumption.
 portdb._aux_cache_keys.clear()
 portdb._aux_cache_keys.update(["EAPI", "KEYWORDS", "SLOT"])
 # dep_zapdeps looks at the vardbapi, but it shouldn't for repoman.
-del trees["/"]["vartree"]
+del trees[portage.const.BROOT]["vartree"]
 
 myreporoot = os.path.basename(portdir_overlay)
 myreporoot += mydir[len(portdir_overlay):]
@@ -697,7 +697,7 @@
 
 	except (OSError,IOError), e:
 		if e.errno != 2:
-			print red("!!!")+" caught exception '%s' for %s/metadata.dtd, bailing" % (str(e), portage.CACHE_PATH)
+			print red("!!!")+" caught exception '%s' for %s/metadata.dtd, bailing" % (str(e), BROOT() + portage.CACHE_PATH)
 			sys.exit(1)
 
 	if must_fetch:
@@ -1503,7 +1503,7 @@
 					xcache.update(shared_xmatch_caches)
 					arch_xmatch_caches[xmatch_cache_key] = xcache
 
-				trees["/"]["porttree"].settings = dep_settings
+				trees[portage.const.BROOT]["porttree"].settings = dep_settings
 				portdb.mysettings = dep_settings
 				portdb.xcache = xcache
 				# for package.use.mask support inside dep_check
Index: bin/archive-conf
===================================================================
--- bin/archive-conf	(revision 12574)
+++ bin/archive-conf	(working copy)
@@ -64,7 +64,7 @@
         md5_match_hash[conf] = ''
 
     # Find all the CONTENT files in VDB_PATH.
-    content_files += os.popen(FIND_EXTANT_CONTENTS % (portage.root+portage.VDB_PATH)).readlines()
+    content_files += os.popen(FIND_EXTANT_CONTENTS % (portage.root()+portage.VDB_PATH)).readlines()
 
     # Search for the saved md5 checksum of all the specified config files
     # and see if the current file is unmodified or not.
Index: bin/quickpkg
===================================================================
--- bin/quickpkg	(revision 12574)
+++ bin/quickpkg	(working copy)
@@ -23,7 +23,7 @@
 	from portage.checksum import perform_md5
 	import tarfile
 	import portage
-	root = portage.settings["ROOT"]
+	root = portage.settings.root
 	trees = portage.db[root]
 	vartree = trees["vartree"]
 	vardb = vartree.dbapi
Index: bin/portageq
===================================================================
--- bin/portageq	(revision 12574)
+++ bin/portageq	(working copy)
@@ -56,7 +56,7 @@
 			noiselevel=-1)
 		return 2
 	try:
-		mylist=portage.db[argv[0]]["vartree"].dbapi.match(argv[1])
+		mylist=portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["vartree"].dbapi.match(argv[1])
 		if mylist:
 			sys.exit(0)
 		else:
@@ -78,7 +78,7 @@
 			noiselevel=-1)
 		return 2
 	try:
-		mylist=portage.db[argv[0]]["vartree"].dbapi.match(argv[1])
+		mylist=portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["vartree"].dbapi.match(argv[1])
 		print portage.best(mylist)
 	except KeyError:
 		sys.exit(1)
@@ -94,7 +94,7 @@
 		sys.exit(2)
 	try:
 		for pack in argv[1:]:
-			mylist=portage.db[argv[0]]["vartree"].dbapi.match(pack)
+			mylist=portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["vartree"].dbapi.match(pack)
 			print pack+":"+portage.best(mylist)
 	except KeyError:
 		sys.exit(1)
@@ -118,8 +118,10 @@
 		print >> sys.stderr, "Unrecognized package type: '%s'" % pkgtype
 		sys.exit(1)
 	trees = portage.db
-	if os.path.realpath(root) == os.path.realpath(portage.settings["ROOT"]):
-		root = portage.settings["ROOT"] # contains the normalized $ROOT
+	if os.path.realpath(root) == os.path.realpath(portage.settings.root.root()):
+		root = portage.settings.root # contains the normalized $ROOT
+	else:
+		root = portage.const.EROOTobject(root, portage.EPREFIX)
 	try:
 			values = trees[root][type_map[pkgtype]].dbapi.aux_get(
 				pkgspec, metakeys)
@@ -142,6 +144,7 @@
 		return 2
 
 	root, cpv = argv
+	root = portage.const.EROOTobject(root, portage.EPREFIX)
 	vartree = portage.db[root]["vartree"]
 	if not vartree.dbapi.cpv_exists(cpv):
 		sys.stderr.write("Package not found: '%s'\n" % cpv)
@@ -171,7 +174,7 @@
 
 	from portage import catsplit, dblink
 	settings = portage.settings
-	root = settings["ROOT"]
+	root = settings.root
 	vardb = portage.db[root]["vartree"].dbapi
 
 	cwd = None
@@ -190,11 +193,11 @@
 				return 2
 			f = os.path.join(cwd, f)
 			f = portage.normalize_path(f)
-		if not f.startswith(root):
+		if not f.startswith(root.root()):
 			sys.stderr.write("ERROR: file paths must begin with <root>!\n")
 			sys.stderr.flush()
 			return 2
-		files.append(f[len(root):])
+		files.append(f[len(root.root()):])
 
 	owners = vardb._owners.get_owners(files)
 
@@ -203,7 +206,7 @@
 		sys.stdout.write("%s\n" % cpv)
 		for f in sorted(owned_files):
 			sys.stdout.write("\t%s\n" % \
-				os.path.join(root, f.lstrip(os.path.sep)))
+				os.path.join(root.root(), f.lstrip(os.path.sep)))
 	if owners:
 		sys.stdout.flush()
 		return 0
@@ -225,6 +228,7 @@
 		return 2
 
 	root, filename = argv
+	root = portage.const.EROOTobject(root, portage.EPREFIX)
 
 	err = sys.stderr
 	cwd = None
@@ -242,7 +246,7 @@
 		f = os.path.join(cwd, f)
 		f = portage.normalize_path(f)
 
-	if not f.startswith(root):
+	if not f.startswith(root.root()):
 		err.write("ERROR: file paths must begin with <root>!\n")
 		err.flush()
 		return 2
@@ -272,6 +276,7 @@
 		return 2
 
 	root, = argv
+	root = portage.const.EROOTobject(root, portage.EPREFIX)
 	out = sys.stdout
 	err = sys.stderr
 	cwd = None
@@ -303,7 +308,7 @@
 			f = os.path.join(cwd, f)
 			f = portage.normalize_path(f)
 
-		if not f.startswith(root):
+		if not f.startswith(root.root()):
 			err.write("ERROR: file paths must begin with <root>!\n")
 			err.flush()
 			errors += 1
@@ -329,7 +334,7 @@
 		print "ERROR: insufficient parameters!"
 		sys.exit(2)
 	try:
-		mylist=portage.db[argv[0]]["porttree"].dbapi.match(argv[1])
+		mylist=portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.match(argv[1])
 		visible=portage.best(mylist)
 		if visible:
 			print visible
@@ -350,7 +355,7 @@
 		sys.exit(2)
 	try:
 		for pack in argv[1:]:
-			mylist=portage.db[argv[0]]["porttree"].dbapi.match(pack)
+			mylist=portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.match(pack)
 			print pack+":"+portage.best(mylist)
 	except KeyError:
 		sys.exit(1)
@@ -365,8 +370,8 @@
 		print "ERROR: insufficient parameters!"
 	
 	#print portage.db[argv[0]]["porttree"].dbapi.cp_all()
-	for pkg in portage.db[argv[0]]["porttree"].dbapi.cp_all():
-		mybest=portage.best(portage.db[argv[0]]["porttree"].dbapi.match(pkg))
+	for pkg in portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.cp_all():
+		mybest=portage.best(portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.match(pkg))
 		if mybest:
 			print mybest
 all_best_visible.uses_root = True
@@ -382,6 +387,7 @@
 		print "ERROR: expected 2 parameters, got %d!" % len(argv)
 		sys.exit(2)
 	root, atom = argv
+	root = portage.const.EROOTobject(root, portage.EPREFIX)
 	if atom:
 		if atom_validate_strict and not portage.isvalidatom(atom):
 			portage.writemsg("ERROR: Invalid atom: '%s'\n" % atom,
@@ -402,7 +408,7 @@
 	set environment/configuration options.
 	"""
 	out = sys.stdout
-	out.write(os.path.join(portage.settings["ROOT"], portage.VDB_PATH) + "\n")
+	out.write(os.path.join(portage.settings.root(), portage.VDB_PATH) + "\n")
 	out.flush()
 	return os.EX_OK
 
@@ -481,7 +487,7 @@
 	if len(argv) < 1:
 		print "ERROR: insufficient parameters!"
 		sys.exit(2)
-	print " ".join(portage.db[argv[0]]["porttree"].dbapi.getRepositories())
+	print " ".join(portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.getRepositories())
 
 def get_repo_path(argv):
 	"""<root> <repo_id>+
@@ -491,7 +497,7 @@
 		print "ERROR: insufficient parameters!"
 		sys.exit(2)
 	for arg in argv[1:]:
-		print portage.db[argv[0]]["porttree"].dbapi.getRepositoryPath(arg)
+		print portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["porttree"].dbapi.getRepositoryPath(arg)
 
 def list_preserved_libs(argv):
 	"""<root>
@@ -503,7 +509,7 @@
 	if len(argv) != 1:
 		print "ERROR: wrong number of arguments"
 		sys.exit(2)
-	mylibs = portage.db[argv[0]]["vartree"].dbapi.plib_registry.getPreservedLibs()
+	mylibs = portage.db[portage.const.EROOTobject(argv[0], portage.const.EPREFIX)]["vartree"].dbapi.plib_registry.getPreservedLibs()
 	rValue = 0
 	for cpv in mylibs:
 		print cpv,
Index: bin/ebuild
===================================================================
--- bin/ebuild	(revision 12574)
+++ bin/ebuild	(working copy)
@@ -130,7 +130,7 @@
 	print "!!! %s does not follow correct package syntax." % (cpv)
 	sys.exit(1)
 
-if ebuild.startswith(portage.root + portage.const.VDB_PATH):
+if ebuild.startswith(portage.root() + portage.const.VDB_PATH):
 	mytree = "vartree"
 
 	portage_ebuild = portage.db[portage.root][mytree].dbapi.findname(cpv)
Index: bin/regenworld
===================================================================
--- bin/regenworld	(revision 12574)
+++ bin/regenworld	(working copy)
@@ -45,7 +45,7 @@
 		__uniqlist__.append(pkgline)
 		return True
 
-world_file = os.path.join(portage.const.EPREFIX, portage.WORLD_FILE)
+world_file = os.path.join(portage.const.BROOT(), portage.WORLD_FILE)
 
 # show a little description if we have arguments
 if len(sys.argv) >= 2 and sys.argv[1] in ["-h", "--help"]:
@@ -55,11 +55,11 @@
 	print "your existing world file (%s) before using this tool." % world_file
 	sys.exit(0)
 
-worldlist = portage.grabfile(os.path.join(portage.const.EPREFIX, portage.WORLD_FILE))
+worldlist = portage.grabfile(world_file)
 syslist = portage.settings.packages
 syslist = filter(issyspkg, syslist)
 
-logfile = portage.grabfile(portage.const.EPREFIX+"/var/log/emerge.log")
+logfile = portage.grabfile(os.path.join(portage.const.BROOT(), "var/log/emerge.log")
 biglist = filter(iscandidate, logfile)
 biglist = map(getpkginfo, biglist)
 tmplist = []
Index: bin/glsa-check
===================================================================
--- bin/glsa-check	(revision 12574)
+++ bin/glsa-check	(working copy)
@@ -126,8 +126,8 @@
 # delay this for speed increase
 from portage.glsa import *
 
-vardb = portage.db[portage.settings["ROOT"]]["vartree"].dbapi
-portdb = portage.db["/"]["porttree"].dbapi
+vardb = portage.db[portage.settings.root]["vartree"].dbapi
+portdb = portage.db[portage.const.BROOT]["porttree"].dbapi
 
 # build glsa lists
 completelist = get_glsa_list(portage.settings)
Index: bin/ebuild.sh
===================================================================
--- bin/ebuild.sh	(revision 12574)
+++ bin/ebuild.sh	(working copy)
@@ -70,6 +70,17 @@
 # Unset some variables that break things.
 unset GZIP BZIP BZIP2 CDPATH GREP_OPTIONS GREP_COLOR GLOBIGNORE
 
+# ROOT = / means, that the executables merged there are executable on the
+# current platform. this means, if this is not true for you, you really
+# need to set ROOT != /. DEFAULT_PATH contains the paths configured into
+# portage, which is BPREFIX. When setting EPREFIX to a distinct value, we
+# need to make sure both versions are in there. if BPREFIX = EPREFIX, paths
+# will be present 2 times. maybe we should check for their existance before
+# adding them?
+if [[ ${ROOT} == "/" ]]; then
+	DEFAULT_PATH=${EPREFIX}/usr/bin:${EPREFIX}/usr/sbin:${EPREFIX}/bin:${EPREFIX}/sbin:${DEFAULT_PATH}
+fi
+
 export PATH="${DEFAULT_PATH}:${PORTAGE_BIN_PATH}:${ROOTPATH}"
 [ ! -z "$PREROOTPATH" ] && export PATH="${PREROOTPATH%%:}:$PATH"
 
Index: bin/emaint
===================================================================
--- bin/emaint	(revision 12574)
+++ bin/emaint	(working copy)
@@ -34,13 +34,13 @@
 		self.okay = []
 		from portage.sets import load_default_config
 		setconfig = load_default_config(portage.settings,
-			portage.db[portage.settings["ROOT"]])
+			portage.db[portage.settings.root])
 		self._sets = setconfig.getSets()
 
 	def _check_world(self, onProgress):
 		categories = set(portage.settings.categories)
-		myroot = portage.settings["ROOT"]
-		self.world_file = os.path.join(myroot, portage.const.EPREFIX_LSTRIP, portage.const.WORLD_FILE)
+		myroot = portage.settings.root
+		self.world_file = os.path.join(myroot(), portage.const.WORLD_FILE)
 		self.found = os.access(self.world_file, os.R_OK)
 		vardb = portage.db[myroot]["vartree"].dbapi
 
@@ -115,7 +115,7 @@
 	name = staticmethod(name)
 
 	def __init__(self):
-		myroot = portage.settings["ROOT"]
+		myroot = portage.settings.root
 		self._bintree = portage.db[myroot]["bintree"]
 		self._bintree.populate()
 		self._pkgindex_file = os.path.join(self._bintree.pkgdir, "Packages")
@@ -329,7 +329,7 @@
 		return "moveinst"
 	name = staticmethod(name)
 	def __init__(self):
-		myroot = portage.settings["ROOT"]
+		myroot = portage.settings.root
 		MoveHandler.__init__(self, portage.db[myroot]["vartree"])
 
 class MoveBinary(MoveHandler):
@@ -340,7 +340,7 @@
 		return "movebin"
 	name = staticmethod(name)
 	def __init__(self):
-		myroot = portage.settings["ROOT"]
+		myroot = portage.settings.root
 		MoveHandler.__init__(self, portage.db[myroot]["bintree"])
 
 class VdbKeyHandler(object):
@@ -354,7 +354,7 @@
 		self.keys = ["HOMEPAGE", "SRC_URI", "KEYWORDS", "DESCRIPTION"]
 		
 		for p in self.list:
-			mydir = os.path.join(os.sep, portage.settings["ROOT"], portage.const.VDB_PATH, p)+os.sep
+			mydir = os.path.join(portage.settings.root(), portage.const.VDB_PATH, p)+os.sep
 			ismissing = True
 			for k in self.keys:
 				if os.path.exists(mydir+k):
@@ -371,7 +371,7 @@
 		errors = []
 	
 		for p in self.missing:
-			mydir = os.path.join(os.sep, portage.settings["ROOT"], portage.const.VDB_PATH, p)+os.sep
+			mydir = os.path.join(portage.settings.root(), portage.const.VDB_PATH, p)+os.sep
 			if not os.access(mydir+"environment.bz2", os.R_OK):
 				errors.append("Can't access %s" % (mydir+"environment.bz2"))
 			elif not os.access(mydir, os.W_OK):
