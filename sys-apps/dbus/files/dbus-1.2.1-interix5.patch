diff -ru -x '*.Po' -x '*.Plo' dbus-1.1.20.orig/dbus/dbus-server-unix.c dbus-1.1.20/dbus/dbus-server-unix.c
--- dbus-1.1.20.orig/dbus/dbus-server-unix.c	2008-03-19 12:04:07 +0100
+++ dbus-1.1.20/dbus/dbus-server-unix.c	2008-03-19 12:00:29 +0100
@@ -100,9 +100,16 @@
               return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
             }
               
+#if defined(__INTERIX)
+		  // need to take good care that this doesn't get too long!!
+          if (!_dbus_string_append (&filename,
+                                    "ds") ||
+              !_dbus_generate_random_ascii (&filename, 6) ||
+#else
           if (!_dbus_string_append (&filename,
                                     "dbus-") ||
               !_dbus_generate_random_ascii (&filename, 10) ||
+#endif
               !_dbus_string_append (&full_path, tmpdir) ||
               !_dbus_concat_dir_and_file (&full_path, &filename))
 
diff -ru -x '*.Po' -x '*.Plo' dbus-1.1.20.orig/dbus/dbus-sysdeps-unix.c dbus-1.1.20/dbus/dbus-sysdeps-unix.c
--- dbus-1.1.20.orig/dbus/dbus-sysdeps-unix.c	2008-03-19 12:08:32 +0100
+++ dbus-1.1.20/dbus/dbus-sysdeps-unix.c	2008-03-19 11:49:28 +0100
@@ -55,6 +55,10 @@
 #include <netdb.h>
 #include <grp.h>
 
+#if defined(__INTERIX)
+# include <arpa/inet.h>
+#endif
+
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -750,9 +754,12 @@
                           const char     *family,
                           DBusError      *error)
 {
+
   int fd = -1, res;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -764,6 +771,7 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR(error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -816,6 +824,60 @@
       break;
     }
   freeaddrinfo(ai);
+#else
+  {
+      char **cur;
+      struct hostent* h;
+      int fam = AF_UNSPEC;
+
+      if((h = gethostbyname(host)) == NULL)
+      {
+        dbus_set_error(error, _dbus_error_from_errno (errno),
+               "Failed to get host information for \"%s\"", host);
+        return -1;
+      }
+
+      if(family) {
+        if(strcmp(family, "ipv4") == 0)
+          fam = AF_INET;
+        else
+        {
+          dbus_set_error (error,
+                          _dbus_error_from_errno (errno),
+                          "Unknown address family %s", family);
+          return -1;
+        }
+      }
+
+      cur = h->h_addr_list;
+
+      while(*cur)
+      {
+          struct sockaddr_in s;
+
+          s.sin_family = fam;
+          s.sin_port = htons(atoi(port));
+          inet_aton(*cur, &s.sin_addr);
+
+          if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+          {
+            _DBUS_ASSERT_ERROR_IS_SET(error);
+            return -1;
+          }
+          _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+          if (connect (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+          {
+            _dbus_close(fd, NULL);
+            fd = -1;
+
+            ++cur;
+            continue;
+          }
+          break;
+      }
+  }
+#endif
 
   if (fd == -1)
     {
@@ -861,12 +923,15 @@
                          DBusError      *error)
 {
   int nlisten_fd = 0, *listen_fd = NULL, res, i;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#endif
 
   *fds_p = NULL;
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -996,6 +1061,92 @@
     }
   freeaddrinfo(ai);
   ai = NULL;
+#else
+  {
+    char **cur;
+    struct hostent* h;
+    int fam = AF_UNSPEC;
+
+    if((h = gethostbyname(host)) == NULL)
+    {
+      dbus_set_error(error, _dbus_error_from_errno (errno),
+             "Failed to get host information for \"%s\"", host);
+      return -1;
+    }
+
+    if(family) {
+      if(strcmp(family, "ipv4") == 0)
+        fam = AF_INET;
+      else
+      {
+        dbus_set_error (error,
+                        _dbus_error_from_errno (errno),
+                        "Unknown address family %s", family);
+        return -1;
+      }
+    }
+
+    cur = h->h_addr_list;
+
+    while(*cur)
+    {
+      int fd = -1, *newlisten_fd;
+      struct sockaddr_in s;
+
+      s.sin_family = fam;
+      s.sin_port = htons(atoi(port));
+      inet_aton(*cur, &s.sin_addr);
+
+      if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+        {
+          _DBUS_ASSERT_ERROR_IS_SET(error);
+          goto failed;
+        }
+      _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+      if (bind (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+        {
+          _dbus_close(fd, NULL);
+          if (errno == EADDRINUSE)
+            {
+              /* Depending on kernel policy, it may or may not
+                 be neccessary to bind to both IPv4 & 6 addresses
+                 so ignore EADDRINUSE here */
+              ++cur;
+              continue;
+            }
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to bind socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      if (listen (fd, 30 /* backlog */) < 0)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to listen on socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      newlisten_fd = dbus_realloc(listen_fd, sizeof(int)*(nlisten_fd+1));
+      if (!newlisten_fd)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to allocate file handle array: %s",
+                          _dbus_strerror (errno));
+          goto failed;
+        }
+      listen_fd = newlisten_fd;
+      listen_fd[nlisten_fd] = fd;
+      nlisten_fd++;
+
+      ++cur;
+    }
+  }
+#endif
 
   if (!nlisten_fd)
     {
@@ -1019,8 +1170,10 @@
   return nlisten_fd;
 
  failed:
+#ifndef __INTERIX
   if (ai)
     freeaddrinfo(ai);
+#endif
   for (i = 0 ; i < nlisten_fd ; i++)
     _dbus_close(listen_fd[i], NULL);
   dbus_free(listen_fd);
