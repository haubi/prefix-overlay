--- dbus-1.4.0.orig/dbus/dbus-sysdeps-unix.c
+++ dbus-1.4.0/dbus/dbus-sysdeps-unix.c
@@ -56,6 +56,10 @@
 #include <netdb.h>
 #include <grp.h>
 
+#if defined(__INTERIX)
+# include <arpa/inet.h>
+#endif
+
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -1158,8 +1162,10 @@ _dbus_connect_tcp_socket_with_nonce (con
 {
   int saved_errno = 0;
   int fd = -1, res;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1171,6 +1177,7 @@ _dbus_connect_tcp_socket_with_nonce (con
 
   _DBUS_ASSERT_ERROR_IS_CLEAR(error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -1223,6 +1230,60 @@ _dbus_connect_tcp_socket_with_nonce (con
       break;
     }
   freeaddrinfo(ai);
+#else
+  {
+      char **cur;
+      struct hostent* h;
+      int fam = AF_UNSPEC;
+
+      if((h = gethostbyname(host)) == NULL)
+      {
+        dbus_set_error(error, _dbus_error_from_errno (errno),
+               "Failed to get host information for \"%s\"", host);
+        return -1;
+      }
+
+      if(family) {
+        if(strcmp(family, "ipv4") == 0)
+          fam = AF_INET;
+        else
+        {
+          dbus_set_error (error,
+                          _dbus_error_from_errno (errno),
+                          "Unknown address family %s", family);
+          return -1;
+        }
+      }
+
+      cur = h->h_addr_list;
+
+      while(*cur)
+      {
+          struct sockaddr_in s;
+
+          s.sin_family = fam;
+          s.sin_port = htons(atoi(port));
+          inet_aton(*cur, &s.sin_addr);
+
+          if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+          {
+            _DBUS_ASSERT_ERROR_IS_SET(error);
+            return -1;
+          }
+          _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+          if (connect (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+          {
+            _dbus_close(fd, NULL);
+            fd = -1;
+
+            ++cur;
+            continue;
+          }
+          break;
+      }
+  }
+#endif
 
   if (fd == -1)
     {
@@ -1283,13 +1344,16 @@ _dbus_listen_tcp_socket (const char
 {
   int saved_errno;
   int nlisten_fd = 0, *listen_fd = NULL, res, i;
+#ifndef __INTERIX
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
   unsigned int reuseaddr;
+#endif
 
   *fds_p = NULL;
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
+#ifndef __INTERIX
   _DBUS_ZERO (hints);
 
   if (!family)
@@ -1429,6 +1493,92 @@ _dbus_listen_tcp_socket (const char
     }
   freeaddrinfo(ai);
   ai = NULL;
+#else
+  {
+    char **cur;
+    struct hostent* h;
+    int fam = AF_UNSPEC;
+
+    if((h = gethostbyname(host)) == NULL)
+    {
+      dbus_set_error(error, _dbus_error_from_errno (errno),
+             "Failed to get host information for \"%s\"", host);
+      return -1;
+    }
+
+    if(family) {
+      if(strcmp(family, "ipv4") == 0)
+        fam = AF_INET;
+      else
+      {
+        dbus_set_error (error,
+                        _dbus_error_from_errno (errno),
+                        "Unknown address family %s", family);
+        return -1;
+      }
+    }
+
+    cur = h->h_addr_list;
+
+    while(*cur)
+    {
+      int fd = -1, *newlisten_fd;
+      struct sockaddr_in s;
+
+      s.sin_family = fam;
+      s.sin_port = htons(atoi(port));
+      inet_aton(*cur, &s.sin_addr);
+
+      if (!_dbus_open_socket (&fd, fam, SOCK_STREAM, 0, error))
+        {
+          _DBUS_ASSERT_ERROR_IS_SET(error);
+          goto failed;
+        }
+      _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+      if (bind (fd, (struct sockaddr*)&s, sizeof(s)) < 0)
+        {
+          _dbus_close(fd, NULL);
+          if (errno == EADDRINUSE)
+            {
+              /* Depending on kernel policy, it may or may not
+                 be neccessary to bind to both IPv4 & 6 addresses
+                 so ignore EADDRINUSE here */
+              ++cur;
+              continue;
+            }
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to bind socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      if (listen (fd, 30 /* backlog */) < 0)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to listen on socket \"%s:%s\": %s",
+                          host ? host : "*", port, _dbus_strerror (errno));
+          goto failed;
+        }
+
+      newlisten_fd = dbus_realloc(listen_fd, sizeof(int)*(nlisten_fd+1));
+      if (!newlisten_fd)
+        {
+          _dbus_close (fd, NULL);
+          dbus_set_error (error, _dbus_error_from_errno (errno),
+                          "Failed to allocate file handle array: %s",
+                          _dbus_strerror (errno));
+          goto failed;
+        }
+      listen_fd = newlisten_fd;
+      listen_fd[nlisten_fd] = fd;
+      nlisten_fd++;
+
+      ++cur;
+    }
+  }
+#endif
 
   if (!nlisten_fd)
     {
@@ -1452,8 +1602,10 @@ _dbus_listen_tcp_socket (const char
   return nlisten_fd;
 
  failed:
+#ifndef __INTERIX
   if (ai)
     freeaddrinfo(ai);
+#endif
   for (i = 0 ; i < nlisten_fd ; i++)
     _dbus_close(listen_fd[i], NULL);
   dbus_free(listen_fd);
