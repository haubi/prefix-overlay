reported upstream: https://bugs.freedesktop.org/show_bug.cgi?id=38334

diff -ru dbus-1.4.8.orig/bus/activation-helper.c dbus-1.4.8/bus/activation-helper.c
--- dbus-1.4.8.orig/bus/activation-helper.c	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/bus/activation-helper.c	2011-06-15 09:32:35 +0200
@@ -322,12 +322,14 @@
     }
 
   /* initialize the group access list */
+#ifdef HAVE_INITGROUPS
   if (initgroups (user, pw->pw_gid))
     {
       dbus_set_error (error, DBUS_ERROR_SPAWN_SETUP_FAILED,
                       "could not initialize groups");
       return FALSE;
     }
+#endif /* HAVE_INITGROUPS */
 
   /* change to the primary group for the user */
   if (setgid (pw->pw_gid))
diff -ru dbus-1.4.8.orig/configure.ac dbus-1.4.8/configure.ac
--- dbus-1.4.8.orig/configure.ac	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/configure.ac	2011-06-15 09:32:35 +0200
@@ -460,6 +460,8 @@
 AC_CHECK_FUNC(gethostbyname,,[AC_CHECK_LIB(nsl,gethostbyname)])
 
 AC_CHECK_FUNCS(vsnprintf vasprintf nanosleep usleep setenv clearenv unsetenv socketpair getgrouplist fpathconf setrlimit poll setlocale localeconv strtoll strtoull)
+AC_CHECK_FUNCS(getaddrinfo getnameinfo recvmsg initgroups setgroups)
+AC_CHECK_TYPE([struct sockaddr_storage])
 
 #### Check for broken poll; taken from Glib's configure
 
@@ -1020,6 +1022,10 @@
    AC_MSG_RESULT(no)
 fi
 
+# on interix, unix fd passing is not working reliably.
+case $host_os in
+*-interix*) ;;
+*)
 # Check for SCM_RIGHTS
 AC_MSG_CHECKING([for SCM_RIGHTS])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
@@ -1030,6 +1036,8 @@
 [ AC_MSG_RESULT([supported])
   AC_DEFINE([HAVE_UNIX_FD_PASSING], [1], [Supports sending UNIX file descriptors]) ],
 [ AC_MSG_RESULT([not supported]) ])
+;;
+esac
 
 NETWORK_libs=
 if test x$dbus_win = xyes ; then
diff -ru dbus-1.4.8.orig/dbus/dbus-server-unix.c dbus-1.4.8/dbus/dbus-server-unix.c
--- dbus-1.4.8.orig/dbus/dbus-server-unix.c	2011-06-15 09:39:32 +0200
+++ dbus-1.4.8/dbus/dbus-server-unix.c	2011-06-15 10:11:35 +0200
@@ -31,6 +31,11 @@
 #include "dbus-sysdeps-unix.h"
 #include "dbus-string.h"
 
+#ifdef __INTERIX
+/* for INTERIX_MAJOR */
+#include <suacomp.h>
+#endif
+
 /**
  * @defgroup DBusServerUnix DBusServer implementations for UNIX
  * @ingroup  DBusInternals
@@ -102,9 +107,19 @@
               return DBUS_SERVER_LISTEN_DID_NOT_CONNECT;
             }
 
+#if defined(__INTERIX) && (INTERIX_MAJOR == 5)
+          /* interix 5.2 quirks: for _some_ dumb reason, UNIX sockets
+           * are limited to a 14 char path. when building dbus, you
+           * better specify --with-*-socket-dir=/tmp/, which is assumed
+           * here! */
+          if (!_dbus_string_append (&filename,
+                                    "ds-") ||
+              !_dbus_generate_random_ascii (&filename, 9 - strlen(tmpdir)) ||
+#else /* !__INTERIX (5) */
           if (!_dbus_string_append (&filename,
                                     "dbus-") ||
               !_dbus_generate_random_ascii (&filename, 10) ||
+#endif /* !__INTERIX (5) */
               !_dbus_string_append (&full_path, tmpdir) ||
               !_dbus_concat_dir_and_file (&full_path, &filename))
             {
diff -ru dbus-1.4.8.orig/dbus/dbus-sysdeps-unix.c dbus-1.4.8/dbus/dbus-sysdeps-unix.c
--- dbus-1.4.8.orig/dbus/dbus-sysdeps-unix.c	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/dbus/dbus-sysdeps-unix.c	2011-06-15 09:32:35 +0200
@@ -55,6 +55,7 @@
 #include <netinet/in.h>
 #include <netdb.h>
 #include <grp.h>
+#include <arpa/inet.h>
 
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
@@ -90,6 +91,10 @@
 #define socklen_t int
 #endif
 
+#ifndef HAVE_SOCKADDR_STORAGE
+#define sockaddr_storage sockaddr
+#endif
+
 static dbus_bool_t
 _dbus_open_socket (int              *fd_p,
                    int               domain,
@@ -1158,8 +1163,6 @@
 {
   int saved_errno = 0;
   int fd = -1, res;
-  struct addrinfo hints;
-  struct addrinfo *ai, *tmp;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1171,14 +1174,20 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR(error);
 
+#ifdef HAVE_GETADDRINFO
+  {
+  struct addrinfo hints;
+  struct addrinfo *ai, *tmp;
   _DBUS_ZERO (hints);
 
   if (!family)
     hints.ai_family = AF_UNSPEC;
   else if (!strcmp(family, "ipv4"))
     hints.ai_family = AF_INET;
+#ifdef AF_INET6
   else if (!strcmp(family, "ipv6"))
     hints.ai_family = AF_INET6;
+#endif
   else
     {
       dbus_set_error (error,
@@ -1223,6 +1232,70 @@
       break;
     }
   freeaddrinfo(ai);
+  }
+#else /* HAVE_GETADDRINFO */
+  {
+    struct hostent* _h;
+    struct sockaddr_in _s;
+    struct in_addr** _c;
+
+    if((_h = gethostbyname(host)) == NULL)
+      {
+        dbus_set_error (error,
+                        _dbus_error_from_errno (errno),
+                        "Failed to lookup host/port: \"%s:%s\"",
+                        host, port);
+        return -1;
+      }
+
+    if (!family)
+#ifdef AF_INET6
+      _s.sin_family = AF_UNSPEC;
+#else
+      _s.sin_family = AF_INET;
+#endif
+    else if (!strcmp(family, "ipv4"))
+      _s.sin_family = AF_INET;
+#ifdef AF_INET6
+    else if (!strcmp(family, "ipv6"))
+      _s.sin_family = AF_INET6;
+#endif /* AF_INET6 */
+    else
+      {
+        dbus_set_error (error,
+                        DBUS_ERROR_BAD_ADDRESS,
+                        "Unknown address family %s", family);
+        return -1;
+      }
+
+    _s.sin_port = htons(atoi(port));
+
+    _c = (struct in_addr**)_h->h_addr_list;
+    
+    while(*_c)
+      {
+        _s.sin_addr = *(*_c);
+        if (!_dbus_open_socket (&fd, _s.sin_family, SOCK_STREAM, 0, error))
+          {
+            _DBUS_ASSERT_ERROR_IS_SET(error);
+            return -1;
+          }
+        _DBUS_ASSERT_ERROR_IS_CLEAR(error);
+
+        if (connect (fd, (struct sockaddr*) &_s, sizeof(_s)) < 0)
+          {
+            saved_errno = errno;
+            _dbus_close(fd, NULL);
+            fd = -1;
+
+            ++_c;
+            continue;
+          }
+
+        break;
+      }
+  }
+#endif /* !HAVE_GETADDRINFO */
 
   if (fd == -1)
     {
@@ -1283,21 +1356,30 @@
 {
   int saved_errno;
   int nlisten_fd = 0, *listen_fd = NULL, res, i;
+#ifdef HAVE_GETADDRINFO
   struct addrinfo hints;
   struct addrinfo *ai, *tmp;
+#else
+  struct hostent* _h;
+  struct sockaddr_in _s;
+  struct in_addr** _c;
+#endif
   unsigned int reuseaddr;
 
   *fds_p = NULL;
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
+#ifdef HAVE_GETADDRINFO
   _DBUS_ZERO (hints);
 
   if (!family)
     hints.ai_family = AF_UNSPEC;
   else if (!strcmp(family, "ipv4"))
     hints.ai_family = AF_INET;
+#ifdef AF_INET6
   else if (!strcmp(family, "ipv6"))
     hints.ai_family = AF_INET6;
+#endif
   else
     {
       dbus_set_error (error,
@@ -1323,8 +1405,52 @@
   tmp = ai;
   while (tmp)
     {
+#else /* HAVE_GETADDRINFO */
+
+    if((_h = gethostbyname(host)) == NULL)
+      {
+        dbus_set_error (error,
+                        _dbus_error_from_errno (errno),
+                        "Failed to lookup host/port: \"%s:%s\"",
+                        host, port);
+        return -1;
+      }
+
+    if (!family)
+#ifdef AF_INET6
+      _s.sin_family = AF_UNSPEC;
+#else
+      _s.sin_family = AF_INET;
+#endif
+    else if (!strcmp(family, "ipv4"))
+      _s.sin_family = AF_INET;
+#ifdef AF_INET6
+    else if (!strcmp(family, "ipv6"))
+      _s.sin_family = AF_INET6;
+#endif /* AF_INET6 */
+    else
+      {
+        dbus_set_error (error,
+                        DBUS_ERROR_BAD_ADDRESS,
+                        "Unknown address family %s", family);
+        return -1;
+      }
+
+ redo_lookup_with_port:
+    _s.sin_port = htons(atoi(port));
+
+    _c = (struct in_addr**)_h->h_addr_list;
+    
+    while(*_c)
+      {
+#endif /* !HAVE_GETADDRINFO */
       int fd = -1, *newlisten_fd;
+#ifdef HAVE_GETADDRINFO
       if (!_dbus_open_socket (&fd, tmp->ai_family, SOCK_STREAM, 0, error))
+#else
+      _s.sin_addr = *(*_c);
+      if (!_dbus_open_socket (&fd, _s.sin_family, SOCK_STREAM, 0, error))
+#endif
         {
           _DBUS_ASSERT_ERROR_IS_SET(error);
           goto failed;
@@ -1338,7 +1464,11 @@
                       host ? host : "*", port, _dbus_strerror (errno));
         }
 
+#ifdef HAVE_GETADDRINFO
       if (bind (fd, (struct sockaddr*) tmp->ai_addr, tmp->ai_addrlen) < 0)
+#else
+      if (bind (fd, (struct sockaddr*) &_s, sizeof(_s)) < 0)
+#endif
         {
           saved_errno = errno;
           _dbus_close(fd, NULL);
@@ -1347,7 +1477,11 @@
               /* Depending on kernel policy, it may or may not
                  be neccessary to bind to both IPv4 & 6 addresses
                  so ignore EADDRINUSE here */
+#ifdef HAVE_GETADDRINFO
               tmp = tmp->ai_next;
+#else
+              ++_c;
+#endif
               continue;
             }
           dbus_set_error (error, _dbus_error_from_errno (saved_errno),
@@ -1396,14 +1530,23 @@
               addrlen = sizeof(addr);
               result = getsockname(fd, (struct sockaddr*) &addr, &addrlen);
 
-              if (result == -1 ||
-                  (res = getnameinfo ((struct sockaddr*)&addr, addrlen, NULL, 0,
+              if (result == -1 
+#ifdef HAVE_GETNAMEINFO
+				  || (res = getnameinfo ((struct sockaddr*)&addr, addrlen, NULL, 0,
                                       portbuf, sizeof(portbuf),
-                                      NI_NUMERICHOST)) != 0)
+                                      NI_NUMERICHOST)) != 0
+#endif
+									  )
                 {
+#ifdef HAVE_GETADDRINFO
                   dbus_set_error (error, _dbus_error_from_errno (errno),
                                   "Failed to resolve port \"%s:%s\": %s (%s)",
                                   host ? host : "*", port, gai_strerror(res), res);
+#else
+                  dbus_set_error (error, _dbus_error_from_errno (errno),
+                                  "Failed to resolve port \"%s:%s\"",
+                                  host ? host : "*", port);
+#endif
                   goto failed;
                 }
               if (!_dbus_string_append(retport, portbuf))
@@ -1414,7 +1557,9 @@
 
               /* Release current address list & redo lookup */
               port = _dbus_string_get_const_data(retport);
+#ifdef HAVE_GETADDRINFO
               freeaddrinfo(ai);
+#endif
               goto redo_lookup_with_port;
             }
           else
@@ -1426,11 +1571,15 @@
                 }
             }
         }
-
+#ifdef HAVE_GETADDRINFO
       tmp = tmp->ai_next;
     }
   freeaddrinfo(ai);
   ai = NULL;
+#else
+      ++_c;
+    }
+#endif
 
   if (!nlisten_fd)
     {
@@ -1454,8 +1603,10 @@
   return nlisten_fd;
 
  failed:
+#ifdef HAVE_GETADDRINFO
   if (ai)
     freeaddrinfo(ai);
+#endif
   for (i = 0 ; i < nlisten_fd ; i++)
     _dbus_close(listen_fd[i], NULL);
   dbus_free(listen_fd);
@@ -1494,6 +1645,21 @@
 
  again:
 
+#ifdef __INTERIX
+  /* interix seems to have problems wrt SIGPIPE
+   * in some cases here. it looks like the signal
+   * happening much faster than on other systems. */
+  {
+    struct sigaction old_sa, new_sa;
+    int sa_status;
+    new_sa.sa_handler = SIG_IGN;
+    new_sa.sa_mask = 0;
+    new_sa.sa_flags = 0;
+
+    if((sa_status = sigaction(SIGPIPE, &new_sa, &old_sa)) < 0)
+      _dbus_warn("failed to ignore SIGPIPE.\n");
+#endif /* __INTERIX */
+
 #if defined(HAVE_CMSGCRED)
   bytes_written = sendmsg (server_fd, &msg, 0
 #if HAVE_DECL_MSG_NOSIGNAL
@@ -1508,6 +1674,12 @@
                         );
 #endif
 
+#ifdef __INTERIX
+    if(sa_status >= 0)
+      sigaction(SIGPIPE, &old_sa, NULL);
+  }
+#endif /* __INTERIX */
+
   if (bytes_written < 0 && errno == EINTR)
     goto again;
 
@@ -1558,12 +1730,13 @@
                                 DBusCredentials *credentials,
                                 DBusError       *error)
 {
-  struct msghdr msg;
   struct iovec iov;
   char buf;
-  dbus_uid_t uid_read;
-  dbus_pid_t pid_read;
+  dbus_uid_t uid_read = DBUS_UID_UNSET;
+  dbus_pid_t pid_read = DBUS_PID_UNSET;
   int bytes_read;
+#ifdef HAVE_RECVMSG
+  struct msghdr msg;
 
 #ifdef HAVE_CMSGCRED
   union {
@@ -1577,9 +1750,7 @@
     struct sockcred cred;
   } cmsg;
 #endif
-
-  uid_read = DBUS_UID_UNSET;
-  pid_read = DBUS_PID_UNSET;
+#endif /* HAVE_RECVMSG */
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1599,6 +1770,7 @@
    * credentials information without doing anything special.
    */
 
+#ifdef HAVE_RECVMSG
   iov.iov_base = &buf;
   iov.iov_len = 1;
 
@@ -1614,6 +1786,10 @@
 
  again:
   bytes_read = recvmsg (client_fd, &msg, 0);
+#else /* HAVE_RECVMSG */
+ again:
+  bytes_read = read(client_fd, &buf, 0);
+#endif /* HAVE_RECVMSG */
 
   if (bytes_read < 0)
     {
@@ -1745,6 +1921,9 @@
       }
     if (ucred != NULL)
       ucred_free (ucred);
+#elif defined(__INTERIX)
+    /* fake it on interix for now. */
+    _dbus_credentials_add_from_current_process(credentials);
 #else /* !SO_PEERCRED && !HAVE_CMSGCRED && !HAVE_GETPEEREID && !HAVE_GETPEERUCRED */
     _dbus_verbose ("Socket credentials not supported on this OS\n");
 #endif
@@ -3832,7 +4011,7 @@
 dbus_bool_t
 _dbus_socket_can_pass_unix_fd(int fd) {
 
-#ifdef SCM_RIGHTS
+#ifdef HAVE_UNIX_FD_PASSING
   union {
     struct sockaddr sa;
     struct sockaddr_storage storage;
diff -ru dbus-1.4.8.orig/dbus/dbus-sysdeps-util-unix.c dbus-1.4.8/dbus/dbus-sysdeps-util-unix.c
--- dbus-1.4.8.orig/dbus/dbus-sysdeps-util-unix.c	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/dbus/dbus-sysdeps-util-unix.c	2011-06-15 09:32:35 +0200
@@ -338,6 +338,7 @@
       return FALSE;
     }
 
+#ifdef HAVE_SETGROUPS
   /* setgroups() only works if we are a privileged process,
    * so we don't return error on failure; the only possible
    * failure is that we don't have perms to do it.
@@ -348,6 +349,7 @@
   if (setgroups (0, NULL) < 0)
     _dbus_warn ("Failed to drop supplementary groups: %s\n",
                 _dbus_strerror (errno));
+#endif /* HAVE_SETGROUPS */
 
   /* Set GID first, or the setuid may remove our permission
    * to change the GID
diff -ru dbus-1.4.8.orig/dbus/dbus-sysdeps.h dbus-1.4.8/dbus/dbus-sysdeps.h
--- dbus-1.4.8.orig/dbus/dbus-sysdeps.h	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/dbus/dbus-sysdeps.h	2011-06-15 09:32:35 +0200
@@ -274,6 +274,19 @@
 #define _DBUS_POLLHUP     0x0080
 /** Invalid request: fd not open */
 #define _DBUS_POLLNVAL    0x1000
+#elif defined(__INTERIX)
+/** There is data to read */
+#define _DBUS_POLLIN      0x0001
+/** Writing now will not block */
+#define _DBUS_POLLOUT     0x0010
+/** Error condition */
+#define _DBUS_POLLERR     0x0040
+/** There is urgent data to read */
+#define _DBUS_POLLPRI     0x0008
+/** Hung up */
+#define _DBUS_POLLHUP     0x0080
+/** Invalid request: fd not open */
+#define _DBUS_POLLNVAL    0x0100
 #else
 /** There is data to read */
 #define _DBUS_POLLIN      0x0001
diff -ru dbus-1.4.8.orig/dbus/sd-daemon.c dbus-1.4.8/dbus/sd-daemon.c
--- dbus-1.4.8.orig/dbus/sd-daemon.c	2011-06-15 09:54:49 +0200
+++ dbus-1.4.8/dbus/sd-daemon.c	2011-06-15 09:32:35 +0200
@@ -40,9 +40,14 @@
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <arpa/inet.h>
 
 #include "sd-daemon.h"
 
+#ifndef HAVE_SOCKADDR_STORAGE
+#define sockaddr_storage sockaddr
+#endif
+
 int sd_listen_fds(int unset_environment) {
 
 #if defined(DISABLE_SYSTEMD) || !defined(__linux__)
@@ -203,7 +208,9 @@
 union sockaddr_union {
         struct sockaddr sa;
         struct sockaddr_in in4;
+#ifdef AF_INET6
         struct sockaddr_in6 in6;
+#endif
         struct sockaddr_un un;
         struct sockaddr_storage storage;
 };
@@ -241,7 +248,11 @@
         socklen_t l;
         int r;
 
-        if (family != 0 && family != AF_INET && family != AF_INET6)
+        if (family != 0 && family != AF_INET 
+#ifdef AF_INET6
+          && family != AF_INET6
+#endif
+          )
                 return -EINVAL;
 
         if ((r = sd_is_socket_internal(fd, type, listening)) <= 0)
@@ -256,8 +267,11 @@
         if (l < sizeof(sa_family_t))
                 return -EINVAL;
 
-        if (sockaddr.sa.sa_family != AF_INET &&
-            sockaddr.sa.sa_family != AF_INET6)
+        if (sockaddr.sa.sa_family != AF_INET 
+#ifdef AF_INET6
+          && sockaddr.sa.sa_family != AF_INET6
+#endif
+          )
                 return 0;
 
         if (family > 0)
@@ -270,11 +284,13 @@
                                 return -EINVAL;
 
                         return htons(port) == sockaddr.in4.sin_port;
+#ifdef AF_INET6
                 } else {
                         if (l < sizeof(struct sockaddr_in6))
                                 return -EINVAL;
 
                         return htons(port) == sockaddr.in6.sin6_port;
+#endif
                 }
         }
 
