diff -ru parity-1.1.0.orig/parity.configurator/Configurator.cpp parity-1.1.0/parity.configurator/Configurator.cpp
--- parity-1.1.0.orig/parity.configurator/Configurator.cpp	2008-08-29 13:57:06 +0200
+++ parity-1.1.0/parity.configurator/Configurator.cpp	2008-08-29 14:31:58 +0200
@@ -317,6 +317,7 @@
 	case LanguageCpp:
 		target << "C++";
 		break;
+	case LanguageUnknown:
 	case LanguageInvalid:
 		target << "none";
 		break;
diff -ru parity-1.1.0.orig/parity.gnu.gcc/parity.gnu.gcc.cpp parity-1.1.0/parity.gnu.gcc/parity.gnu.gcc.cpp
--- parity-1.1.0.orig/parity.gnu.gcc/parity.gnu.gcc.cpp	2008-08-29 13:57:06 +0200
+++ parity-1.1.0/parity.gnu.gcc/parity.gnu.gcc.cpp	2008-08-29 14:31:58 +0200
@@ -87,7 +87,26 @@
 	context.setFrontendType(utils::ToolchainInterixGNU);
 
 	try {
-		parity::options::CommandLine::process(argc - 1, &argv[1], parity::options::OptionTableGnuGcc, 0);
+		parity::options::UnknownArgumentVector unknown;
+		parity::options::CommandLine::process(argc - 1, &argv[1], parity::options::OptionTableGnuGcc, &unknown);
+
+		for(parity::options::UnknownArgumentVector::iterator it = unknown.begin(); it != unknown.end(); ++it) {
+			parity::utils::Path pth(*it);
+			pth.toNative();
+
+			if(pth.exists()) {
+				if(context.getPreprocess() || context.getCompileOnly()) {
+					// assume source file for all unknown things...
+					Log::verbose("assuming source: %s\n", pth.get().c_str());
+					context.setSourcesString(pth.get());
+				} else {
+					Log::verbose("assuming object: %s\n", pth.get().c_str());
+					context.setObjectsLibrariesString(pth.get());
+				}
+			} else {
+				Log::verbose("ignoring unknonw argument: %s\n", it->c_str());
+			}
+		}
 	} catch(const Exception& e) {
 		Log::error("while processing command line: %s\n", e.what());
 		exit(1);
diff -ru parity-1.1.0.orig/parity.gnu.ld/parity.gnu.ld.cpp parity-1.1.0/parity.gnu.ld/parity.gnu.ld.cpp
--- parity-1.1.0.orig/parity.gnu.ld/parity.gnu.ld.cpp	2008-08-29 13:57:06 +0200
+++ parity-1.1.0/parity.gnu.ld/parity.gnu.ld.cpp	2008-08-29 14:31:58 +0200
@@ -87,7 +87,20 @@
 	context.setFrontendType(utils::ToolchainInterixGNU);
 
 	try {
-		parity::options::CommandLine::process(argc - 1, &argv[1], parity::options::OptionTableGnuLd, 0);
+		parity::options::UnknownArgumentVector unknown;
+		parity::options::CommandLine::process(argc - 1, &argv[1], parity::options::OptionTableGnuLd, &unknown);
+
+		for(parity::options::UnknownArgumentVector::iterator it = unknown.begin(); it != unknown.end(); ++it) {
+			parity::utils::Path pth(*it);
+			pth.toNative();
+
+			if(pth.exists()) {
+				Log::verbose("assuming object: %s\n", pth.get().c_str());
+				context.setObjectsLibrariesString(pth.get());
+			} else {
+				Log::verbose("ignoring unknonw argument: %s\n", it->c_str());
+			}
+		}
 	} catch(const Exception& e) {
 		Log::error("while processing command line: %s\n", e.what());
 		exit(1);
diff -ru parity-1.1.0.orig/parity.tasks/CollectorOther.cpp parity-1.1.0/parity.tasks/CollectorOther.cpp
--- parity-1.1.0.orig/parity.tasks/CollectorOther.cpp	2008-08-29 13:57:08 +0200
+++ parity-1.1.0/parity.tasks/CollectorOther.cpp	2008-08-29 14:31:58 +0200
@@ -249,20 +249,20 @@
 					utils::Log::error("error executing compiler!\n");
 					exit(1);
 				}
+			}
 
-				if(context.getCompileOnly())
-				{
-					utils::Log::verbose("only compilation requested, exiting.\n");
-					threading.synchronize();
-					exit(0);
-				}
+			if(context.getCompileOnly())
+			{
+				utils::Log::verbose("only compilation requested, exiting.\n");
+				threading.synchronize();
+				exit(0);
+			}
 
-				if(context.getPreprocess())
-				{
-					utils::Log::verbose("only preprocessing requested, exiting.\n");
-					threading.synchronize();
-					exit(0);
-				}
+			if(context.getPreprocess())
+			{
+				utils::Log::verbose("only preprocessing requested, exiting.\n");
+				threading.synchronize();
+				exit(0);
 			}
 		}
 
diff -ru parity-1.1.0.orig/parity.tasks/MsCompiler.cpp parity-1.1.0/parity.tasks/MsCompiler.cpp
--- parity-1.1.0.orig/parity.tasks/MsCompiler.cpp	2008-08-29 13:57:08 +0200
+++ parity-1.1.0/parity.tasks/MsCompiler.cpp	2008-08-29 14:31:58 +0200
@@ -56,6 +56,7 @@
 					break;
 				case utils::LanguageC:
 				case utils::LanguageCpp:
+				case utils::LanguageUnknown:
 					processCOrCppFile(specialized);
 					compileGeneric(native, ctx.getCompilerExe(), specialized);
 					break;
@@ -237,6 +238,10 @@
 			case utils::LanguageCpp:
 				vec.push_back("/Tp" + file.get());
 				break;
+			case utils::LanguageUnknown:
+				// let the compiler decide here...
+				vec.push_back(file.get());
+				break;
 			default:
 				throw utils::Exception("unknown language type, or language not supported by backend!");
 			}
@@ -256,6 +261,7 @@
 				break;
 			case utils::LanguageC:
 			case utils::LanguageCpp:
+			case utils::LanguageUnknown:
 				{
 					utils::Task::ArgumentVector temp;
 					vectorize(ctx.getCompilerDefaults(), temp);
diff -ru parity-1.1.0.orig/parity.utils/ContextGen.cpp parity-1.1.0/parity.utils/ContextGen.cpp
--- parity-1.1.0.orig/parity.utils/ContextGen.cpp	2008-08-29 13:57:08 +0200
+++ parity-1.1.0/parity.utils/ContextGen.cpp	2008-08-29 14:31:58 +0200
@@ -211,8 +211,9 @@
 					Log::warning("ignoring forced language for assembler, continuing normally!\n");
 				Log::verbose("adding assembler source file: %s\n", ref.c_str());
 				target[ref] = LanguageAsssembler;
-			} else
-				throw utils::Exception("cannot determine type of source file: %s\n", ref.c_str());
+			} else {
+				target[ref] = LanguageUnknown;
+			}
 		}
 
 		std::string ContextGen::printable(const long& val)
@@ -345,6 +346,7 @@
 				return "C";
 			case LanguageCpp:
 				return "C++";
+			case LanguageUnknown:
 			case LanguageInvalid:
 				return "None";
 			default:
diff -ru parity-1.1.0.orig/parity.utils/ContextGen.h parity-1.1.0/parity.utils/ContextGen.h
--- parity-1.1.0.orig/parity.utils/ContextGen.h	2008-08-29 13:57:08 +0200
+++ parity-1.1.0/parity.utils/ContextGen.h	2008-08-29 14:31:58 +0200
@@ -73,6 +73,7 @@
 
 		typedef enum {
 			LanguageInvalid = -1,
+			LanguageUnknown,
 			LanguageC,
 			LanguageCpp,
 			LanguageAsssembler
