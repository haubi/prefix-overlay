Solaris needs lots of help to compile this due to missing stuff.

diff -ur icecc-0.9.1.orig/configure.in icecc-0.9.1/configure.in
--- icecc-0.9.1.orig/configure.in	2008-06-19 10:04:16.000000000 +0200
+++ icecc-0.9.1/configure.in	2008-09-15 21:08:40.004623282 +0200
@@ -34,7 +34,7 @@
 # Some of these are needed by popt (or other libraries included in the future).
 
 AC_CHECK_HEADERS([unistd.h stdint.h signal.h sys/types.h sys/signal.h ifaddrs.h kinfo.h sys/param.h devstat.h])
-AC_CHECK_HEADERS([ctype.h sys/resource.h sys/socket.h sys/stat.h sys/select.h sys/vfs.h])
+AC_CHECK_HEADERS([ctype.h sys/resource.h sys/socket.h sys/stat.h sys/select.h sys/vfs.h sys/statvfs.h sys/loadavg.h])
 AC_CHECK_HEADERS([mach/host_info.h])
 AC_CHECK_HEADERS([netinet/in.h], [], [],
 [#if HAVE_SYS_TYPES_H
@@ -57,12 +57,17 @@
 # include <arpa/nameser.h>
 #endif
 ])
+AC_CHECK_HEADERS([netinet/tcp_timer.h])
+AC_CHECK_HEADERS([netinet/tcp_var.h], [], [],
+[#if HAVE_NETINET_TCP_TIMER_H
+# include <netinet/tcp_timer.h>
+#endif
+])
 
 AC_ARG_VAR(TAR, [Specifies tar path])
 AC_PATH_PROG(TAR, [tar])
 AC_DEFINE_UNQUOTED([TAR], ["$TAR"], [Define path to tar])
-AC_CHECK_HEADERS([float.h mcheck.h alloca.h sys/mman.h netinet/tcp_var.h])
-AC_CHECK_HEADERS([sys/user.h])
+AC_CHECK_HEADERS([float.h mcheck.h alloca.h sys/mman.h sys/user.h])
 
 ######################################################################
 dnl Checks for types
@@ -94,6 +99,9 @@
 ########################################################################
 ### Checks for libraries.
 
+# check for daemon function before adding -lsocket and -lnsl for Solaris
+AC_CHECK_FUNCS([daemon statvfs])
+
 # The following test taken from the cvs sources via Samba:
 # If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
 # The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
diff -ur icecc-0.9.1.orig/daemon/load.cpp icecc-0.9.1/daemon/load.cpp
--- icecc-0.9.1.orig/daemon/load.cpp	2008-05-12 19:51:46.000000000 +0200
+++ icecc-0.9.1/daemon/load.cpp	2008-09-15 21:09:46.675550013 +0200
@@ -31,7 +31,7 @@
 
 #ifdef HAVE_MACH_HOST_INFO_H
 #define USE_MACH 1
-#elif !defined( __linux__ ) && !defined(__CYGWIN__)
+#elif !defined( __linux__ ) && !defined(__CYGWIN__) && !defined(__sun__)
 #define USE_SYSCTL
 #endif
 
@@ -51,6 +51,10 @@
 #include <devstat.h>
 #endif
 
+#ifdef HAVE_SYS_LOADAVG_H
+#include <sys/loadavg.h>
+#endif
+
 using namespace std;
 
 struct CPULoadInfo
diff -ur icecc-0.9.1.orig/daemon/main.cpp icecc-0.9.1/daemon/main.cpp
--- icecc-0.9.1.orig/daemon/main.cpp	2008-05-12 19:51:46.000000000 +0200
+++ icecc-0.9.1/daemon/main.cpp	2008-09-15 21:18:28.152999289 +0200
@@ -59,6 +59,9 @@
 #ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
+#ifdef HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
 
 #include <arpa/inet.h>
 
@@ -617,8 +620,13 @@
             msg.load = 1000;
 
 #ifdef HAVE_SYS_VFS_H
+#ifdef HAVE_STATVFS
+        struct statvfs buf;
+        int ret = statvfs(envbasedir.c_str(), &buf);
+#else
         struct statfs buf;
         int ret = statfs(envbasedir.c_str(), &buf);
+#endif
         if (!ret && buf.f_bavail < (max_kids + 1 - current_kids) * 4 * 1024 * 1024 / buf.f_bsize)
             msg.load = 1000;
 #endif
@@ -1613,10 +1621,17 @@
     chdir( "/" );
 
     if ( detach )
+#ifdef HAVE_DAEMON
         if (daemon(0, 0)) {
             log_perror("daemon()");
             exit (EXIT_DISTCC_FAILED);
         }
+#else
+		{
+			log_warning() << "daemon(3) function not available, should implement with fork" << endl;
+			exit( EXIT_DISTCC_FAILED );
+		}
+#endif
 
     if (dcc_ncpus(&d.num_cpus) == 0)
         log_info() << d.num_cpus << " CPU(s) online on this server" << endl;
diff -ur icecc-0.9.1.orig/daemon/workit.cpp icecc-0.9.1/daemon/workit.cpp
--- icecc-0.9.1.orig/daemon/workit.cpp	2008-05-12 19:51:46.000000000 +0200
+++ icecc-0.9.1/daemon/workit.cpp	2008-09-15 21:08:40.006701182 +0200
@@ -37,6 +37,8 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <sys/fcntl.h>
+#include <fcntl.h>
+#include <signal.h>
 #include <sys/wait.h>
 #if HAVE_SYS_USER_H && !defined(__DragonFly__)
 #  include <sys/user.h>
diff -ur icecc-0.9.1.orig/services/comm.cpp icecc-0.9.1/services/comm.cpp
--- icecc-0.9.1.orig/services/comm.cpp	2008-05-12 19:52:37.000000000 +0200
+++ icecc-0.9.1/services/comm.cpp	2008-09-15 21:08:40.007389504 +0200
@@ -30,10 +30,16 @@
 #include <sys/select.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
+#if HAVE_NETINET_TCP_TIMER_H
+#include <netinet/tcp_timer.h>
+#endif
 #if HAVE_NETINET_TCP_VAR_H
 #include <sys/socketvar.h>
 #include <netinet/tcp_var.h>
 #endif
+#ifndef MSG_NOSIGNAL
+#include <signal.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <netdb.h>
@@ -725,24 +731,23 @@
   int on = 1;
   if (!setsockopt (_fd, SOL_SOCKET, SO_KEEPALIVE, (char*) &on, sizeof(on)))
   {
-#if defined( TCP_KEEPIDLE )
-      int keepidle = TCP_KEEPIDLE;
-#else
-      int keepidle = TCPCTL_KEEPIDLE;
-#endif
-
       int sec;
-      sec = MAX_SCHEDULER_PING - 3 * MAX_SCHEDULER_PONG;
-      setsockopt (_fd, IPPROTO_TCP, keepidle, (char*) &sec, sizeof(sec));
 
-#if defined( TCP_KEEPINTVL )
-      int keepintvl = TCP_KEEPINTVL;
-#else
-      int keepintvl = TCPCTL_KEEPINTVL;
+	  /* note: Solaris has no equivalents to TCP_KEEPIDLE and TCP_KEEPINTVL */
+
+      sec = MAX_SCHEDULER_PING - 3 * MAX_SCHEDULER_PONG;
+#if defined( TCP_KEEPIDLE )
+      setsockopt (_fd, IPPROTO_TCP, TCP_KEEPIDLE, (char*) &sec, sizeof(sec));
+#elif defined( TCPCTL_KEEPIDLE )
+      setsockopt (_fd, IPPROTO_TCP, TCPCTL_KEEPIDLE, (char*) &sec, sizeof(sec));
 #endif
 
       sec = MAX_SCHEDULER_PONG;
-      setsockopt (_fd, IPPROTO_TCP, keepintvl, (char*) &sec, sizeof(sec));
+#if defined( TCP_KEEPINTVL )
+      setsockopt (_fd, IPPROTO_TCP, TCP_KEEPINTVL, (char*) &sec, sizeof(sec));
+#elif defined( TCPCTL_KEEPINTVL )
+      setsockopt (_fd, IPPROTO_TCP, TCPCTL_KEEPINTVL, (char*) &sec, sizeof(sec));
+#endif
 
 #ifdef TCP_KEEPCNT
       sec = 3;
Only in icecc-0.9.1/services: comm.cpp.orig
diff -ur icecc-0.9.1.orig/services/scheduler.cpp icecc-0.9.1/services/scheduler.cpp
--- icecc-0.9.1.orig/services/scheduler.cpp	2008-05-12 19:52:18.000000000 +0200
+++ icecc-0.9.1/services/scheduler.cpp	2008-09-15 21:16:28.512349387 +0200
@@ -32,6 +32,7 @@
 #include <arpa/inet.h>
 #include <sys/select.h>
 #include <sys/signal.h>
+#include <signal.h>
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -137,7 +138,7 @@
 class Job;
 
 /* One compile server (receiver, compile daemon)  */
-class CS : public MsgChannel
+class IceCS : public MsgChannel
 {
 public:
   /* The listener port, on which it takes compile requests.  */
@@ -157,7 +158,7 @@
   bool noremote;
   list<Job*> joblist;
   Environments compiler_versions;  // Available compilers
-  CS (int fd, struct sockaddr *_addr, socklen_t _len, bool text_based)
+  IceCS (int fd, struct sockaddr *_addr, socklen_t _len, bool text_based)
     : MsgChannel(fd, _addr, _len, text_based),
       load(1000), max_jobs(0), noremote(false),
       state(CONNECTED), type(UNKNOWN), chroot_possible(false)
@@ -183,9 +184,9 @@
   bool check_remote( const Job *job ) const;
 };
 
-unsigned int CS::hostid_counter = 0;
+unsigned int IceCS::hostid_counter = 0;
 
-static map<int, CS *> fd2cs;
+static map<int, IceCS *> fd2cs;
 static bool exit_main_loop = false;
 
 time_t starttime;
@@ -196,8 +197,8 @@
   unsigned int id;
   unsigned int local_client_id;
   enum {PENDING, WAITINGFORCS, COMPILING, WAITINGFORDONE} state;
-  CS *server;  // on which server we build
-  CS *submitter;  // who submitted us
+  IceCS *server;  // on which server we build
+  IceCS *submitter;  // who submitted us
   Environments environments;
   time_t starttime;  // _local_ to the compiler server
   time_t start_on_scheduler;  // starttime local to scheduler
@@ -215,7 +216,7 @@
   unsigned int arg_flags;
   string language; // for debugging
   string preferred_host; // for debugging daemons
-  Job (unsigned int _id, CS *subm)
+  Job (unsigned int _id, IceCS *subm)
     : id(_id), local_client_id( 0 ), state(PENDING), server(0),
       submitter(subm),
       starttime(0), start_on_scheduler(0), done_time( 0 ), arg_flags( 0 ) {}
@@ -228,7 +229,7 @@
 };
 
 // A subset of connected_hosts representing the compiler servers
-static list<CS*> css, monitors, controls;
+static list<IceCS*> css, monitors, controls;
 static list<string> block_css;
 static unsigned int new_job_id;
 static map<unsigned int, Job*> jobs;
@@ -238,7 +239,7 @@
 struct UnansweredList
 {
   list<Job*> l;
-  CS *server;
+  IceCS *server;
   bool remove_job (Job *);
 };
 static list<UnansweredList*> toanswer;
@@ -246,7 +247,7 @@
 static list<JobStat> all_job_stats;
 static JobStat cum_job_stats;
 
-static float server_speed (CS *cs, Job *job = 0);
+static float server_speed (IceCS *cs, Job *job = 0);
 
 /* Searches the queue for JOB and removes it.
    Returns true if something was deleted.  */
@@ -346,12 +347,12 @@
 
 }
 
-static bool handle_end (CS *c, Msg *);
+static bool handle_end (IceCS *c, Msg *);
 
 static void
 notify_monitors (Msg* m)
 {
-  list<CS*>::iterator it, it_old;
+  list<IceCS*>::iterator it, it_old;
   for (it = monitors.begin(); it != monitors.end();)
     {
       it_old = it++;
@@ -365,7 +366,7 @@
 }
 
 static float
-server_speed (CS *cs, Job *job)
+server_speed (IceCS *cs, Job *job)
 {
   if (cs->last_compiled_jobs.size() == 0
       || cs->cum_compiled.compile_time_user == 0)
@@ -396,7 +397,7 @@
 }
 
 static void
-handle_monitor_stats( CS *cs, StatsMsg *m = 0)
+handle_monitor_stats( IceCS *cs, StatsMsg *m = 0)
 {
   if ( monitors.empty() )
     return;
@@ -437,7 +438,7 @@
 }
 
 static Job *
-create_new_job (CS *submitter)
+create_new_job (IceCS *submitter)
 {
   ++new_job_id;
   assert (jobs.find(new_job_id) == jobs.end());
@@ -502,7 +503,7 @@
   if (!m)
     return false;
 
-  CS *submitter = static_cast<CS*>( c );
+  IceCS *submitter = static_cast<IceCS*>( c );
 
   Job *master_job = 0;
 
@@ -543,7 +544,7 @@
 }
 
 static bool
-handle_local_job (CS *c, Msg *_m)
+handle_local_job (IceCS *c, Msg *_m)
 {
   JobLocalBeginMsg *m = dynamic_cast<JobLocalBeginMsg *>(_m);
   if (!m)
@@ -557,7 +558,7 @@
 }
 
 static bool
-handle_local_job_done (CS *c, Msg *_m)
+handle_local_job_done (IceCS *c, Msg *_m)
 {
   JobLocalDoneMsg *m = dynamic_cast<JobLocalDoneMsg *>(_m);
   if (!m)
@@ -611,20 +612,20 @@
   return false;
 }
 
-/* Given a candidate CS and a JOB, check all installed environments
-   on the CS for a match.  Return an empty string if none of the required
+/* Given a candidate IceCS and a JOB, check all installed environments
+   on the IceCS for a match.  Return an empty string if none of the required
    environments for this job is installed.  Otherwise return the
    host platform of the first found installed environment which is among
    the requested.  That can be send to the client, which then completely
    specifies which environment to use (name, host platform and target
    platform).  */
 static string
-envs_match( CS* cs, const Job *job )
+envs_match( IceCS* cs, const Job *job )
 {
   if ( job->submitter == cs)
     return cs->host_platform; // it will compile itself
 
-  /* Check all installed envs on the candidate CS ...  */
+  /* Check all installed envs on the candidate IceCS ...  */
   for ( Environments::const_iterator it = cs->compiler_versions.begin(); it != cs->compiler_versions.end(); ++it )
     {
       if ( it->first == job->target_platform )
@@ -633,7 +634,7 @@
 	     the requested target platform.  Now look at each env which
 	     could be installed from the client (i.e. those coming with the
 	     job) if it matches in name and additionally could be run
-	     by the candidate CS.  */
+	     by the candidate IceCS.  */
           for ( Environments::const_iterator it2 = job->environments.begin(); it2 != job->environments.end(); ++it2 )
             {
               if ( it->second == it2->second && platforms_compatible( it2->first, cs->host_platform ) )
@@ -644,14 +645,14 @@
   return string();
 }
 
-/* Given a candidate CS and a JOB, check if any of the requested
-   environments could be installed on the CS.  This is the case if that
-   env can be run there, i.e. if the host platforms of the CS and of the
+/* Given a candidate IceCS and a JOB, check if any of the requested
+   environments could be installed on the IceCS.  This is the case if that
+   env can be run there, i.e. if the host platforms of the IceCS and of the
    environment are compatible.  Return an empty string if none can be
    installed, otherwise return the platform of the first found
    environments which can be installed.  */
 static string
-can_install( CS* cs, const Job *job )
+can_install( IceCS* cs, const Job *job )
 {
   // trace() << "can_install host: '" << cs->host_platform << "' target: '" << job->target_platform << "'" << endl;
   if ( cs->busy_installing )
@@ -670,13 +671,13 @@
   return string();
 }
 
-bool CS::check_remote( const Job *job ) const
+bool IceCS::check_remote( const Job *job ) const
 {
     bool local = (job->submitter == this);
     return local || !noremote;
 }
 
-bool CS::is_eligible( const Job *job )
+bool IceCS::is_eligible( const Job *job )
 {
   bool jobs_okay = int( joblist.size() ) < max_jobs;
   bool load_okay = load < 1000;
@@ -687,10 +688,10 @@
     && this->check_remote( job );
 }
 
-static CS *
+static IceCS *
 pick_server(Job *job)
 {
-  list<CS*>::iterator it;
+  list<IceCS*>::iterator it;
 
 #if DEBUG_SCHEDULER > 1
   trace() << "pick_server " << job->id << " " << job->target_platform << endl;
@@ -698,9 +699,9 @@
 
 #if DEBUG_SCHEDULER > 0
   /* consistency checking for now */
-  for (list<CS*>::iterator it = css.begin(); it != css.end(); ++it)
+  for (list<IceCS*>::iterator it = css.begin(); it != css.end(); ++it)
     {
-      CS* cs= *it;
+      IceCS* cs= *it;
       for ( list<Job*>::const_iterator it2 = cs->joblist.begin(); it2 != cs->joblist.end(); ++it2 )
         {
           Job *job = *it2;
@@ -712,7 +713,7 @@
     {
       Job *j = it->second;
 
-      CS *cs = j->server;
+      IceCS *cs = j->server;
       assert( j->state != j->COMPILING ||
               find( cs->joblist.begin(),
                     cs->joblist.end(), j ) != cs->joblist.end() );
@@ -759,17 +760,17 @@
       /* Otherwise simply average over all jobs.  */
       guess = cum_job_stats / all_job_stats.size();
     }
-  CS *best = 0;
+  IceCS *best = 0;
   // best uninstalled
-  CS *bestui = 0;
+  IceCS *bestui = 0;
   // best preloadable host
-  CS *bestpre = 0;
+  IceCS *bestpre = 0;
 
   uint matches = 0;
 
   for (it = css.begin(); it != css.end(); ++it)
     {
-      CS *cs = *it;
+      IceCS *cs = *it;
       /* For now ignore overloaded servers.  */
       /* Pre-loadable (cs->joblist.size()) == (cs->max_jobs) is checked later.  */
       if (int( cs->joblist.size() ) > cs->max_jobs || cs->load >= 1000)
@@ -900,7 +901,7 @@
 static time_t
 prune_servers ()
 {
-  list<CS*>::iterator it;
+  list<IceCS*>::iterator it;
 
   time_t now = time( 0 );
   time_t min_time = MAX_SCHEDULER_PING;
@@ -909,7 +910,7 @@
     {
       if (now - ( *it )->last_talk >= MAX_SCHEDULER_PING) 
         {
-	  CS *old = *it;
+	  IceCS *old = *it;
           ++it;
 	  handle_end (old, 0);
 	  continue;
@@ -924,7 +925,7 @@
                                      MAX_BUSY_INSTALLING))
         {
 	  trace() << "busy installing for a long time - removing " << ( *it )->nodename << endl;
-	  CS *old = *it;
+	  IceCS *old = *it;
 	  ++it;
 	  handle_end (old, 0);
 	  continue;
@@ -954,7 +955,7 @@
 	    }
 	  // R.I.P.
 	  trace() << "removing " << ( *it )->nodename << endl;
-	  CS *old = *it;
+	  IceCS *old = *it;
 	  ++it;
 	  handle_end (old, 0);
 	  continue;
@@ -965,7 +966,7 @@
       if ((random() % 400) < 0)
         { // R.I.P.
           trace() << "FORCED removing " << ( *it )->nodename << endl;
-          CS *old = *it;
+          IceCS *old = *it;
           ++it;
           handle_end (old, 0);
           continue;
@@ -1001,7 +1002,7 @@
   assert(!css.empty());
 
   Job *first_job = job;
-  CS *cs = 0;
+  IceCS *cs = 0;
 
   while ( true )
     {
@@ -1108,7 +1109,7 @@
 }
 
 static bool
-handle_login (CS *cs, Msg *_m)
+handle_login (IceCS *cs, Msg *_m)
 {
   LoginMsg *m = dynamic_cast<LoginMsg *>(_m);
   if (!m)
@@ -1136,11 +1137,11 @@
   handle_monitor_stats( cs );
 
   /* remove any other clients with the same IP, they must be stale */
-  for (list<CS*>::iterator it = css.begin(); it != css.end(); )
+  for (list<IceCS*>::iterator it = css.begin(); it != css.end(); )
     {
       if (cs->eq_ip(*(*it)))
       {
-        CS* old = *it;
+        IceCS* old = *it;
         ++it;
         handle_end(old, 0);
         continue;
@@ -1172,7 +1173,7 @@
   if (!m)
     return false;
 
-  CS *cs = static_cast<CS *>(c);
+  IceCS *cs = static_cast<IceCS *>(c);
   cs->compiler_versions = m->envs;
   cs->busy_installing = 0;
 
@@ -1191,7 +1192,7 @@
 }
 
 static bool
-handle_mon_login (CS *c, Msg *_m)
+handle_mon_login (IceCS *c, Msg *_m)
 {
   MonLoginMsg *m = dynamic_cast<MonLoginMsg *>(_m);
   if (!m)
@@ -1200,7 +1201,7 @@
   // monitors really want to be fed lazily
   c->setBulkTransfer();
 
-  for (list<CS*>::const_iterator it = css.begin(); it != css.end(); ++it)
+  for (list<IceCS*>::const_iterator it = css.begin(); it != css.end(); ++it)
     handle_monitor_stats( *it );
 
   fd2cs.erase( c->fd ); // no expected data from them
@@ -1208,7 +1209,7 @@
 }
 
 static bool
-handle_job_begin (CS *c, Msg *_m)
+handle_job_begin (IceCS *c, Msg *_m)
 {
   JobBeginMsg *m = dynamic_cast<JobBeginMsg *>(_m);
   if ( !m )
@@ -1240,7 +1241,7 @@
 
 
 static bool
-handle_job_done (CS *c, Msg *_m)
+handle_job_done (IceCS *c, Msg *_m)
 {
   JobDoneMsg *m = dynamic_cast<JobDoneMsg *>(_m);
   if ( !m )
@@ -1367,7 +1368,7 @@
 }
 
 static bool
-handle_ping (CS* c, Msg * /*_m*/)
+handle_ping (IceCS* c, Msg * /*_m*/)
 {
   c->last_talk = time( 0 );
   if ( c->max_jobs < 0 )
@@ -1376,7 +1377,7 @@
 }
 
 static bool
-handle_stats (CS * c, Msg * _m)
+handle_stats (IceCS * c, Msg * _m)
 {
   StatsMsg *m = dynamic_cast<StatsMsg *>(_m);
   if (!m)
@@ -1391,7 +1392,7 @@
         c->max_jobs *= -1;
     }
 
-  for (list<CS*>::iterator it = css.begin(); it != css.end(); ++it)
+  for (list<IceCS*>::iterator it = css.begin(); it != css.end(); ++it)
     if ( *it == c )
       {
         ( *it )->load = m->load;
@@ -1444,12 +1445,12 @@
 }
 
 static bool
-handle_control_login(CS* c)
+handle_control_login(IceCS* c)
 {
-    c->type = CS::LINE;
+    c->type = IceCS::LINE;
     c->last_talk = time (0);
     c->setBulkTransfer();
-    c->state = CS::LOGGEDIN;
+    c->state = IceCS::LOGGEDIN;
     assert(find(controls.begin(), controls.end(), c) == controls.end());
     controls.push_back(c);
 
@@ -1464,7 +1465,7 @@
 }
 
 static bool
-handle_line (CS *c, Msg *_m)
+handle_line (IceCS *c, Msg *_m)
 {
   TextMsg *m = dynamic_cast<TextMsg *>(_m);
   if (!m)
@@ -1488,9 +1489,9 @@
     }
   if (cmd == "listcs")
     {
-      for (list<CS*>::iterator it = css.begin(); it != css.end(); ++it)
+      for (list<IceCS*>::iterator it = css.begin(); it != css.end(); ++it)
 	{
-	  CS* cs= *it;
+	  IceCS* cs= *it;
 	  sprintf (buffer, " (%s:%d) ", cs->name.c_str(), cs->remote_port);
 	  line = " " + cs->nodename + buffer;
 	  line += "[" + cs->host_platform + "] speed=";
@@ -1535,7 +1536,7 @@
       }
       else
         for (list<string>::const_iterator si = l.begin(); si != l.end(); ++si)
-	  for (list<CS*>::iterator it = css.begin(); it != css.end(); ++it)
+	  for (list<IceCS*>::iterator it = css.begin(); it != css.end(); ++it)
 	    if ((*it)->nodename == *si || (*it)->name == *si)
 	      {
                 if (cmd == "blockcs")
@@ -1551,7 +1552,7 @@
     }
   else if (cmd == "internals" )
     {
-      for (list<CS*>::iterator it = css.begin(); it != css.end(); ++it)
+      for (list<IceCS*>::iterator it = css.begin(); it != css.end(); ++it)
         {
           Msg *msg = NULL;
 
@@ -1598,17 +1599,17 @@
 
 // return false if some error occured, leaves C open.  */
 static bool
-try_login (CS *c, Msg *m)
+try_login (IceCS *c, Msg *m)
 {
   bool ret = true;
   switch (m->type)
     {
     case M_LOGIN:
-      c->type = CS::DAEMON;
+      c->type = IceCS::DAEMON;
       ret = handle_login (c, m);
       break;
     case M_MON_LOGIN:
-      c->type = CS::MONITOR;
+      c->type = IceCS::MONITOR;
       ret = handle_mon_login (c, m);
       break;
     default:
@@ -1617,7 +1618,7 @@
       break;
     }
   if (ret)
-    c->state = CS::LOGGEDIN;
+    c->state = IceCS::LOGGEDIN;
   else
     handle_end (c, m);
 
@@ -1626,7 +1627,7 @@
 }
 
 static bool
-handle_end (CS *toremove, Msg *m)
+handle_end (IceCS *toremove, Msg *m)
 {
 #if DEBUG_SCHEDULER > 1
   trace() << "Handle_end " << toremove << " " << m << endl;
@@ -1635,7 +1636,7 @@
 #endif
 
   switch (toremove->type) {
-  case CS::MONITOR:
+  case IceCS::MONITOR:
     {
       assert (find (monitors.begin(), monitors.end(), toremove) != monitors.end());
       monitors.remove (toremove);
@@ -1644,7 +1645,7 @@
 #endif
     }
     break;
-  case CS::DAEMON:
+  case IceCS::DAEMON:
     {
       log_info() << "remove daemon " << toremove->nodename << endl;
 
@@ -1704,7 +1705,7 @@
         }
     }
     break;
-  case CS::LINE:
+  case IceCS::LINE:
     {
       if (!toremove->send_msg (TextMsg ("200 Good Bye!"))) {
       }
@@ -1724,7 +1725,7 @@
 
 /* Returns TRUE if C was not closed.  */
 static bool
-handle_activity (CS *c)
+handle_activity (IceCS *c)
 {
   Msg *m;
   bool ret = true;
@@ -1735,7 +1736,7 @@
       return false;
     }
   /* First we need to login.  */
-  if (c->state == CS::CONNECTED)
+  if (c->state == IceCS::CONNECTED)
     return try_login (c, m);
 
   switch (m->type)
@@ -1939,7 +1940,15 @@
 
   setup_debug( debug_level, logfile );
   if ( detach )
+#if HAVE_DAEMON
     daemon( 0, 0 );
+#else
+	{
+      log_warning() << "daemon(3) function not available, should implement with fork" << endl;
+      return 1;
+	}
+#endif
+
 
   listen_fd = open_tcp_listener (port);
   if (listen_fd < 0)
@@ -1996,10 +2005,10 @@
       if (broad_fd > max_fd)
         max_fd = broad_fd;
       FD_SET (broad_fd, &read_set);
-      for (map<int, CS*>::const_iterator it = fd2cs.begin(); it != fd2cs.end();)
+      for (map<int, IceCS*>::const_iterator it = fd2cs.begin(); it != fd2cs.end();)
         {
           int i = it->first;
-          CS *c = it->second;
+          IceCS *c = it->second;
           bool ok = true;
           ++it;
           /* handle_activity() can delete c and make the iterator
@@ -2044,7 +2053,7 @@
                 }
               if (remote_fd >= 0)
                 {
-                  CS *cs = new CS (remote_fd, (struct sockaddr*) &remote_addr, remote_len, false);
+                  IceCS *cs = new IceCS (remote_fd, (struct sockaddr*) &remote_addr, remote_len, false);
                   trace() << "accepted " << cs->name << endl;
                   cs->last_talk = time( 0 );
 
@@ -2076,7 +2085,7 @@
 	    }
 	  if (remote_fd >= 0)
 	    {
-	      CS *cs = new CS (remote_fd, (struct sockaddr*) &remote_addr, remote_len, true);
+	      IceCS *cs = new IceCS (remote_fd, (struct sockaddr*) &remote_addr, remote_len, true);
 	      fd2cs[cs->fd] = cs;
               if (!handle_control_login(cs))
                 {
@@ -2123,11 +2132,11 @@
 		}
 	    }
 	}
-      for (map<int, CS*>::const_iterator it = fd2cs.begin();
+      for (map<int, IceCS*>::const_iterator it = fd2cs.begin();
            max_fd && it != fd2cs.end();)
         {
           int i = it->first;
-          CS *c = it->second;
+          IceCS *c = it->second;
           /* handle_activity can delete the channel from the fd2cs list,
              hence advance the iterator right now, so it doesn't become
              invalid.  */
Only in icecc-0.9.1: solaris.patch
