diff -ruNbB binutils-2.17/bfd/archive.c binutils-2.17.sua/bfd/archive.c
--- binutils-2.17/bfd/archive.c	2005-10-05 23:24:23 +0200
+++ binutils-2.17.sua/bfd/archive.c	2008-04-01 09:03:06 +0200
@@ -409,8 +409,11 @@
     {
       filename = get_extended_arelt_filename (abfd, hdr.ar_name);
       if (filename == NULL)
+    	{
+		bfd_set_error (bfd_error_malformed_archive);
 	return NULL;
     }
+    }
   /* BSD4.4-style long filename.
      Only implemented for reading, so far!  */
   else if (hdr.ar_name[0] == '#'
@@ -1841,11 +1841,18 @@
 		  flagword flags = (syms[src_count])->flags;
 		  asection *sec = syms[src_count]->section;
 
-		  if ((flags & BSF_GLOBAL ||
-		       flags & BSF_WEAK ||
+		  /* For ordinary simbols, we only want real definitions; 
+		     however, for weak symbols, it may be an indirection
+		     to a symbol defined in another file, and thus be 
+		     undefined (in the undefined section) here.  But 
+		     we need it defined in the archive symbol table so we 
+		     can get the module and resolve the indirection. */
+
+		  if (((flags & BSF_GLOBAL ||
 		       flags & BSF_INDIRECT ||
 		       bfd_is_com_section (sec))
 		      && ! bfd_is_und_section (sec))
+			|| flags & BSF_WEAK)	  
 		    {
 		      bfd_size_type namelen;
 		      struct orl *new_map;
diff -ruNbB binutils-2.17/bfd/archures.c binutils-2.17.sua/bfd/archures.c
--- binutils-2.17/bfd/archures.c	2006-03-06 14:42:03 +0100
+++ binutils-2.17.sua/bfd/archures.c	2008-04-01 09:03:06 +0200
@@ -25,6 +25,16 @@
 #include "libbfd.h"
 #include "safe-ctype.h"
 
+#if 1
+/*
+ * FIXME
+ * mayank@14th June, 2007
+ * There is a suspected bug here in SUA due to which the declarations 
+ * of strcasecmp are not detected by configure. 
+ */
+extern int       __cdecl strcasecmp (const char *, const char *);
+extern int       __cdecl strncasecmp (const char *, const char *, size_t);
+#endif
 /*
 
 SECTION
diff -ruNbB binutils-2.17/bfd/bfd-in.h binutils-2.17.sua/bfd/bfd-in.h
--- binutils-2.17/bfd/bfd-in.h	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/bfd-in.h	2008-04-01 09:03:06 +0200
@@ -239,6 +239,10 @@
    to any input file.  */
 #define BFD_LINKER_CREATED 0x2000
 
+/* This flag indicates that the BFD has the NO-LINK flag set */
+#define NO_LINK 0x2000
+
+
 /* Symbols and relocation.  */
 
 /* A count of carsyms (canonical archive symbols).  */
@@ -301,6 +305,19 @@
 #define	align_power(addr, align)	\
   (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
 
+#if 1
+/*
+ * FIXME
+ * mayank@14th June, 2007
+ * I dont think this macro makes sense. Check out section.c 
+ * and peicode.h
+ */
+#define bfd_get_section_size_before_reloc(section) \
+     ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
+                            : (section)->rawsize)
+#endif
+
+
 typedef struct bfd_section *sec_ptr;
 
 #define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
@@ -326,6 +343,24 @@
   (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
    / bfd_octets_per_byte (bfd))
 
+/* For the moment these functions are required only for flag bits beyond
+   the first 32, but it's set up so that all programs can convert to use
+   these over time.  (Hopefully, by the time that another word is needed,
+   the flag word can be converted to a simple array, but now, for backwards
+   compatability, we do it this ugly way.) */
+   
+#define bfd_section_flag_value(bfd,sec,flag) \
+    ((((flag)/32==0 ? (sec)->flags           \
+		    : (sec)->more_flags[((flag)/32)-1]) & (1<<((flag)%32))) != 0)
+
+#define bfd_set_section_flag_value(bfd,sec,flag)             \
+    ((flag)/32==0 ? ((sec)->flags |=  (1 << ((flag)%32)))    \
+		  : ((sec)->more_flags[((flag)/32)-1] |=  (1 << ((flag)%32))))
+
+#define bfd_clear_section_flag_value(bfd,sec,flag)           \
+    ((flag)/32==0 ? ((sec)->flags &= ~(1 << ((flag)%32)))    \
+		  : ((sec)->more_flags[((flag)/32)-1] &= ~(1 << ((flag)%32))))
+
 typedef struct stat stat_type;
 
 typedef enum bfd_print_symbol
@@ -741,6 +776,12 @@
 extern bfd_boolean bfd_sparclinux_size_dynamic_sections
   (bfd *, struct bfd_link_info *);
 
+/* PE/COFF shared library support routines for the linker.  */
+extern bfd_boolean bfd_coff_size_dynamic_sections
+  PARAMS ((bfd *, const char *, const char *, const char *,
+	   const char * const *, struct bfd_link_info *, struct bfd_section **,
+	   struct bfd_elf_version_tree *));
+
 /* mmap hacks */
 
 struct _bfd_window_internal;
diff -ruNbB binutils-2.17/bfd/bfd-in2.h binutils-2.17.sua/bfd/bfd-in2.h
--- binutils-2.17/bfd/bfd-in2.h	2006-03-26 01:38:42 +0100
+++ binutils-2.17.sua/bfd/bfd-in2.h	2008-04-01 09:03:06 +0200
@@ -246,6 +246,10 @@
    to any input file.  */
 #define BFD_LINKER_CREATED 0x2000
 
+/* This flag indicates that the BFD has the NO-LINK flag set */
+#define NO_LINK 0x2000
+
+
 /* Symbols and relocation.  */
 
 /* A count of carsyms (canonical archive symbols).  */
@@ -333,6 +339,24 @@
   (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
    / bfd_octets_per_byte (bfd))
 
+/* For the moment these functions are required only for flag bits beyond
+   the first 32, but it's set up so that all programs can convert to use
+   these over time.  (Hopefully, by the time that another word is needed,
+   the flag word can be converted to a simple array, but now, for backwards
+   compatability, we do it this ugly way.) */
+   
+#define bfd_section_flag_value(bfd,sec,flag) \
+    ((((flag)/32==0 ? (sec)->flags           \
+		    : (sec)->more_flags[((flag)/32)-1]) & (1<<((flag)%32))) != 0)
+
+#define bfd_set_section_flag_value(bfd,sec,flag)             \
+    ((flag)/32==0 ? ((sec)->flags |=  (1 << ((flag)%32)))    \
+		  : ((sec)->more_flags[((flag)/32)-1] |=  (1 << ((flag)%32))))
+
+#define bfd_clear_section_flag_value(bfd,sec,flag)           \
+    ((flag)/32==0 ? ((sec)->flags &= ~(1 << ((flag)%32)))    \
+		  : ((sec)->more_flags[((flag)/32)-1] &= ~(1 << ((flag)%32))))
+
 typedef struct stat stat_type;
 
 typedef enum bfd_print_symbol
@@ -748,6 +772,12 @@
 extern bfd_boolean bfd_sparclinux_size_dynamic_sections
   (bfd *, struct bfd_link_info *);
 
+/* PE/COFF shared library support routines for the linker.  */
+extern bfd_boolean bfd_coff_size_dynamic_sections
+  PARAMS ((bfd *, const char *, const char *, const char *,
+	   const char * const *, struct bfd_link_info *, struct bfd_section **,
+	   struct bfd_elf_version_tree *));
+
 /* mmap hacks */
 
 struct _bfd_window_internal;
@@ -1072,6 +1102,43 @@
 
 long bfd_get_size (bfd *abfd);
 
+/* This enum exists so that transition to an abstraction can start;
+   use with bfd_{get_,set_,}section_value_flag. */
+enum section_sec_flags {
+       sec_flag_ALLOC,
+       sec_flag_LOAD,
+       sec_flag_RELOC,
+       sec_flag_ARCH_BIT_0,
+       sec_flag_READONLY,
+       sec_flag_CODE,
+       sec_flag_DATA,
+       sec_flag_ROM,
+       sec_flag_CONSTRUCTOR,
+       sec_flag_HAS_CONTENTS,
+       sec_flag_NEVER_LOAD,
+       sec_flag_COFF_SHARED_LIBRARY,
+       sec_flag_reserved1, sec_flag_reserved2, /* for constructor types */
+       sec_flag_HAS_GOT_REF,
+       sec_flag_IS_COMMON,
+       sec_flag_DEBUGGING,
+       sec_flag_IN_MEMORY,
+       sec_flag_EXCLUDE,
+       sec_flag_SORT_ENTRIES,
+       sec_flag_LINK_ONCE,
+       sec_flag_reserved3,sec_flag_reserved4, /* for comdat types */
+       sec_flag_LINKER_CREATED,
+       sec_flag_KEEP,
+       sec_flag_SMALL_DATA,
+       sec_flag_SHARED,
+       sec_flag_BLOCK,
+       sec_flag_CLINK,
+       sec_flag_MERGE,
+       sec_flag_STRINGS,
+       sec_flag_GROUP,
+       sec_flag_NOREAD,
+      sec_flag_last  /* The traditional "last" value */
+};
+
 /* Extracted from bfdwin.c.  */
 /* Extracted from section.c.  */
 typedef struct bfd_section
@@ -1096,6 +1163,8 @@
      flags are read in from the object file, and some are
      synthesized from other information.  */
   flagword flags;
+  flagword more_flags[1];
+
 
 #define SEC_NO_FLAGS   0x000
 
@@ -1383,6 +1452,23 @@
   /* File position of line data.  */
   file_ptr line_filepos;
 
+/* #ifdef DYNAMIC_LINKING */
+  /* Certain sections need counts, which we overload into the
+     coff number of relocs and/or number of line numbers fields,
+     but carrying those in the same fields here is asking for 
+     trouble, so the overloaded ones live here. */
+
+  unsigned int info_r;
+  unsigned int info_l;
+
+  /* There are multiple string tables possible when dynamically
+     linking; this is the section number for the string table
+     for this section */
+
+  int link_index;
+
+/* #endif */
+
   /* Pointer to data for applications.  */
   void *userdata;
 
@@ -1399,6 +1485,9 @@
   /* Entity size for merging purposes.  */
   unsigned int entsize;
 
+  /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
+  struct coff_comdat_info *comdat;
+
   /* Points to the kept section if this section is a link-once section,
      and is discarded.  */
   struct bfd_section *kept_section;
@@ -1470,6 +1559,14 @@
 extern const struct bfd_symbol * const bfd_und_symbol;
 extern const struct bfd_symbol * const bfd_ind_symbol;
 
+#define bfd_get_section_size_before_reloc(section) \
+     ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
+                            : (section)->rawsize)
+#define bfd_get_section_size_after_reloc(section) \
+     ((section)->reloc_done ? (section)->size \
+                            : (abort (), (bfd_size_type) 1))
+
+
 /* Macros to handle insertion and deletion of a bfd's sections.  These
    only handle the list pointers, ie. do not adjust section_count,
    target_index etc.  */
@@ -1656,6 +1753,9 @@
 bfd_boolean bfd_copy_private_section_data
    (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
 
+void _bfd_strip_section_from_output
+   (struct bfd_link_info *info, asection *section);
+
 #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
      BFD_SEND (obfd, _bfd_copy_private_section_data, \
                (ibfd, isection, obfd, osection))
@@ -4447,6 +4547,13 @@
      be used only for archive elements.  */
   int archive_pass;
 
+/* #ifdef DYNAMIC_LINKING */
+    /* Used by some backends for dynamic link private data; independent
+       of per-format private data. */
+    struct dynamic_info *dynamic_info;  /* used by shared libs only */
+    bfd_vma *local_got_offsets; /* used if dynamic linking on all bfds */
+/* #endif */
+
   /* Used by the back end to hold private data.  */
   union
     {
@@ -4538,6 +4645,8 @@
 
 bfd_error_handler_type bfd_get_error_handler (void);
 
+const char *bfd_archive_filename (bfd *);
+
 long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
 
 long bfd_canonicalize_reloc
@@ -4668,6 +4777,9 @@
   (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
    bfd_boolean, asymbol **);
 
+/* In case we're exec()-ing, we need to clean up JUST the fd */
+#define bfd_fileno(abfd) fileno((FILE *)((abfd)->iostream))
+
 bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
 
 struct bfd_preserve
@@ -4770,6 +4882,12 @@
     the contents of a file.  */
   enum bfd_flavour flavour;
 
+ /* Input format: if the file format for input to the linker is not the same
+    as the output format, then a pointer to the input format type goes here
+    in the output format's record.  (This happens for PE/PEI, at least.) */
+
+  const struct bfd_target *input_format;
+
   /* The order of bytes within the data area of a file.  */
   enum bfd_endian byteorder;
 
@@ -4952,8 +5070,8 @@
   struct bfd_symbol *
               (*_bfd_make_empty_symbol) (bfd *);
   void        (*_bfd_print_symbol)
-    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
-#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type, struct bfd_symbol *);
+#define bfd_print_symbol(b,p,s,e,r) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e,r))
   void        (*_bfd_get_symbol_info)
     (bfd *, struct bfd_symbol *, symbol_info *);
 #define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
diff -ruNbB binutils-2.17/bfd/bfd.c binutils-2.17.sua/bfd/bfd.c
--- binutils-2.17/bfd/bfd.c	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/bfd.c	2008-04-01 09:03:06 +0200
@@ -150,6 +150,13 @@
 .     be used only for archive elements.  *}
 .  int archive_pass;
 .
+.{* #ifdef DYNAMIC_LINKING *}
+.    {* Used by some backends for dynamic link private data; independent
+.       of per-format private data. *}
+.    struct dynamic_info *dynamic_info;  {* used by shared libs only *}
+.    bfd_vma *local_got_offsets; {* used if dynamic linking on all bfds *}
+.{* #endif *}
+.
 .  {* Used by the back end to hold private data.  *}
 .  union
 .    {
@@ -630,6 +636,55 @@
 }
 
 /*
+FUNCTION
+	bfd_archive_filename
+
+SYNOPSIS
+	const char *bfd_archive_filename (bfd *);
+
+DESCRIPTION
+	For a BFD that is a component of an archive, returns a string
+	with both the archive name and file name.  For other BFDs, just
+	returns the file name.
+*/
+
+const char *
+bfd_archive_filename (abfd)
+     bfd *abfd;
+{
+  if (abfd->my_archive)
+    {
+      static size_t curr = 0;
+      static char *buf;
+      size_t needed;
+
+      needed = (strlen (bfd_get_filename (abfd->my_archive))
+		+ strlen (bfd_get_filename (abfd)) + 3);
+      if (needed > curr)
+	{
+	  if (curr)
+	    free (buf);
+	  curr = needed + (needed >> 1);
+	  buf = bfd_malloc ((bfd_size_type) curr);
+	  /* If we can't malloc, fail safe by returning just the file
+	     name. This function is only used when building error
+	     messages.  */
+	  if (!buf)
+	    {
+	      curr = 0;
+	      return bfd_get_filename (abfd);
+	    }
+	}
+      sprintf (buf, "%s(%s)", bfd_get_filename (abfd->my_archive),
+	       bfd_get_filename (abfd));
+      return buf;
+    }
+  else
+    return bfd_get_filename (abfd);
+}
+
+
+/*
 SECTION
 	Miscellaneous
 
@@ -1247,6 +1302,9 @@
 .  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
 .   bfd_boolean, asymbol **);
 .
+.{* In case we're exec()-ing, we need to clean up JUST the fd *}
+.#define bfd_fileno(abfd) fileno((FILE *)((abfd)->iostream))
+.
 
 */
 
diff -ruNbB binutils-2.17/bfd/binary.c binutils-2.17.sua/bfd/binary.c
--- binutils-2.17/bfd/binary.c	2005-05-23 19:44:52 +0200
+++ binutils-2.17.sua/bfd/binary.c	2008-04-01 09:03:06 +0200
@@ -41,6 +41,17 @@
    a start symbol, an end symbol, and an absolute length symbol.  */
 #define BIN_SYMS 3
 
+static bfd_boolean binary_mkobject PARAMS ((bfd *));
+static const bfd_target *binary_object_p PARAMS ((bfd *));
+static bfd_boolean binary_get_section_contents
+  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
+static long binary_get_symtab_upper_bound PARAMS ((bfd *));
+static char *mangle_name PARAMS ((bfd *, char *));
+static long binary_canonicalize_symtab PARAMS ((bfd *, asymbol **));
+static void binary_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
+static bfd_boolean binary_set_section_contents
+  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
+static int binary_sizeof_headers PARAMS ((bfd *, bfd_boolean));
 /* Set by external programs - specifies the BFD architecture and
    machine number to be uses when creating binary BFDs.  */
 enum bfd_architecture  bfd_external_binary_architecture = bfd_arch_unknown;
@@ -158,7 +169,7 @@
 /* Return the symbol table.  */
 
 static long
-binary_canonicalize_symtab (bfd *abfd, asymbol **alocation)
+binary_canonicalize_symtab (bfd *abfd, struct bfd_symbol **alocation)
 {
   asection *sec = (asection *) abfd->tdata.any;
   asymbol *syms;
@@ -329,6 +340,7 @@
 {
   "binary",			/* name */
   bfd_target_unknown_flavour,	/* flavour */
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* byteorder */
   BFD_ENDIAN_UNKNOWN,		/* header_byteorder */
   EXEC_P,			/* object_flags */
diff -ruNbB binutils-2.17/bfd/coff-alpha.c binutils-2.17.sua/bfd/coff-alpha.c
--- binutils-2.17/bfd/coff-alpha.c	2005-07-14 09:48:28 +0200
+++ binutils-2.17.sua/bfd/coff-alpha.c	2008-04-01 09:03:07 +0200
@@ -2383,6 +2383,7 @@
 {
   "ecoff-littlealpha",		/* name */
   bfd_target_ecoff_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_LITTLE,		/* data byte order is little */
   BFD_ENDIAN_LITTLE,		/* header byte order is little */
 
diff -ruNbB binutils-2.17/bfd/coff-i386.c binutils-2.17.sua/bfd/coff-i386.c
--- binutils-2.17/bfd/coff-i386.c	2005-05-04 17:53:02 +0200
+++ binutils-2.17.sua/bfd/coff-i386.c	2008-04-01 09:03:07 +0200
@@ -47,7 +47,9 @@
 static reloc_howto_type *coff_i386_reloc_type_lookup
   PARAMS ((bfd *, bfd_reloc_code_real_type));
 
-#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
+/* This limits the alignment of common to this power; 8 byte alignment is
+   what's "good" on Pentiums, etc. */
+#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)
 /* The page size is a guess based on ELF.  */
 
 #define COFF_PAGE_SIZE 0x1000
@@ -137,6 +139,12 @@
     diff -= pe_data (output_bfd)->pe_opthdr.ImageBase;
 #endif
 
+#if 0
+	if (reloc_entry->howto->type == R_GNU_GOTOFF)
+	{
+		diff =-symbol->value;
+	}
+#endif
 #define DOIT(x) \
   x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))
 
@@ -340,7 +348,116 @@
 	 TRUE,			/* partial_inplace */
 	 0xffffffff,		/* src_mask */
 	 0xffffffff,		/* dst_mask */
-	 PCRELOFFSET)		/* pcrel_offset */
+	 PCRELOFFSET),		/* pcrel_offset */
+#ifdef DYNAMIC_LINKING /* [ */
+  {025,0,0,0,0,0,0,0,"",0,0,0,0},
+  {026,0,0,0,0,0,0,0,"",0,0,0,0},
+  {027,0,0,0,0,0,0,0,"",0,0,0,0},
+  HOWTO (R_GNU_GOT32,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 FALSE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOT32",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_PLT32,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 TRUE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "PLT32",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_COPY,		/* type 032 */                                  
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 FALSE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "COPY",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GLOB_DAT,	/* type 033 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 FALSE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GLOB_DAT",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_JUMP_SLOT,	/* type 034 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 TRUE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "JUMP_SLOT",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_RELATIVE,	/* type 035 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 TRUE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "RELATIVE",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GOTOFF,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 FALSE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOTOFF",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GOTPC,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 TRUE,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOTPC",		/* name */                                 
+	 TRUE,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+#endif /* ] */
 };
 
 /* Turn a howto into a reloc  nunmber */
@@ -393,48 +510,10 @@
       cache_ptr->addend += asect->vma;				\
   }
 
-/* We use the special COFF backend linker.  For normal i386 COFF, we
-   can use the generic relocate_section routine.  For PE, we need our
-   own routine.  */
-
-#ifndef COFF_WITH_PE
+/* We use the special COFF backend linker. */
 
 #define coff_relocate_section _bfd_coff_generic_relocate_section
 
-#else /* COFF_WITH_PE */
-
-/* The PE relocate section routine.  The only difference between this
-   and the regular routine is that we don't want to do anything for a
-   relocatable link.  */
-
-static bfd_boolean coff_pe_i386_relocate_section
-  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
-	   struct internal_reloc *, struct internal_syment *, asection **));
-
-static bfd_boolean
-coff_pe_i386_relocate_section (output_bfd, info, input_bfd,
-			       input_section, contents, relocs, syms,
-			       sections)
-     bfd *output_bfd;
-     struct bfd_link_info *info;
-     bfd *input_bfd;
-     asection *input_section;
-     bfd_byte *contents;
-     struct internal_reloc *relocs;
-     struct internal_syment *syms;
-     asection **sections;
-{
-  if (info->relocatable)
-    return TRUE;
-
-  return _bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,
-					     input_section, contents,
-					     relocs, syms, sections);
-}
-
-#define coff_relocate_section coff_pe_i386_relocate_section
-
-#endif /* COFF_WITH_PE */
 
 /* Convert an rtype to howto for the COFF backend linker.  */
 
@@ -572,6 +651,14 @@
     case BFD_RELOC_32_SECREL:
       return howto_table + R_SECREL32;
 #endif
+#ifdef DYNAMIC_LINKING
+    case BFD_RELOC_386_GOT32:
+    case BFD_RELOC_386_PLT32:
+    case BFD_RELOC_386_GOTOFF:
+    case BFD_RELOC_386_GOTPC:
+      return howto_table + (R_GNU_GOT32 + (code - BFD_RELOC_386_GOT32));
+#endif
+
     default:
       BFD_FAIL ();
       return 0;
@@ -580,6 +667,34 @@
 
 #define coff_rtype_to_howto coff_i386_rtype_to_howto
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+static bfd_boolean coff_i386_link_create_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+static bfd_boolean coff_i386_check_relocs 
+      PARAMS (( bfd *, struct bfd_link_info *, asection *, 
+		const struct internal_reloc *relocs));
+static bfd_boolean coff_i386_adjust_dynamic_symbol 
+      PARAMS (( bfd*, struct bfd_link_info *, struct coff_link_hash_entry *,
+		bfd_boolean));
+static bfd_boolean coff_i386_finish_dynamic_symbol 
+      PARAMS (( bfd *, struct bfd_link_info *, struct coff_link_hash_entry *,
+                struct internal_syment *));
+static bfd_boolean coff_i386_finish_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+
+
+#define coff_backend_link_create_dynamic_sections \
+             coff_i386_link_create_dynamic_sections
+#define coff_backend_check_relocs coff_i386_check_relocs
+#define coff_backend_adjust_dynamic_symbol coff_i386_adjust_dynamic_symbol
+#define coff_backend_size_dynamic_sections pei_generic_size_dynamic_sections
+#define coff_backend_finish_dynamic_symbol coff_i386_finish_dynamic_symbol
+#define coff_backend_finish_dynamic_sections coff_i386_finish_dynamic_sections
+
+#endif /* ] */
+
+
 #ifdef TARGET_UNDERSCORE
 
 /* If i386 gcc uses underscores for symbol names, then it does not use
@@ -604,8 +719,1035 @@
 
 #endif /* TARGET_UNDERSCORE */
 
+static bfd_boolean coff_i386_link_create_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+static bfd_boolean coff_i386_check_relocs 
+      PARAMS (( bfd *, struct bfd_link_info *, asection *, 
+		const struct internal_reloc *relocs));
+static bfd_boolean coff_i386_adjust_dynamic_symbol 
+      PARAMS (( bfd*, struct bfd_link_info *, struct coff_link_hash_entry *,
+		bfd_boolean));
+static bfd_boolean coff_i386_finish_dynamic_symbol 
+      PARAMS (( bfd *, struct bfd_link_info *, struct coff_link_hash_entry *,
+                struct internal_syment *));
+static bfd_boolean coff_i386_finish_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+
 #include "coffcode.h"
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_ENTRY_SIZE 16
+
+/* The first entry in a (PIC) procedure linkage table look like this.  */
+
+static const bfd_byte coff_i386_pic_plt0_entry[PLT_ENTRY_SIZE] =
+{
+  0xff, 0xb3, 4, 0, 0, 0,	/* pushl 4(%ebx) */
+  0xff, 0xa3, 8, 0, 0, 0,	/* jmp *8(%ebx) */
+  0, 0, 0, 0			/* pad out to 16 bytes.  */
+};
+
+/* Subsequent entries in a (PIC) procedure linkage table look like this.  */
+
+static const bfd_byte coff_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0xff, 0xa3,	/* jmp *offset(%ebx) */
+  0, 0, 0, 0,	/* replaced with offset of this symbol in .got.  */
+  0x68,		/* pushl immediate */
+  0, 0, 0, 0,	/* replaced with offset into relocation table.  */
+  0xe9,		/* jmp relative */
+  0, 0, 0, 0	/* replaced with offset to start of .plt.  */
+};
+
+  /* Since the spelling of _DYNAMIC et. al. changes, this becomes architecture
+     dependent */
+
+#ifdef TARGET_UNDERSCORE
+#define DYNAMIC_SYM "__DYNAMIC"
+#define GOT_SYM     "__GLOBAL_OFFSET_TABLE_"
+#define PLT_SYM     "__PROCEDURE_LINKAGE_TABLE_"
+#else
+#define DYNAMIC_SYM "_DYNAMIC"
+#define GOT_SYM     "_GLOBAL_OFFSET_TABLE_"
+#define PLT_SYM     "_PROCEDURE_LINKAGE_TABLE_"
+#endif
+
+static bfd_boolean
+coff_i386_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
+{
+  flagword flags;
+  register asection *s;
+  struct coff_link_hash_entry *h = NULL;
+
+  /* We need to create .plt, .rel.plt, .got, .got.plt, .dynbss, and
+     .rel.bss sections.  */
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED);
+
+  s = bfd_make_section (abfd, ".plt");
+  coff_hash_table (info)->splt = s;
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+				  (flags | SEC_CODE | SEC_READONLY))
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+
+    /* Define the symbol __PROCEDURE_LINKAGE_TABLE_ at the start of the
+       .plt section.  */
+    if (! (bfd_coff_link_add_one_symbol
+	   (info, abfd, PLT_SYM, BSF_GLOBAL, s,
+	    (bfd_vma) 0, (const char *) NULL, 
+	    FALSE, FALSE,
+	    ((struct bfd_link_hash_entry **)((void *) &h)))))
+      return FALSE;
+    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+    h->type = 0;
+
+    if (info->shared
+	&& ! _bfd_coff_link_record_dynamic_symbol (info, h))
+      return FALSE;
+
+  s = bfd_make_section (abfd, ".rel.plt");
+  coff_hash_table (info)->srelplt = s;
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY | SEC_DATA)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return FALSE;
+
+  if (! _bfd_coff_create_got_section (abfd, info, GOT_SYM, TRUE))
+    return FALSE;
+
+#ifdef USE_COPY_RELOC /* [ */
+  /* The .dynbss section is a place to put symbols which are defined
+     by dynamic objects, are referenced by regular objects, and are
+     not functions.  We must allocate space for them in the process
+     image and use a R_*_COPY reloc to tell the dynamic linker to
+     initialize them at run time.  The linker script puts the .dynbss
+     section into the .bss section of the final image.  */
+  s = bfd_make_section (abfd, ".dynbss");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
+    return FALSE;
+
+  /* The .rel.bss section holds copy relocs.  This section is not
+     normally needed.  We need to create it here, though, so that the
+     linker will map it to an output section.  We can't just create it
+     only if we need it, because we will not know whether we need it
+     until we have seen all the input files, and the first time the
+     main linker code calls BFD after examining all the input files
+     (size_dynamic_sections) the input sections have already been
+     mapped to the output sections.  If the section turns out not to
+     be needed, we can discard it later.  We will never need this
+     section when generating a shared object, since they do not use
+     copy relocs.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".rel.bss"); 
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY
+						     | SEC_DYNAMIC)
+	  || ! bfd_set_section_alignment (abfd, s, 1))
+	return FALSE;
+    }
+#endif /* ] */
+
+
+  /* The special symbol _DYNAMIC is always set to the start of the
+     .dynamic section.  This call occurs before we have processed the
+     symbols for any dynamic object, so we don't have to worry about
+     overriding a dynamic definition.  We could set _DYNAMIC in a
+     linker script, but we only want to define it if we are, in fact,
+     creating a .dynamic section.  We don't want to define it if there
+     is no .dynamic section, since on some ELF platforms the start up
+     code examines it to decide how to initialize the process.  */
+  s = coff_hash_table (info)->dynamic;
+  h = NULL;
+  if (! (bfd_coff_link_add_one_symbol
+	 (info, abfd, DYNAMIC_SYM, BSF_GLOBAL, s, (bfd_vma) 0,
+	  (const char *) NULL, 
+	  FALSE, FALSE,
+	  ((struct bfd_link_hash_entry **) ((void *)&h)))))
+    return FALSE;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bfd_boolean
+coff_i386_check_relocs (
+     bfd *abfd,
+     struct bfd_link_info *info,
+     asection *sec,
+     const struct internal_reloc *relocs)
+{
+  bfd *dynobj;
+  bfd_vma *local_got_offsets;
+  const struct internal_reloc *rel;
+  const struct internal_reloc *rel_end;
+  asection *sgot;
+  asection *srelgot;
+  asection *sreloc;
+
+  if (info->relocatable)
+    return TRUE;
+
+  /* we don't do this for .stabs (or .stabstr). */
+  if (strncmp(sec->name, ".stab",5) == 0)
+    return TRUE;
+
+  dynobj = coff_hash_table (info)->dynobj;
+  local_got_offsets = coff_local_got_offsets (abfd);
+
+  sgot = NULL;
+  srelgot = NULL;
+  sreloc = NULL;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      long r_symndx;
+      struct coff_link_hash_entry *h;
+
+      r_symndx = rel->r_symndx;
+
+      if (r_symndx == -1)
+	h = NULL;
+      else
+	h = obj_coff_sym_hashes(abfd)[r_symndx];
+
+      switch (rel->r_type)
+	{
+	case R_GNU_GOTOFF:
+	case R_GNU_GOTPC:
+	case R_GNU_GOT32:
+	  /* This symbol/reloc requires at least the existence of a GOT */
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  if (sgot == NULL)
+	      sgot = coff_hash_table(info)->sgot;
+
+	  if (sgot == NULL)
+	    {
+	      if (! _bfd_coff_create_got_section (dynobj, info, GOT_SYM, TRUE))
+		return FALSE;
+	      sgot = coff_hash_table(info)->sgot;
+	    }
+
+
+	  if (rel->r_type != R_GNU_GOT32)
+	      break;
+
+	  /* This symbol requires a real global offset table entry (and
+	     a relocation for it).  */
+	  if (srelgot == NULL
+	      && (h != NULL || info->shared))
+	    {
+	      srelgot = coff_hash_table(info)->srelgot;
+	      if (srelgot == NULL)
+		{
+		  srelgot = bfd_make_section (dynobj, ".rel.got");
+                  coff_hash_table(info)->srelgot = srelgot;
+		  if (srelgot == NULL
+		      || ! bfd_set_section_flags (dynobj, srelgot,
+						  (SEC_ALLOC
+						   | SEC_LOAD
+						   | SEC_HAS_CONTENTS
+						   | SEC_IN_MEMORY
+						   | SEC_LINKER_CREATED
+						   | SEC_READONLY))
+		      || ! bfd_set_section_alignment (dynobj, srelgot, 1))
+		    return FALSE;
+		}
+	    }
+
+	  /* If it has a GOT relocation, it needs a GOT offset.  If it
+	     has a symbol table entry, it goes there, otherwise we build
+	     a special table (for locals). */
+	  if (h != NULL)
+	    {
+	      if (h->got_offset != (bfd_vma) -1)
+		{
+		  /* We have already allocated space in the .got.  */
+		  break;
+		}
+	      h->got_offset = sgot->size;
+
+	      /* Make sure this symbol is output as a dynamic symbol.  */
+	      if (h->dynindx == -1)
+		{
+		  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+		    return FALSE;
+		}
+
+// fprintf(stderr, "relgot adds reloc #%d in slot %d, %s\n", srelgot->rawsize/10, h->got_offset/4, h->root.root.string); //
+	      srelgot->size += bfd_coff_relsz (abfd);
+	    }
+	  else
+	    {
+     	      /* This is a global offset table entry for a local
+                 symbol.  */
+	      if (local_got_offsets == NULL)
+		{
+		  size_t size;
+		  register unsigned int i;
+
+		  size = obj_raw_syment_count(abfd) * sizeof (bfd_vma);
+		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
+		  if (local_got_offsets == NULL)
+		    return FALSE;
+		  coff_local_got_offsets (abfd) = local_got_offsets;
+		  for (i = 0; i <obj_raw_syment_count(abfd); i++)
+		    local_got_offsets[i] = (bfd_vma) -1;
+		}
+	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
+		{
+		  /* We have already allocated space in the .got.  */
+		  break;
+		}
+	      local_got_offsets[r_symndx] = sgot->size;
+
+	      if (info->shared)
+		{
+		  /* If we are generating a shared object, we need to
+                     output a R_GNU_RELATIVE reloc so that the dynamic
+                     linker can adjust this GOT entry.  */
+		  srelgot->size += bfd_coff_relsz (abfd);
+// fprintf(stderr, "relgot adds anonymous\n"); //
+		}
+	    }
+
+	  sgot->size += 4;
+
+	  break;
+
+	case R_GNU_PLT32:
+	  /* This symbol requires a procedure linkage table entry.  We
+             actually build the entry in adjust_dynamic_symbol,
+             because this might be a case of linking PIC code which is
+             never referenced by a dynamic object, in which case we
+             don't need to generate a procedure linkage table entry
+             after all.  */
+
+	  /* If this is a local symbol, we resolve it directly without
+             creating a procedure linkage table entry.  */
+	  if (h == NULL)
+	    continue;
+
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_NEEDS_PLT;
+
+	  break;
+
+	case R_PCRLONG:
+	  /* local symbols don't get dynamic PCRLONG relocs */
+	  if (h == NULL)
+	      break;
+
+	  /* Symbolicly linked shared libs may not propigate all PCRLONG 
+	     relocations.  For defined symbols they end up just being 
+	     normal branches.  (When it's not symbolic, they are subject 
+	     to dynamic symbol resolution, so each needs a relocation entry.)  
+
+	     Undefined symbols still need an entry, in case someone else 
+	     defines them.  Since we don't yet know for sure whether it's
+	     undefined or not, we count them separately. */
+
+	  /* drop thru */
+        case R_DIR32:
+
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  /* DIR32 relocations always need some sort of relocation,
+	     either RELATIVE or symbolic; either way, count them. */
+#ifdef USE_COPY_RELOC
+	  if (info->shared)
+#endif
+	    {
+	      /* When creating a shared object, or not using COPY relocations,
+		 we must copy some of these reloc types into the output file.
+		 We create a reloc section in dynobj and make room for this
+		 reloc.  */
+	      if (sreloc == NULL)
+		{
+	          sreloc = coff_hash_table (info)->sreloc;
+		  if (sreloc == NULL)
+		    {
+		      flagword flags;
+
+		      sreloc = bfd_make_section (dynobj, ".rel.internal");
+	              coff_hash_table (info)->sreloc = sreloc;
+		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
+			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+		      if ((sec->flags & SEC_ALLOC) != 0)
+			flags |= SEC_ALLOC | SEC_LOAD;
+		      if (sreloc == NULL
+			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
+			  || ! bfd_set_section_alignment (dynobj, sreloc, 1))
+			return FALSE;
+		    }
+		}
+
+	      /* For the generic reloc section, we want to count the
+		 number of relocations needed on a per-symbol basis,
+		 and then increase the section size after we determine
+		 which symbols will actually need runtime reloc entries.
+		 Local symbols (h==NULL) will get RELATIVE relocs (if any),
+		 so just count 'em now.   We figure out section symbols
+		 later, as it *might* look like an ordinary ref now. */
+
+	      if (h)
+		{
+      		  if (rel->r_type == R_PCRLONG)
+		      h->num_relative_relocs_needed++;
+		  else
+		      h->num_long_relocs_needed++;
+		}
+#ifdef USE_COPY_RELOC
+	      else
+#else
+	      else if (info->shared)
+#endif
+		{
+	          sreloc->size += bfd_coff_relsz (abfd);
+		}
+	    }
+
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+coff_i386_adjust_dynamic_symbol (
+     bfd *dynobj,
+     struct bfd_link_info *info,
+     struct coff_link_hash_entry *h,
+     bfd_boolean skip)
+{
+  asection *s;
+#ifdef USE_COPY_RELOC
+  unsigned int power_of_two;
+#endif
+  asection *sreloc = coff_hash_table (info)->sreloc;
+
+  /* The first part is done for every symbol; the rest only for 
+     ones selected by the generic adjust_dynamic_symbol */
+
+  /* Earlier, we counted the number of relocations each symbol might
+     need.  Now that we know the symbol type, increase the size of 
+     .rel.internal for those symbols that will get dynamic relocations.
+
+     If it's a dynamic symbol (unconditionally) or we're doing a
+     shared library, we want to emit dynamic relocations 
+     for those relocations we counted up earlier.  (The code there knows
+     which types of relocations we care about, but doesn't for sure
+     know the symbol type.)  (N.B.: we can occasionally have dynamic symbol
+     that we reference (and thus need to count) that isn't defined, if
+     it's coming via an indirect shared lib.)
+
+     If it is a symbolic shared library, we don't want to count locally
+     defined absolute symbols, because they won't get a relocation.
+
+     DLL symbols are ALWAYS static w.r.t. .so's; their dynamic nature
+     is handled by the DLL mechanism.
+
+     Section symbols are (implicitly) counted in shared libraries 
+     because they get RELATIVE relocs that weren't counted (again because 
+     we couldn't be sure of symbol type at the time.)
+
+     Note: the fact that the count is non-zero is in the formal sense
+     equivalent to REF_REGULAR being true, so we don't need to check
+     REF_REGULAR, just add the count.
+
+     Note: if it's a very simple case, sreloc may be null (and
+     consequently all counts zero), and we don't need to bother.  */
+
+  if (sreloc != NULL 
+	&& (((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+             || (h->dynindx != -1 && h->root.type == bfd_link_hash_undefined)
+             || info->shared)
+        )
+    {
+#undef DEBUG_COUNTING
+#ifdef DEBUG_COUNTING //!!
+int did_print=0;
+if (h->num_long_relocs_needed || h->num_relative_relocs_needed) 
+{
+did_print = 1;
+fprintf(stderr, "%s (%x) adds %d+%d(?)", h->root.root.string, h->coff_link_hash_flags, h->num_long_relocs_needed, h->num_relative_relocs_needed); //!!
+}
+#endif
+      /* We'll need a dynamic reloc for 'long relocs' passed above (whether
+	 it'll be symbolic or relative is determined by the relocation code)
+	 and whether it's a suppressed symbol or not (suppressed either
+	 explicitly, or because it's symbolic mode).  For suppressed
+	 symbols, if they're locally defined and absolute, no relocation.
+	 (Read || as "or else if" below, it'll make more sense.) */
+      if (! info->shared 
+	  || !(info->symbolic || h->dynindx == -1)
+	  || !((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	  || !bfd_is_abs_section(h->root.u.def.section)
+	  )
+	{
+          sreloc->size += 
+	      (h->num_long_relocs_needed * bfd_coff_relsz (dynobj));
+          h->num_long_relocs_needed = -h->num_long_relocs_needed;
+	}
+      /* relative relocs are needed in shared but not for suppressed symbols,
+	 but undefined suppressed symbols do get a reloc. We couldn't
+	 tell about undefined when we first counted them, but now we can.
+	 Note... these tests really are different; things fail if not. */
+      if (
+#ifdef USE_DLLS
+	  (h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) == 0
+#endif
+	  && (! info->shared 
+	     || !(info->symbolic || h->dynindx == -1)
+	     || !((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	     || h->root.type == bfd_link_hash_undefined)
+	  )
+	{
+          sreloc->size += 
+	      (h->num_relative_relocs_needed * bfd_coff_relsz (dynobj));
+          h->num_relative_relocs_needed = -h->num_relative_relocs_needed;
+	}
+#ifdef DEBUG_COUNTING //!!
+if (did_print) fprintf(stderr, "relocs = %d\n", sreloc->size); //!!
+#endif
+    }
+
+  if (skip)
+      return TRUE;
+  /* Make sure we know what is going on here.  */
+#ifdef USE_WEAK
+  BFD_ASSERT (dynobj != NULL
+	      && ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT)
+		  || h->weakdef != NULL
+		  || ((h->coff_link_hash_flags
+		       & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_REF_REGULAR) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) == 0)));
+#else
+  BFD_ASSERT (dynobj != NULL
+	      && ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT)
+		  || ((h->coff_link_hash_flags
+		       & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_REF_REGULAR) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) == 0)));
+#endif
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (ISFCN(h->type)
+      || (h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0)
+    {
+      if (! info->shared
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) == 0)
+	{
+	  /* This case can occur if we saw a PLT32 reloc in an input
+             file, but the symbol was never mentioned by a dynamic
+             object.  In such a case, we don't actually need to build
+             a procedure linkage table, and we can just do a PC32
+             reloc instead.  */
+	  BFD_ASSERT ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0);
+	  return TRUE;
+	}
+
+      /* Make sure this symbol is output as a dynamic symbol.  */
+      if (h->dynindx == -1)
+	{
+	  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = coff_hash_table(info)->splt;
+      BFD_ASSERT (s != NULL);
+
+      /* If this is the first .plt entry, make room for the special
+	 first entry.  */
+      if (s->size == 0)
+	s->size += PLT_ENTRY_SIZE;
+
+      /* If this symbol is not defined in a regular file, and we are
+	 not generating a shared library, then set the symbol to this
+	 location in the .plt.  This is required to make function
+	 pointers compare as equal between the normal executable and
+	 the shared library.  */
+      if (! info->shared
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  h->root.u.def.section = s;
+	  h->root.u.def.value = s->size;
+	}
+
+      h->plt_offset = s->size;
+
+      /* Make room for this entry.  */
+      s->size += PLT_ENTRY_SIZE;
+
+      /* We also need to make an entry in the .got.plt section, which
+	 will be placed in the .got section by the linker script.  */
+
+      s = coff_hash_table(info)->sgotplt;
+      BFD_ASSERT (s != NULL);
+      s->size += 4;
+
+      /* We also need to make an entry in the .rel.plt section.  */
+
+      s = coff_hash_table(info)->srelplt;
+      BFD_ASSERT (s != NULL);
+      s->size += bfd_coff_relsz (dynobj);
+//fprintf(stderr, "relPLT adds # %d, %s\n",( s->rawsize/bfd_coff_relsz (dynobj))-1, h->root.root.string);
+
+      return TRUE;
+    }
+
+#ifdef USE_WEAK
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->weakdef != NULL)
+    {
+      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
+		  || h->weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->weakdef->root.u.def.section;
+      h->root.u.def.value = h->weakdef->root.u.def.value;
+      return TRUE;
+    }
+#endif
+
+#ifdef USE_COPY_RELOC /* [ */
+  /* If we are not doing COPY relocations at all, we assume the same
+     case as for shared libraries, and pay the cost of doing relocations
+     for such symbols at runtime if the symbol is accessed by non-PIC
+     code.  (By being smart, it's not necessarily that bad.) */
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  s = bfd_get_section_by_name (dynobj, ".dynbss");
+  BFD_ASSERT (s != NULL);
+
+  /* We must generate a R_GNU_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rel.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      asection *srel;
+
+      srel = bfd_get_section_by_name (dynobj, ".rel.bss");
+      BFD_ASSERT (srel != NULL);
+      srel->size += bfd_coff_relsz (abfd);
+      h->coff_link_hash_flags |= COFF_LINK_HASH_NEEDS_COPY;
+    }
+
+  /* We need to figure out the alignment required for this symbol.  I
+     have no idea how ELF linkers handle this.  */
+  power_of_two = bfd_log2 (h->size);
+  if (power_of_two > 3)
+    power_of_two = 3;
+
+  /* Apply the required alignment.  */
+  s->size = BFD_ALIGN (s->size,
+			    (bfd_size_type) (1 << power_of_two));
+  if (power_of_two > bfd_get_section_alignment (dynobj, s))
+    {
+      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
+	return FALSE;
+    }
+
+  /* Define the symbol as being at this point in the section.  */
+  h->root.u.def.section = s;
+  h->root.u.def.value = s->size;
+
+  /* Increment the section size to make room for the symbol.  */
+  s->size += h->size;
+#endif /* ] */
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+coff_i386_finish_dynamic_symbol (
+     bfd *output_bfd,
+     struct bfd_link_info *info,
+     struct coff_link_hash_entry *h,
+     struct internal_syment *sym)
+{
+  bfd *dynobj;
+  bfd_vma imagebase=0;
+  if (pe_data(output_bfd) != NULL)
+      imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
+
+  /* It is possible to get here with h->dynindx == -1; a symbol that is
+     forced local may still need a GOT entry. */
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  if (h->plt_offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgotplt;
+      asection *srelplt;
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      struct internal_reloc rel;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+
+    if ((h->coff_link_hash_flags & COFF_LINK_WEAK_PLT) == 0) {
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = coff_hash_table(info)->splt;
+      sgotplt = coff_hash_table(info)->sgotplt;
+      srelplt = coff_hash_table(info)->srelplt;
+      BFD_ASSERT (splt != NULL && sgotplt != NULL && srelplt != NULL);
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt_offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+	 corresponds to this function.  Each .got entry is 4 bytes.
+	 The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+
+      /* Fill in the entry in the procedure linkage table.
+
+	 Non-PIC code in a shared library won't go thru the PLT/GOT
+	 (it gets relocated inline), so using PIC in any 
+	 shared lib works.  Since the caller of the stub must be in
+	 this shared lib (and thus share a single GOT value) %ebx will
+	 be right when the PIC PLT entry is called. 
+
+	 Main won't go thru the PLT/GOT unless there's PIC in it; whether
+	 the PLT is PIC or not really doesn't matter, and it saves a
+	 few relocation entries if it is PIC.  */
+
+      /* No need for a base_file entry here (code is PIC) */
+      memcpy (splt->contents + h->plt_offset, coff_i386_pic_plt_entry,
+	      PLT_ENTRY_SIZE);
+      bfd_put_32 (output_bfd, got_offset,
+		  splt->contents + h->plt_offset + 2);
+
+      /* Fill in rest of plt entry: the offset to the relocation and
+	 the start of the PLT.  Tricky code, here:
+
+	 - This becomes the branch stub/thunk for this symbol.
+	 - Instruction 1 is a jump indirect to the symbol's GOT slot
+	   * Initially, the GOT slot contains the address of the next
+	     instruction below.
+	   * After dynamic link, this is the address of the real function.
+	 - Instruction 2 pushes the offset of the relocation entry.
+	 - Instruction 3 jumps indirect to the start of PLT, which
+	   contains:
+	      pushl .got+4   # startup crams in &info struct for this lib
+	      jmp   *.got+8  # startup crams in &runtime linker.
+	 - .got+8 contains the address of the runtime dynamic linker.
+	 - The dynamic linker is effectively called with 2 args,
+	      - the reloc entry
+	      - the info struct.  (This struct is private to the runtime
+		  side of things.  We don't know anything about it here.)
+
+	 Thus, until the dynamic linker has done it's thing (the first
+	 call) we jump to the dynamic linker after having pushed the relocation
+	 information it requires.  After that (once the GOT is modified)
+	 we jump to the real routine.  */
+
+      bfd_put_32 (output_bfd, plt_index * bfd_coff_relsz (output_bfd),
+		  splt->contents + h->plt_offset + 7);
+      bfd_put_32 (output_bfd, - (h->plt_offset + PLT_ENTRY_SIZE),
+		  splt->contents + h->plt_offset + 12);
+
+      /* if (info->base_file ...  do something */
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (splt->output_section->vma
+		   + splt->output_offset
+		   + h->plt_offset
+		   + 6 + imagebase),
+		  sgotplt->contents + got_offset);
+
+      /* Fill in the entry in the .rel.plt section.  */
+      rel.r_symndx = h->dynindx;
+      rel.r_vaddr = (sgotplt->output_section->vma
+		      + sgotplt->output_offset
+		      + got_offset);
+
+//fprintf(stderr, "relPLT emits # %d, %s\n", plt_index, h->root.root.string);
+      rel.r_type = R_GNU_JUMP_SLOT;
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+			srelplt->contents + plt_index * bfd_coff_relsz (output_bfd));
+      srelplt->reloc_count++;  /* used for subsequent assert */
+    }
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->n_scnum = N_UNDEF;
+	  sym->n_sclass = C_EXT;
+	}
+    }
+
+  if (h->got_offset != (bfd_vma) -1)
+    {
+      asection *sgot;
+      asection *srelgot;
+      struct internal_reloc rel;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+
+      sgot = coff_hash_table(info)->sgot;
+      srelgot = coff_hash_table(info)->srelgot;
+      BFD_ASSERT (sgot != NULL && srelgot != NULL);
+
+      rel.r_vaddr = (sgot->output_section->vma
+		      + sgot->output_offset
+		      + (h->got_offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+	 locally, we just want to emit a RELATIVE reloc.  The entry in
+	 the global offset table will already have been initialized in
+	 the relocate_section function.  */
+      if ((info->shared
+	     && info->symbolic
+	     && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR))
+	  || (h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0) 
+        {
+	  rel.r_type = R_GNU_RELATIVE;
+	  rel.r_symndx = 0;
+	}
+      else
+	{
+          BFD_ASSERT (h->dynindx != -1);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got_offset);
+	  rel.r_type = R_GNU_GLOB_DAT;
+	  rel.r_symndx = h->dynindx;
+	}
+
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+	      (srelgot->contents + srelgot->reloc_count*bfd_coff_relsz (output_bfd)));
+// fprintf(stderr, "finish relgot emits %d, reloc #%d, for slot %d, %s\n", rel.r_type, srelgot->reloc_count, h->got_offset/4, h->root.root.string); //
+      ++srelgot->reloc_count;
+    }
+
+#ifdef USE_COPY_RELOC /* [ */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_COPY) != 0)
+    {
+      asection *s;
+      struct internal_reloc rel;
+
+      /* This symbol needs a copy reloc.  Set it up.  */
+
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+				   ".rel.bss");
+      BFD_ASSERT (s != NULL);
+
+      rel.r_vaddr = (h->root.u.def.value
+		      + h->root.u.def.section->output_section->vma
+		      + h->root.u.def.section->output_offset);
+      rel.r_type = R_GNU_COPY;
+      rel.r_symndx = h->dynindx;
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+		      (s->contents + s->reloc_count*bfd_coff_relsz (abfd)));
+      ++s->reloc_count;
+    }
+#endif /* ] */
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
+  if (strcmp (h->root.root.string, DYNAMIC_SYM) == 0
+      || strcmp (h->root.root.string, GOT_SYM) == 0)
+    sym->n_scnum = N_ABS;
+
+  return TRUE;
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+coff_i386_finish_dynamic_sections (
+     bfd *output_bfd,
+     struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sgotplt;
+  asection *sdyn;
+  bfd_vma imagebase=0;
+
+  if (pe_data(output_bfd) != NULL)
+      imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  sgotplt = coff_hash_table(info)->sgotplt;
+  BFD_ASSERT (sgotplt != NULL);
+  sdyn = coff_hash_table (info)->dynamic;
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      asection *splt;
+      coff_external_dyn *dyncon, *dynconend;
+
+      splt = coff_hash_table(info)->splt;
+      BFD_ASSERT (splt != NULL && sdyn != NULL);
+
+      dyncon = (coff_external_dyn *) sdyn->contents;
+      dynconend = (coff_external_dyn *) (sdyn->contents + sdyn->size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  coff_internal_dyn dyn;
+	  asection *s;
+
+	  bfd_coff_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	    case DT_PLTGOT:
+	      s = coff_hash_table(info)->sgotplt;
+	      goto get_vma;
+	    case DT_JMPREL:
+	      s = coff_hash_table(info)->srelplt;
+	    get_vma:
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->output_section->vma 
+	                       + s->vma 
+			       + s->output_offset;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_PLTRELSZ:
+	      /* Get size from .rel.plt section. */
+	      s = coff_hash_table(info)->srelplt;
+	      BFD_ASSERT (s != NULL);
+	      if (s->size != 0)
+		dyn.d_un.d_val = s->size;
+	      else
+		dyn.d_un.d_val = s->size;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_RELSZ:
+	      /* Accumulate sizes from .rel.internal and .rel.got sections */
+	      s = coff_hash_table(info)->sreloc;
+	      dyn.d_un.d_val = 0;
+	      if (s != NULL)
+		{
+		  if (s->size != 0)
+		    dyn.d_un.d_val = s->size;
+		  else
+		    dyn.d_un.d_val = s->size;
+		}
+
+	      s = coff_hash_table(info)->srelgot;
+	      if (s != NULL)
+		{
+		  if (s->size != 0)
+		    dyn.d_un.d_val += s->size;
+		  else
+		    dyn.d_un.d_val += s->size;
+		}
+
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+	    }
+	}
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      if (splt->size > 0)
+	{
+	   memcpy (splt->contents, coff_i386_pic_plt0_entry, PLT_ENTRY_SIZE);
+	}
+    }
+
+  /* Fill in the first three entries in the global offset table.  */
+  if (sgotplt->size > 0)
+    {
+      /* if (info->base_file ...) */
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset + imagebase,
+		    sgotplt->contents);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 4);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 8);
+    }
+
+  return TRUE;
+}
+
+#endif /* ] DYNAMIC_LINKING */
+
+#ifdef INPUT_FORMAT
+extern const bfd_target INPUT_FORMAT;
+#define PINPUT_FORMAT &INPUT_FORMAT
+#else
+#define PINPUT_FORMAT NULL
+#endif
+
+
 const bfd_target
 #ifdef TARGET_SYM
   TARGET_SYM =
@@ -619,12 +1761,17 @@
   "coff-i386",			/* name */
 #endif
   bfd_target_coff_flavour,
+  PINPUT_FORMAT,		/* format of acceptable input files for link */
   BFD_ENDIAN_LITTLE,		/* data byte order is little */
   BFD_ENDIAN_LITTLE,		/* header byte order is little */
 
   (HAS_RELOC | EXEC_P |		/* object flags */
    HAS_LINENO | HAS_DEBUG |
+#ifdef DYNAMIC_LINKING
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED | DYNAMIC),
+#else
    HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
+#endif
 
   (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
 #ifdef COFF_WITH_PE
@@ -663,7 +1810,11 @@
      BFD_JUMP_TABLE_RELOCS (coff),
      BFD_JUMP_TABLE_WRITE (coff),
      BFD_JUMP_TABLE_LINK (coff),
+#ifdef DYNAMIC_LINKING
+     BFD_JUMP_TABLE_DYNAMIC (coff),
+#else
      BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+#endif
 
   NULL,
 
diff -ruNbB binutils-2.17/bfd/coff64-rs6000.c binutils-2.17.sua/bfd/coff64-rs6000.c
--- binutils-2.17/bfd/coff64-rs6000.c	2005-11-24 07:02:08 +0100
+++ binutils-2.17.sua/bfd/coff64-rs6000.c	2008-04-01 09:03:07 +0200
@@ -868,7 +868,7 @@
       if (current->lineno_count != 0)
 	haslinno = TRUE;
 
-      section.s_flags = sec_to_styp_flags (current->name, current->flags);
+      section.s_flags = sec_to_styp_flags (abfd, current);
 
       if (!strcmp (current->name, _TEXT))
 	{
diff -ruNbB binutils-2.17/bfd/coffcode.h binutils-2.17.sua/bfd/coffcode.h
--- binutils-2.17/bfd/coffcode.h	2005-10-25 19:40:09 +0200
+++ binutils-2.17.sua/bfd/coffcode.h	2008-04-01 09:03:07 +0200
@@ -310,7 +310,7 @@
 #define GNU_LINKONCE_WI ".gnu.linkonce.wi."
 
 static long sec_to_styp_flags
-  (const char *, flagword);
+  ( bfd *, asection *);
 static bfd_boolean styp_to_sec_flags
   (bfd *, void *, const char *, asection *, flagword *);
 static bfd_boolean coff_bad_format_hook
@@ -343,7 +343,7 @@
 static enum coff_symbol_classification coff_classify_symbol
   (bfd *, struct internal_syment *);
 static bfd_boolean coff_slurp_reloc_table
-  (bfd *, asection *, asymbol **);
+  (bfd *, asection *, asymbol **,bfd_boolean);
 static long coff_canonicalize_reloc
   (bfd *, asection *, arelent **, asymbol **);
 #ifndef coff_mkobject_hook
@@ -393,8 +393,10 @@
 #endif
 
 static long
-sec_to_styp_flags (const char *sec_name, flagword sec_flags)
+sec_to_styp_flags (bfd *abfd, asection *sec)
 {
+	const const char *sec_name = sec->name;
+	flagword sec_flags= sec->flags;
   long styp_flags = 0;
 
   if (!strcmp (sec_name, _TEXT))
@@ -516,8 +518,10 @@
    and honor whatever objcopy/strip, etc. sent us as input.  */
 
 static long
-sec_to_styp_flags (const char *sec_name, flagword sec_flags)
+sec_to_styp_flags (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
 {
+	flagword sec_flags =sec->flags;
+	const char *sec_name = sec->name;
   long styp_flags = 0;
 
   /* caution: there are at least three groups of symbols that have
@@ -531,7 +535,7 @@
   /* FIXME: There is no gas syntax to specify the debug section flag.  */
   if (strncmp (sec_name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1) == 0
       || strncmp (sec_name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1) == 0)
-    sec_flags = SEC_DEBUGGING;
+    sec_flags = SEC_READONLY | SEC_DEBUGGING;
 
   /* skip LOAD */
   /* READONLY later */
@@ -559,13 +563,15 @@
     styp_flags |= IMAGE_SCN_LNK_COMDAT;
   /* skip LINK_DUPLICATES */
   /* skip LINKER_CREATED */
-
+#if 0
   if (sec_flags & (SEC_ALLOC | SEC_LOAD))
+#endif
     {
       /* For now, the read/write bits are mapped onto SEC_READONLY, even
 	 though the semantics don't quite match.  The bits from the input
 	 are retained in pei_section_data(abfd, section)->pe_flags.  */
-      styp_flags |= IMAGE_SCN_MEM_READ;       /* Always readable.  */
+      if (!bfd_section_flag_value(abfd, sec, sec_flag_NOREAD))
+      	styp_flags |= IMAGE_SCN_MEM_READ;       /* Invert NOREAD for read  */
       if ((sec_flags & SEC_READONLY) == 0)
 	styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
       if (sec_flags & SEC_CODE)
@@ -597,6 +603,9 @@
   long styp_flags = internal_s->s_flags;
   flagword sec_flags = 0;
 
+  /* Transitional. */
+  BFD_ASSERT(&section->flags == flags_ptr);
+
 #ifdef STYP_BLOCK
   if (styp_flags & STYP_BLOCK)
     sec_flags |= SEC_TIC54X_BLOCK;
@@ -718,6 +727,7 @@
   if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
     sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
 #endif
+  section->flags = sec_flags;
 
   if (flags_ptr == NULL)
     return FALSE;
@@ -738,7 +748,18 @@
   struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
   bfd_byte *esymstart, *esym, *esymend;
   int seen_state = 0;
+  int namelen = strlen(name);
+
   char *target_name = NULL;
+  int target_len = 0;
+
+  target_name = strchr (name, '$');
+  if (target_name != NULL)
+  {
+      /* Skip the `$'.  */
+      target_name += 1;
+      target_len = strlen(target_name);
+  }
 
   sec_flags |= SEC_LINK_ONCE;
 
@@ -770,6 +791,8 @@
       struct internal_syment isym;
       char buf[SYMNMLEN + 1];
       const char *symname;
+      char *t;
+      int len;
 
       bfd_coff_swap_sym_in (abfd, esym, & isym);
 
@@ -795,7 +818,7 @@
 	     second one.  It may be some other later symbol.
 
 	     Since gas also doesn't follow MS conventions and
-	     emits the section similar to .text$<name>, where
+	     emits the section similar to .text$<something>, where
 	     <something> is the name we're looking for, we
 	     distinguish the two as follows:
 
@@ -812,6 +835,21 @@
 	  if (symname == NULL)
 	    abort ();
 
+	  /* MSVC decorated names don't appear in the section name, but
+	     there are also @s in MSVC ?? string pooling symbols.
+	     To forestall other oddities, since we know that we're
+	     dealing with MSVC if we're here at all, only investigate
+	     symbols not beginning with _. */
+	  t = strchr(symname, '@');
+	  if (strncmp(symname,"__real@",7) != 0 && symname[0] == '_' && t != NULL) 
+	    {
+	      len = t-symname;
+	    }
+	  else
+	    {
+	      len = strlen(symname);
+	    }
+
 	  switch (seen_state)
 	    {
 	    case 0:
@@ -845,7 +883,8 @@
 		   names like .text$foo__Fv (in the case of a
 		   function).  See comment above for more.  */
 
-		if (strcmp (name, symname) != 0)
+		if (namelen != len ||
+			strncmp (name, symname,len) != 0)
 		  _bfd_error_handler (_("%B: warning: COMDAT symbol '%s' does not match section name '%s'"),
 				      abfd, symname, name);
 
@@ -856,13 +895,15 @@
 				      isym.n_type, isym.n_sclass,
 				      0, isym.n_numaux, & aux);
 
-		target_name = strchr (name, '$');
-		if (target_name != NULL)
+		/* Since this is a heuristic, it can be ugly...
+		   don't let .idata pass this test.  (Otherwise
+		   .idata$5 would! */
+
+		if (target_name != NULL 
+		    && strncmp(name, ".idata", 6) != 0)
 		  {
 		    /* Gas mode.  */
 		    seen_state = 2;
-		    /* Skip the `$'.  */
-		    target_name += 1;
 		  }
 
 		/* FIXME: Microsoft uses NODUPLICATES and
@@ -912,21 +953,41 @@
 		       place to play this game? Or should we do
 		       it when reading it in.  */
 		  case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
-#ifdef STRICT_PE_FORMAT
-		    /* FIXME: This is not currently implemented.  */
-		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
-#else
+		    /* FIXME: This is not currently implemented, altho
+		       lib.exe generated .lib files use it.  To work
+		       around it, we lie and say we always want to
+		       link the section.  This works for .lib files,
+		       where each entry should only occur once, and
+		       is the only place ASSOCIATIVE has been sighted,
+		       so far.  As far as I can tell, there aren't
+		       COMDAT symbols for this case (and DUMPBIN.EXE
+		       appears to agree).
+
+		       Note that there aren't bits to represent such a
+		       state in sec_flags.  */
+
 		    sec_flags &= ~SEC_LINK_ONCE;
-#endif
-		    break;
+		    goto breakloop;
 
 		  default:  /* 0 means "no symbol" */
 		    /* debug$F gets this case; other
 		       implications ??? */
 		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
-		    break;
+		    goto breakloop;
 		  }
 	      }
+	      /* At this point we're supposed to have a comdat
+		 symbol; we use the presence of this field as a
+		 flag saying we have a comdat symbol, rather than
+		 a vanilla common.  Note the goto above in two
+		 of the cases above.  We'll fill in the actual
+		 value later when we find it.  */
+
+ 	      coff_section_data(abfd, section)->comdat = 
+ 		bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+ 	      if (coff_section_data(abfd, section)->comdat == NULL)
+		abort();
+
 	      break;
 
 	    case 2:
@@ -936,8 +997,10 @@
 #define TARGET_UNDERSCORE 0
 #endif
 	      /* Is this the name we're looking for ?  */
-	      if (strcmp (target_name,
-			  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)
+	      if (len - (TARGET_UNDERSCORE ? 1 : 0) != target_len 
+	      	|| strncmp (target_name,
+			  symname + (TARGET_UNDERSCORE ? 1 : 0), 
+			  len - (TARGET_UNDERSCORE ? 1 : 0)) != 0)
 		{
 		  /* Not the name we're looking for */
 		  esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
@@ -955,22 +1018,38 @@
 		   section #.  It is the actual symbol name.
 		   Intel puts the two adjacent, but Alpha (at
 		   least) spreads them out.  */
-
-		amt = sizeof (struct coff_comdat_info);
-		coff_section_data (abfd, section)->comdat
-		  = bfd_alloc (abfd, amt);
-		if (coff_section_data (abfd, section)->comdat == NULL)
-		  abort ();
+		/* MS tools have been seen to generate every
+		   C function as a separate comdat (/Gy).  If
+		   this is done, C_EXT and C_STAT become relevant:
+		   two static functions in different files could
+		   collide.
+
+		   When STAT, we want all the colliding functions,
+		   so we'll make sure the names don't match.
+		   (That's OK because we're using a private name
+		   in the comdat structure for name matching!) */
+
+		if (isym.n_sclass == C_STAT)
+		  {
+		    static int static_sequence = 1;
+ 		    coff_section_data (abfd, section)->comdat->symbol = 9999999; /* err if used. */
+		    newname = bfd_alloc (abfd, 10);
+		    sprintf(newname, "stat-%d",static_sequence++);
+		  }
+		else
+		  {
 
 		coff_section_data (abfd, section)->comdat->symbol =
 		  (esym - esymstart) / bfd_coff_symesz (abfd);
 
-		amt = strlen (symname) + 1;
+		amt = len  + 1;
 		newname = bfd_alloc (abfd, amt);
 		if (newname == NULL)
 		  abort ();
 
-		strcpy (newname, symname);
+		strncpy (newname, symname,len);
+		newname[len]='\0';
+		  }
 		coff_section_data (abfd, section)->comdat->name
 		  = newname;
 	      }
@@ -983,6 +1062,14 @@
     }
 
  breakloop:
+ /* If something goes wrong, it's much easier to diagnose it here
+    than in ld.  This falls into the "it shouldn't happen" category,
+    but it could, and we don't know how to recover gracefully
+    (or for that matter, at all) until we see an example. */
+   if ((coff_section_data(abfd,section)->comdat) != NULL 
+	&& (coff_section_data(abfd,section)->comdat->name) == NULL)
+      abort ();
+
   return sec_flags;
 }
 
@@ -1008,9 +1095,16 @@
   flagword sec_flags;
   bfd_boolean result = TRUE;
 
+  /* Transitional. */
+  BFD_ASSERT(&section->flags == flags_ptr);
+
   /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */
   sec_flags = SEC_READONLY;
 
+  /* Check for bit NOT set to set the NOREAD flag. */
+  if ((styp_flags & IMAGE_SCN_MEM_READ) == 0)
+      bfd_set_section_flag_value(bfd, section, sec_flag_NOREAD);
+
   /* Process each flag bit in styp_flags in turn.  */
   while (styp_flags)
     {
@@ -1043,7 +1137,7 @@
 	  break;
 #endif
 	case IMAGE_SCN_MEM_READ:
-	  /* Ignored, assume it always to be true.  */
+ 	  bfd_set_section_flag_value(bfd, section, sec_flag_NOREAD);
 	  break;
 	case IMAGE_SCN_TYPE_NO_PAD:
 	  /* Skip.  */
@@ -1130,6 +1224,8 @@
     sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
 #endif
 
+  section->flags = sec_flags;
+
   if (flags_ptr)
     * flags_ptr = sec_flags;
 
@@ -1291,6 +1387,85 @@
 .  bfd_boolean (*_bfd_coff_final_link_postscript)
 .    (bfd *, struct coff_final_link_info *);
 .
+. void (*_bfd_coff_canonicalize_one_symbol) PARAMS((
+.       bfd *,
+.       combined_entry_type *,
+.       coff_symbol_type *));
+.#ifdef DYNAMIC_LINKING
+. void (*_bfd_coff_swap_dyn_in) PARAMS ((
+.       bfd *, 
+.       const PTR, 
+.       coff_internal_dyn *));
+. void (*_bfd_coff_swap_dyn_out) PARAMS ((
+.       bfd *, 
+.       const coff_internal_dyn *, 
+.       coff_external_dyn *));
+. void (*_bfd_coff_swap_verdef_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verdef *src,
+.	coff_internal_verdef *dst));
+. void (*_bfd_coff_swap_verdef_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verdef *src,
+.	coff_external_verdef *dst));
+. void (*_bfd_coff_swap_verdaux_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verdaux *src,
+.	coff_internal_verdaux *dst));
+. void (*_bfd_coff_swap_verdaux_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verdaux *src,
+.	coff_external_verdaux *dst));
+. void (*_bfd_coff_swap_verneed_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verneed *src,
+.	coff_internal_verneed *dst));
+. void (*_bfd_coff_swap_verneed_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verneed *src,
+.	coff_external_verneed *dst));
+. void (*_bfd_coff_swap_vernaux_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_vernaux *src,
+.	coff_internal_vernaux *dst));
+. void (*_bfd_coff_swap_vernaux_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_vernaux *src,
+.	coff_external_vernaux *dst));
+. void (*_bfd_coff_swap_versym_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_versym *src,
+.	coff_internal_versym *dst));
+. void (*_bfd_coff_swap_versym_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_versym *src,
+.	coff_external_versym *dst));
+. bfd_boolean (*_bfd_coff_backend_link_create_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+. bfd_boolean (*_bfd_coff_backend_check_relocs) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       asection *,
+.       const struct internal_reloc *relocs));
+. bfd_boolean (*_bfd_coff_backend_adjust_dynamic_symbol) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       struct coff_link_hash_entry *,
+.	bfd_boolean));
+. bfd_boolean (*_bfd_coff_backend_size_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+. bfd_boolean (*_bfd_coff_backend_finish_dynamic_symbol) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       struct coff_link_hash_entry *,
+.       struct internal_syment *));
+. bfd_boolean (*_bfd_coff_backend_finish_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+.#endif
+.
 .} bfd_coff_backend_data;
 .
 .#define coff_backend_info(abfd) \
@@ -1326,6 +1501,51 @@
 .#define bfd_coff_swap_aouthdr_out(abfd, i,o) \
 .  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
 .
+.#ifdef DYNAMIC_LINKING
+.#define bfd_coff_swap_dyn_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_in) (abfd, i, o))
+.#define bfd_coff_swap_dyn_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_out) (abfd, i, o))
+.#define bfd_coff_swap_verdef_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_in) (abfd, i, o))
+.#define bfd_coff_swap_verdef_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_out) (abfd, i, o))
+.#define bfd_coff_swap_verdaux_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_in) (abfd, i, o))
+.#define bfd_coff_swap_verdaux_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_out) (abfd, i, o))
+.#define bfd_coff_swap_verneed_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_in) (abfd, i, o))
+.#define bfd_coff_swap_verneed_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_out) (abfd, i, o))
+.#define bfd_coff_swap_vernaux_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_in) (abfd, i, o))
+.#define bfd_coff_swap_vernaux_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_out) (abfd, i, o))
+.#define bfd_coff_swap_versym_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_in) (abfd, i, o))
+.#define bfd_coff_swap_versym_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_out) (abfd, i, o))
+.#define bfd_coff_backend_link_create_dynamic_sections(abfd, i) \
+.        ((coff_backend_info (abfd)-> \
+.           _bfd_coff_backend_link_create_dynamic_sections) (abfd, i))
+.#define bfd_coff_backend_check_relocs(abfd, i, s, r) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_check_relocs) \
+.           (abfd, i, s, r))
+.#define bfd_coff_backend_adjust_dynamic_symbol(abfd, i, h, s) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_adjust_dynamic_symbol) \
+.           (abfd, i, h, s))
+.#define bfd_coff_backend_size_dynamic_sections(abfd, i) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_size_dynamic_sections) \
+.           (abfd, i))
+.#define bfd_coff_backend_finish_dynamic_symbol(abfd, i, h, s) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_finish_dynamic_symbol) \
+.           (abfd, i, h, s))
+.#define bfd_coff_backend_finish_dynamic_sections(abfd, i) \
+.        ((coff_backend_info(abfd)->_bfd_coff_backend_finish_dynamic_sections) \
+.           (abfd, i))
+.#endif
+
 .#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
 .#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
 .#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
@@ -1418,6 +1638,10 @@
 .  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
 .   (info, abfd, name, flags, section, value, string, cp, coll, hashp))
 .
+.#define bfd_coff_canonicalize_one_symbol(abfd, src, dest) \
+.        ((coff_backend_info (abfd)->_bfd_coff_canonicalize_one_symbol)\
+.         (abfd, src, dest))
+.
 .#define bfd_coff_link_output_has_begun(a,p) \
 .  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
 .#define bfd_coff_final_link_postscript(a,p) \
@@ -1531,10 +1755,10 @@
   { COFF_SECTION_NAME_PARTIAL_MATCH (".stab"),
     3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
   /* Similarly for the .ctors and .dtors sections.  */
-  { COFF_SECTION_NAME_EXACT_MATCH (".ctors"),
-    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
-  { COFF_SECTION_NAME_EXACT_MATCH (".dtors"),
-    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 }
+  { COFF_SECTION_NAME_PARTIAL_MATCH (".ctor"),
+    2, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
+  { COFF_SECTION_NAME_PARTIAL_MATCH (".dtor"),
+    2, COFF_ALIGNMENT_FIELD_EMPTY, 2 }
 };
 
 static const unsigned int coff_section_alignment_table_size =
@@ -2275,6 +2499,9 @@
 
 /* Handle the csect auxent of a C_EXT or C_HIDEXT symbol.  */
 
+static bfd_boolean coff_pointerize_aux_hook
+  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
+	   unsigned int, combined_entry_type *));
 static bfd_boolean
 coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
 			  combined_entry_type *table_base,
@@ -2309,6 +2536,9 @@
 
 /* We don't want to pointerize bal entries.  */
 
+static bfd_boolean coff_pointerize_aux_hook
+  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
+	   unsigned int, combined_entry_type *));
 static bfd_boolean
 coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
 			  combined_entry_type *table_base ATTRIBUTE_UNUSED,
@@ -2333,6 +2563,9 @@
 
 /* Print an aux entry.  This returns TRUE if it has printed it.  */
 
+static bfd_boolean coff_print_aux
+  PARAMS ((bfd *, FILE *, combined_entry_type *, combined_entry_type *,
+	   combined_entry_type *, unsigned int));
 static bfd_boolean
 coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,
 		FILE *file ATTRIBUTE_UNUSED,
@@ -3028,7 +3261,7 @@
       ++count;
 
     /* We allocate an extra cell to simplify the final loop.  */
-    amt = sizeof (struct asection *) * (count + 1);
+    amt = sizeof (asection *) * (count + 1);
     section_list = bfd_malloc (amt);
     if (section_list == NULL)
       return FALSE;
@@ -3113,7 +3346,8 @@
 #endif
 
       /* Only deal with sections which have contents.  */
-      if (!(current->flags & SEC_HAS_CONTENTS))
+      if (!(current->flags & SEC_HAS_CONTENTS)
+          || current->size == 0)
 	continue;
 
 #ifdef COFF_IMAGE_WITH_PE
@@ -3362,6 +3596,8 @@
   asection *bss_sec = NULL;
   struct internal_filehdr internal_f;
   struct internal_aouthdr internal_a;
+  int section_count;
+
 #ifdef COFF_LONG_SECTION_NAMES
   size_t string_size = STRING_SIZE_SIZE;
 #endif
@@ -3381,6 +3617,9 @@
   reloc_base = obj_relocbase (abfd);
 
   /* Work out the size of the reloc and linno areas.  */
+  /* Incidentally, count the number of sections */
+  section_count=0;
+
 
   for (current = abfd->sections; current != NULL; current =
        current->next)
@@ -3390,6 +3629,7 @@
       if (obj_pe (abfd) && current->reloc_count >= 0xffff)
 	reloc_count ++;
 #endif
+      section_count++;
       reloc_count += current->reloc_count;
     }
 
@@ -3544,7 +3784,7 @@
 #endif
 #endif
 
-      section.s_flags = sec_to_styp_flags (current->name, current->flags);
+      section.s_flags = sec_to_styp_flags (abfd, current);
 
       if (!strcmp (current->name, _TEXT))
 	text_sec = current;
@@ -3553,6 +3793,61 @@
       else if (!strcmp (current->name, _BSS))
 	bss_sec = current;
 
+#ifdef DYNAMIC_LINKING
+      else if (strcmp (current->name, ".dynsym") == 0)
+	{
+          int dynsymcount;
+	  /* objcopy or strip will copy over info_r, but may not set
+	     dynsymcount.  The linker will set dynsymcount, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    {
+              dynsymcount = 
+	          coff_hash_table(coff_data(abfd)->link_info)->dynsymcount;
+	      section.s_nreloc = dynsymcount;
+	    }
+	    else
+	      section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".dynstr") == 0)
+	{
+	  section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version_d") == 0)
+	{
+	  /* objcopy or strip will copy over info_r, but may not set
+	     cverrefs.  The linker will set cverrefs, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    section.s_nreloc = dyn_data (abfd)->cverdefs;
+	  else
+	    BFD_ASSERT (dyn_data (abfd)->cverdefs == 0
+			|| current->info_r == dyn_data (abfd)->cverdefs);
+
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version_r") == 0)
+	{
+	  /* objcopy or strip will copy over info_r, but may not set
+	     cverrefs.  The linker will set cverrefs, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    section.s_nreloc = dyn_data (abfd)->cverrefs;
+	  else
+	    BFD_ASSERT (dyn_data (abfd)->cverrefs == 0
+			|| current->info_r == dyn_data (abfd)->cverrefs);
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version") == 0)
+	{
+	  section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+#endif
+
+
 #ifdef I960
       section.s_align = (current->alignment_power
 			 ? 1 << current->alignment_power
@@ -3769,6 +4064,14 @@
   internal_f.f_target_id = TIC80_TARGET_ID;
 #endif
 
+#ifdef COFF_IMAGE_WITH_PE
+#ifdef DYNAMIC_LINKING
+  if ((abfd->flags & DYNAMIC) != 0)
+    pe_data(abfd)->pe_opthdr.DllCharacteristics |= 0x0001;
+#endif
+#endif
+
+
   /* FIXME, should do something about the other byte orders and
      architectures.  */
 
@@ -4310,49 +4613,31 @@
   return TRUE;
 }
 
-/* Slurp in the symbol table, converting it to generic form.  Note
-   that if coff_relocate_section is defined, the linker will read
-   symbols via coff_link_add_symbols, rather than via this routine.  */
+// NOTE:  This text is NOT part of the official patch submittal, but
+// MUST remain with it until the patch is actually applied to the official
+// source.  Thus the // comments.
+
+// The goal of this group of changes is to split coff_slurp_symbol_table
+// into a "worker" coff_canonicalize_one_symbol, which is the body of
+// function, and a driver coff_slurp_symbol_table.  To make maintenance
+// easier until the patch is applied officially, the indentation has not
+// been changed to match GNU standards.  When actually applying the change,
+// the indentation needs to be changed, after the patch is applied.
+// There are other // comments below to indicate the residual changes.
 
-static bfd_boolean
-coff_slurp_symbol_table (bfd * abfd)
-{
-  combined_entry_type *native_symbols;
-  coff_symbol_type *cached_area;
-  unsigned int *table_ptr;
-  bfd_size_type amt;
-  unsigned int number_of_symbols = 0;
-
-  if (obj_symbols (abfd))
-    return TRUE;
-
-  /* Read in the symbol table.  */
-  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
-    return FALSE;
-
-  /* Allocate enough room for all the symbols in cached form.  */
-  amt = obj_raw_syment_count (abfd);
-  amt *= sizeof (coff_symbol_type);
-  cached_area = bfd_alloc (abfd, amt);
-  if (cached_area == NULL)
-    return FALSE;
+/* Input one symbol, needed for dynamic linking as well as 
+   coff_slurp_symbol_table */
 
-  amt = obj_raw_syment_count (abfd);
-  amt *= sizeof (unsigned int);
-  table_ptr = bfd_alloc (abfd, amt);
+static void coff_canonicalize_one_symbol 
+  PARAMS((bfd *, combined_entry_type *, coff_symbol_type *));
 
-  if (table_ptr == NULL)
-    return FALSE;
-  else
-    {
-      coff_symbol_type *dst = cached_area;
-      unsigned int last_native_index = obj_raw_syment_count (abfd);
-      unsigned int this_index = 0;
-
-      while (this_index < last_native_index)
-	{
-	  combined_entry_type *src = native_symbols + this_index;
-	  table_ptr[this_index] = number_of_symbols;
+static void
+coff_canonicalize_one_symbol (abfd, src, dst)
+     bfd * abfd;
+     combined_entry_type *src;
+     coff_symbol_type *dst;
+{
+//  This needs an indentation fix.
 	  dst->symbol.the_bfd = abfd;
 
 	  dst->symbol.name = (char *) (src->u.syment._n._n_n._n_offset);
@@ -4367,7 +4652,13 @@
 	    {
 #ifdef I960
 	    case C_LEAFEXT:
-	      /* Fall through to next case.  */
+#if 0
+	      dst->symbol.value = src->u.syment.n_value - dst->symbol.section->vma;
+	      dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL;
+	      dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
+#endif
+	      /* Fall through to next case */
+
 #endif
 
 	    case C_EXT:
@@ -4380,10 +4671,10 @@
 	    case C_HIDEXT:
 #endif
 #ifdef C_SYSTEM
-	    case C_SYSTEM:	/* System Wide variable.  */
+	    case C_SYSTEM:	/* System Wide variable */
 #endif
 #ifdef COFF_WITH_PE
-            /* In PE, 0x68 (104) denotes a section symbol.  */
+            /* In PE, 0x68 (104) denotes a section symbol */
             case C_SECTION:
 	    /* In PE, 0x69 (105) denotes a weak external symbol.  */
 	    case C_NT_WEAK:
@@ -4392,18 +4683,14 @@
 		{
 		case COFF_SYMBOL_GLOBAL:
 		  dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL;
-#if defined COFF_WITH_PE
-		  /* PE sets the symbol to a value relative to the
-                     start of the section.  */
-		  dst->symbol.value = src->u.syment.n_value;
-#else
 		  dst->symbol.value = (src->u.syment.n_value
 				       - dst->symbol.section->vma);
-#endif
 		  if (ISFCN ((src->u.syment.n_type)))
+		    {
 		    /* A function ext does not go at the end of a
 		       file.  */
 		    dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
+		    }
 		  break;
 
 		case COFF_SYMBOL_COMMON:
@@ -4455,16 +4742,16 @@
 
 	      break;
 
-	    case C_STAT:	 /* Static.  */
+	    case C_STAT:	/* static			 */
 #ifdef I960
-	    case C_LEAFSTAT:	 /* Static leaf procedure.  */
+	    case C_LEAFSTAT:	/* static leaf procedure        */
 #endif
 #if defined ARM
-            case C_THUMBSTAT:    /* Thumb static.  */
-            case C_THUMBLABEL:   /* Thumb label.  */
-            case C_THUMBSTATFUNC:/* Thumb static function.  */
+            case C_THUMBSTAT:   /* Thumb static                  */
+            case C_THUMBLABEL:  /* Thumb label                   */
+            case C_THUMBSTATFUNC:/* Thumb static function        */
 #endif
-	    case C_LABEL:	 /* Label.  */
+	    case C_LABEL:	/* label			 */
 	      if (src->u.syment.n_scnum == N_DEBUG)
 		dst->symbol.flags = BSF_DEBUGGING;
 	      else
@@ -4474,43 +4761,42 @@
 		 section, if there is one.  */
 	      if (dst->symbol.section)
 		{
-#if defined COFF_WITH_PE
-		  /* PE sets the symbol to a value relative to the
-                     start of the section.  */
-		  dst->symbol.value = src->u.syment.n_value;
-#else
 		  dst->symbol.value = (src->u.syment.n_value
 				       - dst->symbol.section->vma);
-#endif
 		}
 	      else
 		dst->symbol.value = src->u.syment.n_value;
 	      break;
 
-	    case C_MOS:		/* Member of structure.  */
-	    case C_EOS:		/* End of structure.  */
-	    case C_REGPARM:	/* Register parameter.  */
-	    case C_REG:		/* register variable.  */
-              /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
+	    case C_MOS:	/* member of structure	 */
+	    case C_EOS:	/* end of structure		 */
+#ifdef NOTDEF			/* C_AUTOARG has the same value */
+#ifdef C_GLBLREG
+	    case C_GLBLREG:	/* A29k-specific storage class */
+#endif
+#endif
+	    case C_REGPARM:	/* register parameter		 */
+	    case C_REG:	/* register variable		 */
+              /* C_AUTOARG conflictes with TI COFF C_UEXT */
 #if !defined (TIC80COFF) && !defined (TICOFF)
 #ifdef C_AUTOARG
-	    case C_AUTOARG:	/* 960-specific storage class.  */
+	    case C_AUTOARG:	/* 960-specific storage class */
 #endif
 #endif
-	    case C_TPDEF:	/* Type definition.  */
+	    case C_TPDEF:	/* type definition		 */
 	    case C_ARG:
-	    case C_AUTO:	/* Automatic variable.  */
-	    case C_FIELD:	/* Bit field.  */
-	    case C_ENTAG:	/* Enumeration tag.  */
-	    case C_MOE:		/* Member of enumeration.  */
-	    case C_MOU:		/* Member of union.  */
-	    case C_UNTAG:	/* Union tag.  */
+	    case C_AUTO:	/* automatic variable */
+	    case C_FIELD:	/* bit field */
+	    case C_ENTAG:	/* enumeration tag		 */
+	    case C_MOE:	/* member of enumeration	 */
+	    case C_MOU:	/* member of union		 */
+	    case C_UNTAG:	/* union tag			 */
 	      dst->symbol.flags = BSF_DEBUGGING;
 	      dst->symbol.value = (src->u.syment.n_value);
 	      break;
 
-	    case C_FILE:	/* File name.  */
-	    case C_STRTAG:	/* Structure tag.  */
+	    case C_FILE:	/* file name			 */
+	    case C_STRTAG:	/* structure tag		 */
 #ifdef RS6000COFF_C
 	    case C_GSYM:
 	    case C_LSYM:
@@ -4518,9 +4804,7 @@
 	    case C_RSYM:
 	    case C_RPSYM:
 	    case C_STSYM:
-	    case C_TCSYM:
 	    case C_BCOMM:
-	    case C_ECOML:
 	    case C_ECOMM:
 	    case C_DECL:
 	    case C_ENTRY:
@@ -4532,8 +4816,8 @@
 	      break;
 
 #ifdef RS6000COFF_C
-	    case C_BINCL:	/* Beginning of include file.  */
-	    case C_EINCL:	/* Ending of include file.  */
+	    case C_BINCL:	/* beginning of include file     */
+	    case C_EINCL:	/* ending of include file        */
 	      /* The value is actually a pointer into the line numbers
                  of the file.  We locate the line number entry, and
                  set the section to the section which contains it, and
@@ -4574,9 +4858,9 @@
 	      break;
 #endif
 
-	    case C_BLOCK:	/* ".bb" or ".eb".  */
-	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf").  */
-	    case C_EFCN:	/* Physical end of function.  */
+	    case C_BLOCK:	/* ".bb" or ".eb"		 */
+	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf")  */
+	    case C_EFCN:	/* physical end of function	 */
 #if defined COFF_WITH_PE
 	      /* PE sets the symbol to a value relative to the start
 		 of the section.  */
@@ -4588,7 +4872,13 @@
 		  dst->symbol.flags = BSF_DEBUGGING;
 		}
 	      else
+		{
 		dst->symbol.flags = BSF_DEBUGGING | BSF_DEBUGGING_RELOC;
+		  /* Base the value as an index from the base of the
+		     section. */
+		  dst->symbol.value = 
+		    (src->u.syment.n_value - dst->symbol.section->vma);
+		}
 #else
 	      /* Base the value as an index from the base of the
 		 section.  */
@@ -4598,7 +4888,7 @@
 #endif
 	      break;
 
-	    case C_STATLAB:	/* Static load time label.  */
+	    case C_STATLAB:	/* Static load time label */
               dst->symbol.value = src->u.syment.n_value;
               dst->symbol.flags = BSF_GLOBAL;
               break;
@@ -4611,51 +4901,111 @@
 		  && src->u.syment.n_scnum == 0)
 		break;
 	      /* Fall through.  */
-	    case C_EXTDEF:	/* External definition.  */
-	    case C_ULABEL:	/* Undefined label.  */
-	    case C_USTATIC:	/* Undefined static.  */
+	    case C_EXTDEF:	/* external definition		 */
+	    case C_ULABEL:	/* undefined label		 */
+	    case C_USTATIC:	/* undefined static		 */
 #ifndef COFF_WITH_PE
             /* C_LINE in regular coff is 0x68.  NT has taken over this storage
-               class to represent a section symbol.  */
-	    case C_LINE:	/* line # reformatted as symbol table entry.  */
+               class to represent a section symbol */
+	    case C_LINE:	/* line # reformatted as symbol table entry */
 	      /* NT uses 0x67 for a weak symbol, not C_ALIAS.  */
-	    case C_ALIAS:	/* Duplicate tag.  */
+	    case C_ALIAS:	/* duplicate tag		 */
 #endif
-	      /* New storage classes for TI COFF.  */
+	      /* New storage classes for TI COFF */
 #if defined(TIC80COFF) || defined(TICOFF)
-	    case C_UEXT:	/* Tentative external definition.  */
+	    case C_UEXT:	/* Tentative external definition */
 #endif
-	    case C_EXTLAB:	/* External load time label.  */
-	    case C_HIDDEN:	/* Ext symbol in dmert public lib.  */
+	    case C_EXTLAB:	/* External load time label */
+	    case C_HIDDEN:	/* ext symbol in dmert public lib */
 	    default:
 	      (*_bfd_error_handler)
-		(_("%B: Unrecognized storage class %d for %s symbol `%s'"),
-		 abfd, src->u.syment.n_sclass,
+		(_("%s: Unrecognized storage class %d for %s symbol `%s'"),
+		 bfd_archive_filename (abfd), src->u.syment.n_sclass,
 		 dst->symbol.section->name, dst->symbol.name);
 	      dst->symbol.flags = BSF_DEBUGGING;
 	      dst->symbol.value = (src->u.syment.n_value);
 	      break;
 	    }
 
+	  if (src->u.syment.n_scnum == N_DEBUG)
+	     dst->symbol.flags |= BSF_DEBUGGING;
+
+/*      BFD_ASSERT(dst->symbol.flags != 0);*/
+
 	  dst->native = src;
 
 	  dst->symbol.udata.i = 0;
-	  dst->lineno = NULL;
+	  dst->lineno = (alent *) NULL;
+
+    // End of misindented region
+}
+
+/* Slurp in the symbol table, converting it to generic form.  Note
+   that if coff_relocate_section is defined, the linker will read
+   symbols via coff_link_add_symbols, rather than via this routine.  */
+
+static bfd_boolean coff_slurp_symbol_table PARAMS (( bfd *abfd));
+
+static bfd_boolean
+coff_slurp_symbol_table (abfd)
+     bfd * abfd;
+{
+  combined_entry_type *native_symbols;
+  coff_symbol_type *cached_area;
+  unsigned int *table_ptr;
+  bfd_size_type amt;
+
+  unsigned int number_of_symbols = 0;
+
+  if (obj_symbols (abfd))
+    return TRUE;
+
+  /* Read in the symbol table */
+  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
+    {
+      return (FALSE);
+    }				/* on error */
+
+  /* Allocate enough room for all the symbols in cached form */
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (coff_symbol_type);
+  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
+  if (cached_area == NULL)
+    return FALSE;
+
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (unsigned int);
+  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);
+
+  if (table_ptr == NULL)
+    return FALSE;
+  else
+    {
+      coff_symbol_type *dst = cached_area;
+      unsigned int last_native_index = obj_raw_syment_count (abfd);
+      unsigned int this_index = 0;
+      while (this_index < last_native_index)
+	{
+	  combined_entry_type *src = native_symbols + this_index;
+	  table_ptr[this_index] = number_of_symbols;
+
 	  this_index += (src->u.syment.n_numaux) + 1;
+
+	  bfd_coff_canonicalize_one_symbol(abfd, src, dst);
+
 	  dst++;
 	  number_of_symbols++;
-	}
-    }
+	}			/* walk the native symtab */
+    }				/* bfdize the native symtab */
 
   obj_symbols (abfd) = cached_area;
   obj_raw_syments (abfd) = native_symbols;
 
   bfd_get_symcount (abfd) = number_of_symbols;
   obj_convert (abfd) = table_ptr;
-  /* Slurp the line tables for each section too.  */
+  /* Slurp the line tables for each section too */
   {
     asection *p;
-
     p = abfd->sections;
     while (p)
       {
@@ -4663,9 +5013,9 @@
 	p = p->next;
       }
   }
-
   return TRUE;
-}
+}				/* coff_slurp_symbol_table() */
+
 
 /* Classify a COFF symbol.  A couple of targets have globally visible
    symbols which are not class C_EXT, and this handles those.  It also
@@ -4691,9 +5041,6 @@
 #ifdef C_SYSTEM
     case C_SYSTEM:
 #endif
-#ifdef COFF_WITH_PE
-    case C_NT_WEAK:
-#endif
       if (syment->n_scnum == 0)
 	{
 	  if (syment->n_value == 0)
@@ -4703,6 +5050,11 @@
 	}
       return COFF_SYMBOL_GLOBAL;
 
+#ifdef COFF_WITH_PE
+    case C_NT_WEAK:
+      return COFF_SYMBOL_GLOBAL;
+#endif
+
     default:
       break;
     }
@@ -4811,14 +5163,21 @@
 #endif
 
 static bfd_boolean
-coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
+coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols, bfd_boolean dynamic)
 {
   RELOC *native_relocs;
   arelent *reloc_cache;
   arelent *cache_ptr;
   unsigned int idx;
   bfd_size_type amt;
-
+  unsigned int num_relocs;
+  unsigned int *conv_table;
+  int conv_table_size = 0;
+  bfd_vma this_vma;
+
+// NOTE:  MISINDENT until final patch
+  if (!dynamic)
+    {   //  Begin misindent
   if (asect->relocation)
     return TRUE;
   if (asect->reloc_count == 0)
@@ -4828,15 +5187,48 @@
   if (!coff_slurp_symbol_table (abfd))
     return FALSE;
 
+  num_relocs = asect->reloc_count;
+
   amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
   native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
   amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
   reloc_cache = bfd_alloc (abfd, amt);
 
+  conv_table = obj_convert (abfd);
+  conv_table_size = obj_conv_table_size (abfd);
+
   if (reloc_cache == NULL || native_relocs == NULL)
     return FALSE;
 
-  for (idx = 0; idx < asect->reloc_count; idx++)
+  this_vma = asect->vma;
+    } // end of misindent.
+
+#ifdef DYNAMIC_LINKING
+  else
+    {
+      num_relocs = pei_section_data (abfd,asect)->virt_size
+	   / bfd_coff_relsz (abfd);
+
+      native_relocs = bfd_alloc (abfd, pei_section_data(abfd,asect)->virt_size);
+      if (native_relocs == NULL)
+	return FALSE;
+      bfd_get_section_contents(abfd, asect, native_relocs, 0, 
+				pei_section_data(abfd,asect)->virt_size);
+
+      reloc_cache = (arelent *)
+	bfd_alloc (abfd, (size_t) (num_relocs * sizeof (arelent)));
+      if (reloc_cache == NULL)
+	return FALSE;
+
+      conv_table = NULL;
+
+      /* We'd apply the VMA of the .rel.dyn section if we
+	 used the section's vma, which is wrong! 0 is right. */
+      this_vma = 0;
+    }
+#endif
+
+  for (idx = 0; idx < num_relocs; idx++)
     {
       struct internal_reloc dst;
       struct external_reloc *src;
@@ -4851,23 +5243,57 @@
 
 #ifdef RELOC_PROCESSING
       RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
+
+      if (cache_ptr->howto == NULL)
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: illegal relocation type %d at address 0x%lx"),
+	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
+	  bfd_set_error (bfd_error_bad_value);
+	  return false;
+	}
+
 #else
       cache_ptr->address = dst.r_vaddr;
 
+      /* Fill in the cache_ptr->howto field from dst.r_type;
+	 We need this very early because of use of symndx_is_value below */
+      RTYPE2HOWTO (cache_ptr, &dst);
+
+      if (cache_ptr->howto == NULL)
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: illegal relocation type %d at address 0x%lx"),
+	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+
+
       if (dst.r_symndx != -1)
 	{
-	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
+	  if (dst.r_symndx < 0 || 
+		(conv_table !=NULL && dst.r_symndx >= conv_table_size))
 	    {
 	      (*_bfd_error_handler)
-		(_("%B: warning: illegal symbol index %ld in relocs"),
-		 abfd, dst.r_symndx);
+		(_("%B: warning: illegal symbol index %ld at offset 0x%1x in relocs"),
+		 abfd, dst.r_symndx, dst.r_vaddr);
 	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
 	      ptr = NULL;
 	    }
+#ifdef DYNAMIC_LINKING
+	  else if (conv_table == NULL)
+  	    {
+	      /* Dynamic link symbol tables contain no aux entries, so
+		 the index applies directly. */
+	      cache_ptr->sym_ptr_ptr = symbols + dst.r_symndx;
+  	      ptr = *(cache_ptr->sym_ptr_ptr);
+  	    }
+#endif
 	  else
 	    {
 	      cache_ptr->sym_ptr_ptr = (symbols
-					+ obj_convert (abfd)[dst.r_symndx]);
+					+ conv_table [dst.r_symndx]);
 	      ptr = *(cache_ptr->sym_ptr_ptr);
 	    }
 	}
@@ -4887,21 +5313,11 @@
       /* Calculate any reloc addend by looking at the symbol.  */
       CALC_ADDEND (abfd, ptr, dst, cache_ptr);
 
-      cache_ptr->address -= asect->vma;
+      cache_ptr->address -= this_vma;
       /* !! cache_ptr->section = NULL;*/
 
-      /* Fill in the cache_ptr->howto field from dst.r_type.  */
-      RTYPE2HOWTO (cache_ptr, &dst);
 #endif	/* RELOC_PROCESSING */
 
-      if (cache_ptr->howto == NULL)
-	{
-	  (*_bfd_error_handler)
-	    (_("%B: illegal relocation type %d at address 0x%lx"),
-	     abfd, dst.r_type, (long) dst.r_vaddr);
-	  bfd_set_error (bfd_error_bad_value);
-	  return FALSE;
-	}
     }
 
   asect->relocation = reloc_cache;
@@ -4917,6 +5333,10 @@
    always work.  It is the responsibility of the including file to
    make sure it is reasonable if it is needed.  */
 
+static reloc_howto_type *coff_rtype_to_howto
+  PARAMS ((bfd *, asection *, struct internal_reloc *,
+	   struct coff_link_hash_entry *, struct internal_syment *,
+	   bfd_vma *));
 static reloc_howto_type *
 coff_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
 		     asection *sec ATTRIBUTE_UNUSED,
@@ -4964,7 +5384,7 @@
     }
   else
     {
-      if (! coff_slurp_reloc_table (abfd, section, symbols))
+      if (! coff_slurp_reloc_table (abfd, section, symbols,FALSE))
 	return -1;
 
       tblptr = section->relocation;
@@ -4976,9 +5396,49 @@
   return section->reloc_count;
 }
 
+/* Canonicalize the dynamic relocation entries. */
+static long coff_canonicalize_dynamic_reloc 
+    PARAMS ((bfd *, arelent **, asymbol **));
+
+static long
+coff_canonicalize_dynamic_reloc (abfd, storage, syms)
+     bfd *abfd;
+     arelent **storage;
+     asymbol **syms;
+{
+  asection *s;
+  long ret;
+  arelent *p;
+  long count, i;
+
+  if (dyn_data (abfd) == 0)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  ret = 0;
+  s = bfd_get_section_by_name(abfd, ".rel.dyn");
+
+  if (! coff_slurp_reloc_table (abfd, s, syms, TRUE))
+    return -1;
+  count = pei_section_data(abfd,s)->virt_size / bfd_coff_relsz(abfd);
+  p = s->relocation;
+  for (i = 0; i < count; i++)
+    *storage++ = p++;
+  ret += count;
+
+  *storage = NULL;
+
+  return ret;
+}
+
 #ifndef coff_reloc16_estimate
 #define coff_reloc16_estimate dummy_reloc16_estimate
 
+static int dummy_reloc16_estimate
+  PARAMS ((bfd *, asection *, arelent *, unsigned int,
+	   struct bfd_link_info *));
 static int
 dummy_reloc16_estimate (bfd *abfd ATTRIBUTE_UNUSED,
 			asection *input_section ATTRIBUTE_UNUSED,
@@ -4998,6 +5458,9 @@
 
 /* This works even if abort is not declared in any header file.  */
 
+static void dummy_reloc16_extra_cases
+  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
+	   bfd_byte *, unsigned int *, unsigned int *));
 static void
 dummy_reloc16_extra_cases (bfd *abfd ATTRIBUTE_UNUSED,
 			   struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
@@ -5060,6 +5523,8 @@
 
 #ifndef coff_link_output_has_begun
 
+static bfd_boolean coff_link_output_has_begun
+  PARAMS ((bfd *, struct coff_final_link_info *));
 static bfd_boolean
 coff_link_output_has_begun (bfd * abfd,
 			    struct coff_final_link_info * info ATTRIBUTE_UNUSED)
@@ -5070,6 +5535,8 @@
 
 #ifndef coff_final_link_postscript
 
+static bfd_boolean coff_final_link_postscript
+  PARAMS ((bfd *, struct coff_final_link_info *));
 static bfd_boolean
 coff_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,
 			    struct coff_final_link_info * pfinfo ATTRIBUTE_UNUSED)
@@ -5121,7 +5588,7 @@
 #define coff_SWAP_scnhdr_in coff_swap_scnhdr_in
 #endif
 
-static const bfd_coff_backend_data bfd_coff_std_swap_table ATTRIBUTE_UNUSED =
+static const bfd_coff_backend_data bfd_coff_std_swap_table =
 {
   coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
   coff_SWAP_aux_out, coff_SWAP_sym_out,
@@ -5158,7 +5625,20 @@
   coff_classify_symbol, coff_compute_section_file_positions,
   coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
   coff_adjust_symndx, coff_link_add_one_symbol,
-  coff_link_output_has_begun, coff_final_link_postscript
+  coff_link_output_has_begun, coff_final_link_postscript,
+  coff_canonicalize_one_symbol,
+#ifdef DYNAMIC_LINKING
+  coff_swap_dyn_in, coff_swap_dyn_out,
+  coff_swap_verdef_in, coff_swap_verdef_out,
+  coff_swap_verdaux_in, coff_swap_verdaux_out,
+  coff_swap_verneed_in, coff_swap_verneed_out,
+  coff_swap_vernaux_in, coff_swap_vernaux_out,
+  coff_swap_versym_in, coff_swap_versym_out,
+  coff_backend_link_create_dynamic_sections, coff_backend_check_relocs, 
+  coff_backend_adjust_dynamic_symbol, coff_backend_size_dynamic_sections,
+  coff_backend_finish_dynamic_symbol, coff_backend_finish_dynamic_sections
+#endif
+
 };
 
 #ifdef TICOFF
diff -ruNbB binutils-2.17/bfd/coffgen.c binutils-2.17.sua/bfd/coffgen.c
--- binutils-2.17/bfd/coffgen.c	2005-05-23 19:44:52 +0200
+++ binutils-2.17.sua/bfd/coffgen.c	2008-04-01 09:03:07 +0200
@@ -43,10 +43,37 @@
 #include "coff/internal.h"
 #include "libcoff.h"
 
+static void coff_fix_symbol_name
+  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_size_type *,
+	   asection **, bfd_size_type *));
+static bfd_boolean coff_write_symbol
+  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_vma *,
+	   bfd_size_type *, asection **, bfd_size_type *));
+static bfd_boolean coff_write_alien_symbol
+  PARAMS ((bfd *, asymbol *, bfd_vma *, bfd_size_type *,
+	   asection **, bfd_size_type *));
+static bfd_boolean coff_write_native_symbol
+  PARAMS ((bfd *, coff_symbol_type *, bfd_vma *, bfd_size_type *,
+	   asection **, bfd_size_type *));
+static void coff_pointerize_aux
+  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
+	   unsigned int, combined_entry_type *));
+static asection *make_a_section_from_file
+  PARAMS ((bfd *, struct internal_scnhdr *, unsigned int));
+const bfd_target *coff_real_object_p
+  PARAMS ((bfd *, unsigned, struct internal_filehdr *,
+	   struct internal_aouthdr *));
+static void fixup_symbol_value
+  PARAMS ((bfd *, coff_symbol_type *, struct internal_syment *));
+static char *build_debug_section
+  PARAMS ((bfd *));
+static char *copy_name
+  PARAMS ((bfd *, char *, size_t));
+
 /* Take a section header read from a coff file (in HOST byte order),
    and make a BFD "section" out of it.  This is used by ECOFF.  */
 
-static bfd_boolean
+static asection *
 make_a_section_from_file (bfd *abfd,
 			  struct internal_scnhdr *hdr,
 			  unsigned int target_index)
@@ -54,7 +81,6 @@
   asection *return_section;
   char *name;
   bfd_boolean result = TRUE;
-  flagword flags;
 
   name = NULL;
 
@@ -74,14 +100,14 @@
 	{
 	  strings = _bfd_coff_read_string_table (abfd);
 	  if (strings == NULL)
-	    return FALSE;
+	    return NULL;
 	  /* FIXME: For extra safety, we should make sure that
              strindex does not run us past the end, but right now we
              don't know the length of the string table.  */
 	  strings += strindex;
 	  name = bfd_alloc (abfd, (bfd_size_type) strlen (strings) + 1);
 	  if (name == NULL)
-	    return FALSE;
+	    return NULL;
 	  strcpy (name, strings);
 	}
     }
@@ -91,14 +117,14 @@
       /* Assorted wastage to null-terminate the name, thanks AT&T! */
       name = bfd_alloc (abfd, (bfd_size_type) sizeof (hdr->s_name) + 1);
       if (name == NULL)
-	return FALSE;
+	return NULL;
       strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
       name[sizeof (hdr->s_name)] = 0;
     }
 
   return_section = bfd_make_section_anyway (abfd, name);
   if (return_section == NULL)
-    return FALSE;
+    return NULL;
 
   return_section->vma = hdr->s_vaddr;
   return_section->lma = hdr->s_paddr;
@@ -117,10 +143,9 @@
   return_section->target_index = target_index;
 
   if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,
-					 & flags))
+					 & return_section->flags))
     result = FALSE;
 
-  return_section->flags = flags;
 
   /* At least on i386-coff, the line number count for a shared library
      section must be ignored.  */
@@ -132,14 +157,16 @@
   /* FIXME: should this check 'hdr->s_size > 0'.  */
   if (hdr->s_scnptr != 0)
     return_section->flags |= SEC_HAS_CONTENTS;
-
-  return result;
+  if (!result)
+  	return NULL;
+  else  
+  	return return_section;
 }
 
 /* Read in a COFF object and make it into a BFD.  This is used by
    ECOFF as well.  */
 
-static const bfd_target *
+const bfd_target *
 coff_real_object_p (bfd *abfd,
 		    unsigned nscns,
 		    struct internal_filehdr *internal_f,
@@ -153,6 +180,10 @@
   unsigned int scnhsz;
   char *external_sections;
 
+#ifdef DYNAMIC_LINKING
+  bfd_boolean dynamic;
+#endif
+
   if (!(internal_f->f_flags & F_RELFLG))
     abfd->flags |= HAS_RELOC;
   if ((internal_f->f_flags & F_EXEC))
@@ -182,6 +213,14 @@
   if (tdata == NULL)
     goto fail2;
 
+#ifdef DYNAMIC_LINKING
+  dynamic = (abfd->flags & DYNAMIC) != 0;
+
+  if (dynamic)
+    dyn_data(abfd) =
+      (struct dynamic_info *) bfd_zalloc(abfd, sizeof (struct dynamic_info));
+#endif
+
   scnhsz = bfd_coff_scnhsz (abfd);
   readsize = (bfd_size_type) nscns * scnhsz;
   external_sections = bfd_alloc (abfd, readsize);
@@ -200,16 +239,105 @@
   if (nscns != 0)
     {
       unsigned int i;
+#ifdef DYNAMIC_LINKING
+      asection *sec;
+      const char *name;
+      coff_coffsections(abfd) = 
+	  (asection **)bfd_alloc(abfd, sizeof(asection *) * nscns);
+#endif
+
       for (i = 0; i < nscns; i++)
 	{
 	  struct internal_scnhdr tmp;
 	  bfd_coff_swap_scnhdr_in (abfd,
 				   (void *) (external_sections + i * scnhsz),
 				   (void *) & tmp);
-	  if (! make_a_section_from_file (abfd, &tmp, i + 1))
+#ifdef DYNAMIC_LINKING /* [ */
+	  sec = make_a_section_from_file (abfd, &tmp, i + 1);
+
+	  if (sec == NULL)
 	    goto fail;
+
+	  coff_coffsections(abfd)[i] = sec;
+
+	  if (dynamic)
+	    {
+	      name=bfd_get_section_name(abfd, sec);
+
+	      /* we need quick access to certain sections, so we do the name
+		 lookup once, and some other housekeeping along the way. */
+
+	      if (strcmp(name, ".dynamic") == 0)
+		{
+		  coff_dynamic(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".dynsym") == 0)
+		{
+		  coff_dynsymtab(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
 	}
+	      else if (strcmp(name, ".dynstr") == 0)
+		{
+		  coff_dynstrtab(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".gnu.version_d") == 0)
+		{
+		  coff_dynverdef(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
     }
+	      else if (strcmp(name, ".gnu.version_r") == 0)
+		{
+		  coff_dynverref(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".gnu.version") == 0)
+		{
+		  coff_dynversym(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	    }
+
+#else /* ][ */
+	  
+	  if ( make_a_section_from_file (abfd, &tmp, i + 1) == NULL)
+	    goto fail;
+#endif
+	}
+    }
+#ifdef DYNAMIC_LINKING
+  if (dynamic)
+    {
+      if (coff_dynamic(abfd) != NULL && coff_dynstrtab(abfd) != NULL)
+	  coff_dynamic(abfd)->link_index = coff_dynstrtab(abfd)->index;
+
+      if (coff_dynsymtab(abfd) != NULL && coff_dynstrtab(abfd) != NULL)
+	  coff_dynsymtab(abfd)->link_index = coff_dynstrtab(abfd)->index;
+
+      if (coff_dynverdef(abfd) != NULL && coff_dynversym(abfd) != NULL)
+	  coff_dynverdef(abfd)->link_index = coff_dynversym(abfd)->index;
+    }
+#endif
+
 
   return abfd->xvec;
 
@@ -296,7 +424,9 @@
 asection *
 coff_section_from_bfd_index (bfd *abfd, int index)
 {
+#ifndef DYNAMIC_LINKING
   struct bfd_section *answer = abfd->sections;
+#endif
 
   if (index == N_ABS)
     return bfd_abs_section_ptr;
@@ -305,6 +435,14 @@
   if (index == N_DEBUG)
     return bfd_abs_section_ptr;
 
+#ifdef DYNAMIC_LINKING
+  /* range check; special negatives were eliminated above */
+  if (index < 0 || index > (int)abfd->section_count)
+    return bfd_und_section_ptr;
+
+  return coff_coffsections(abfd)[index-1];
+#else
+
   while (answer)
     {
       if (answer->target_index == index)
@@ -315,6 +453,7 @@
   /* We should not reach this point, but the SCO 3.2v4 /lib/libc_s.a
      has a bad symbol table in biglitpow.o.  */
   return bfd_und_section_ptr;
+#endif
 }
 
 /* Get the upper bound of a COFF symbol table.  */
@@ -350,6 +489,16 @@
   return bfd_get_symcount (abfd);
 }
 
+/*
+ * FIXME
+ * mayank@14th June, 2007
+ * This function satisfies new vector introduced in 2.17
+ * check what this does and put appropriate code
+ */
+long coff_get_synthetic_symtab(bfd *abfd, long l1, struct bfd_symbol **asym1, long l2, struct bfd_symbol **asym2,struct bfd_symbol **asym3)
+{
+	return _bfd_nodynamic_get_synthetic_symtab(abfd,l1,asym1,l2,asym2,asym3);
+}
 /* Get the name of a symbol.  The caller must pass in a buffer of size
    >= SYMNMLEN + 1.  */
 
@@ -556,7 +705,7 @@
 }
 
 static void
-fixup_symbol_value (bfd *abfd,
+fixup_symbol_value (bfd *abfd ATTRIBUTE_UNUSED,
 		    coff_symbol_type *coff_symbol_ptr,
 		    struct internal_syment *syment)
 {
@@ -587,13 +736,10 @@
 
 	  syment->n_value = (coff_symbol_ptr->symbol.value
 			     + coff_symbol_ptr->symbol.section->output_offset);
-	  if (! obj_pe (abfd))
-            {
               syment->n_value += (syment->n_sclass == C_STATLAB)
                 ? coff_symbol_ptr->symbol.section->output_section->lma
                 : coff_symbol_ptr->symbol.section->output_section->vma;
             }
-	}
       else
 	{
 	  BFD_ASSERT (0);
@@ -1001,9 +1147,8 @@
       native->u.syment.n_scnum =
 	symbol->section->output_section->target_index;
       native->u.syment.n_value = (symbol->value
+				  + symbol->section->output_section->vma
 				  + symbol->section->output_offset);
-      if (! obj_pe (abfd))
-	native->u.syment.n_value += symbol->section->output_section->vma;
 
       /* Copy the any flags from the file header into the symbol.
          FIXME: Why?  */
@@ -1018,7 +1163,7 @@
   if (symbol->flags & BSF_LOCAL)
     native->u.syment.n_sclass = C_STAT;
   else if (symbol->flags & BSF_WEAK)
-    native->u.syment.n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
+    native->u.syment.n_sclass = C_WEAKEXT;
   else
     native->u.syment.n_sclass = C_EXT;
   native->u.syment.n_numaux = 0;
@@ -1863,7 +2008,8 @@
 coff_print_symbol (bfd *abfd,
 		   void * filep,
 		   asymbol *symbol,
-		   bfd_print_symbol_type how)
+		   bfd_print_symbol_type how,
+		   asymbol *base)
 {
   FILE * file = (FILE *) filep;
 
@@ -1885,8 +2031,8 @@
 	  bfd_vma val;
 	  unsigned int aux;
 	  combined_entry_type *combined = coffsymbol (symbol)->native;
-	  combined_entry_type *root = obj_raw_syments (abfd);
 	  struct lineno_cache_entry *l = coffsymbol (symbol)->lineno;
+	  combined_entry_type *root = coffsymbol(base)->native;
 
 	  fprintf (file, "[%3ld]", (long) (combined - root));
 
@@ -2298,9 +2443,8 @@
 	  native->u.syment.n_scnum =
 	    symbol->section->output_section->target_index;
 	  native->u.syment.n_value = (symbol->value
+			  	      + symbol->section->output_section->vma
 				      + symbol->section->output_offset);
-	  if (! obj_pe (abfd))
-	    native->u.syment.n_value += symbol->section->output_section->vma;
 
 	  /* Copy the any flags from the file header into the symbol.
 	     FIXME: Why?  */
@@ -2315,6 +2459,498 @@
   return TRUE;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
+
+long
+coff_get_dynamic_symtab_upper_bound (abfd)
+     bfd *abfd;
+{
+  long symcount;
+  long symtab_size;
+  asection *hdr;
+
+  hdr = coff_dynsymtab(abfd);
+
+  if (hdr == NULL)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  symcount = bfd_section_size(abfd, hdr) / bfd_coff_symesz (abfd);
+  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
+
+  return symtab_size;
+}
+
+long
+coff_canonicalize_dynamic_symtab (abfd, alocation)
+     bfd *abfd;
+     asymbol **alocation;
+{
+  unsigned long size;
+  unsigned long strtab_size;
+  asection *dynsym;
+  asection *dynstr;
+  char *raw_src;
+  char *raw_end;
+  int sym_count;
+  bfd_size_type symesz;
+  char *string_table = NULL;
+  coff_symbol_type *cached_area;
+  int syt_index = 0;
+  combined_entry_type *isyms;
+  combined_entry_type *internal;
+  combined_entry_type *symbol_ptr;
+  unsigned int n_tmask;
+  unsigned int n_btshft;
+  unsigned int n_btmask;
+  int i;
+
+
+  n_tmask = coff_data (abfd)->local_n_tmask;
+  n_btshft = coff_data (abfd)->local_n_btshft;
+  n_btmask = coff_data (abfd)->local_n_btmask;
+
+  symesz = bfd_coff_symesz (abfd);
+
+  /* First get the dynamic symbol table */
+  dynsym = coff_dynsymtab(abfd);
+
+  if (dynsym == NULL) 
+     return 0;
+
+  sym_count = dynsym->info_r;
+
+  if (sym_count == 0)
+     return 0;
+
+  size = sym_count * symesz;
+
+  raw_src = (PTR) bfd_malloc (size);
+  if (raw_src == NULL)
+     return -1;
+  
+  if (! bfd_get_section_contents (abfd, dynsym, raw_src, (file_ptr) 0, size))
+     return -1;
+
+  /* mark the end of the symbols */
+  raw_end = (char *) raw_src + sym_count * symesz;
+
+  dynstr = coff_dynstrtab(abfd);
+
+  string_table = NULL;
+  strtab_size = 0;
+
+  if (dynstr != NULL)
+    {
+      strtab_size = bfd_section_size(abfd, dynstr); 
+      if (strtab_size == 0) abort();
+      string_table = (PTR) bfd_malloc (strtab_size);
+      if (string_table == NULL)
+          return -1;
+  
+      if (! bfd_get_section_contents (abfd, dynstr, string_table, 
+	      (file_ptr) 0, strtab_size))
+	return -1;
+    }
+
+  /* Allocate enough room for all the symbols in cached form */
+  cached_area = (coff_symbol_type *)
+	 bfd_alloc (abfd, (sym_count * sizeof (coff_symbol_type)));
+
+  if (cached_area == NULL)
+    return -1;
+
+  internal = isyms = (combined_entry_type *)
+	 bfd_alloc (abfd, (sym_count * sizeof (combined_entry_type)));
+
+  if (isyms == NULL)
+    return -1;
+
+  /* Swap all the raw entries */
+  for (; raw_src < raw_end; raw_src += symesz)
+    {
+      coff_symbol_type *dst = &cached_area[syt_index];
+
+      bfd_coff_swap_sym_in (abfd, (PTR) raw_src, (PTR)&isyms->u.syment);
+
+      /* canonicalize the name; can't use other code because it's from
+	 the dynamic symbol table here. */
+      if (isyms->u.syment._n._n_n._n_zeroes != 0)
+	{
+	  /* This is a "short" name.  Make it long.  */
+	  unsigned long i = 0;
+	  char *newstring = NULL;
+
+	  /* find the length of this string without walking into memory
+	     that isn't ours.  */
+	  for (i = 0; i < 8; ++i)
+	    {
+	      if (isyms->u.syment._n._n_name[i] == '\0')
+		{
+		  break;
+		}		/* if end of string */
+	    }		/* possible lengths of this string. */
+
+	  if ((newstring = (PTR) bfd_alloc (abfd, ++i)) == NULL)
+	    return -1;
+	  memset (newstring, 0, i);
+	  strncpy (newstring, isyms->u.syment._n._n_name, i - 1);
+	  isyms->u.syment._n._n_n._n_offset = (long int) newstring;
+	  isyms->u.syment._n._n_n._n_zeroes = 0;
+	}
+      else if (isyms->u.syment._n._n_n._n_offset == 0)
+	isyms->u.syment._n._n_n._n_offset = (long int) "";
+      else
+	{
+	  /* Long name already.  Point symbol at the string in the
+	     table.  */
+	  if (string_table == NULL)
+	    {
+		return -1;
+	    }
+	  if ((unsigned long)isyms->u.syment._n._n_n._n_offset > strtab_size
+	     || isyms->u.syment._n._n_n._n_offset < 0)
+	    {
+	        isyms->u.syment._n._n_n._n_offset = (int)"BAD SYMBOL";
+	    }
+	  isyms->u.syment._n._n_n._n_offset =
+	    ((long int)
+	     (string_table
+	      + isyms->u.syment._n._n_n._n_offset));
+	}
+
+      bfd_coff_canonicalize_one_symbol(abfd, isyms, dst);
+
+      alocation[syt_index] = (asymbol *)dst;
+
+      /* Because of C_NT_WEAK n_numaux isn't always zero. */
+      symbol_ptr = isyms;
+      for (i = 0;
+	   i < isyms->u.syment.n_numaux;
+	   i++)
+	{
+	  raw_src += symesz;
+	  isyms++;
+	  bfd_coff_swap_aux_in (abfd, (PTR) raw_src,
+				symbol_ptr->u.syment.n_type,
+				symbol_ptr->u.syment.n_sclass,
+				i, symbol_ptr->u.syment.n_numaux,
+				&(isyms->u.auxent));
+	  coff_pointerize_aux (abfd, internal, symbol_ptr, i,
+			       isyms);
+         syt_index += 1;
+	  alocation[syt_index] = NULL;
+	}
+      syt_index += 1;
+      isyms++;
+    }				/* bfdize the native symtab */
+
+  return syt_index; 
+} 			/* coff_canonicalize_dynamic_symtab() */
+
+
+/* Return the size required for the dynamic reloc entries.  Any
+   section that was actually installed in the BFD, and has type
+   SHT_REL or SHT_RELA, and uses the dynamic symbol table, is
+   considered to be a dynamic reloc section.  */
+
+long
+coff_get_dynamic_reloc_upper_bound (abfd)
+     bfd *abfd;
+{
+  long ret;
+  asection *s;
+
+  if (dyn_data (abfd) == 0)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  ret = sizeof (arelent *);
+  for (s = abfd->sections; s != NULL; s = s->next)
+   if (strncmp(s->name, ".rel.", 5) == 0)
+      {
+          ret += ((pei_section_data(abfd,s)->virt_size 
+		   / bfd_coff_relsz(abfd)) * sizeof (arelent *));
+      }
+
+  return ret;
+}
+
+/* A special case that assures that the first slot is used, so "real"
+   entries can assume the offset is not zero; only some stringtabs
+   (.dynstr and others derived from ELF) rely on this assumption, and
+   it could be removed, but it'd take more hunting than it's worth. */
+struct bfd_strtab_hash *
+_bfd_coff_stringtab_init ()
+{
+  struct bfd_strtab_hash *ret;
+
+  ret = _bfd_stringtab_init ();
+  if (ret != NULL)
+    {
+      bfd_size_type loc;
+
+      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
+      BFD_ASSERT (loc == 0 || loc == (bfd_size_type) -1);
+      if (loc == (bfd_size_type) -1)
+        {
+          _bfd_stringtab_free (ret);
+          ret = NULL;
+        }
+    }
+  return ret;
+}
+
+/* get a string-table section */
+char *
+bfd_coff_get_str_section (abfd, shindex)
+     bfd * abfd;
+     unsigned int shindex;
+{
+  asection **i_shdrp;
+  char *shstrtab = NULL;
+  unsigned int shstrtabsize;
+  asection *sec;
+
+  i_shdrp = coff_coffsections (abfd);
+  if (i_shdrp == 0 || i_shdrp[shindex] == 0)
+    return 0;
+
+  sec = i_shdrp[shindex];
+  shstrtab = (char *) sec->contents;
+
+  if (shstrtab == NULL)
+    {
+      /* No cached one, attempt to read, and cache what we read. */
+
+      shstrtabsize = bfd_section_size(abfd, sec);
+      shstrtab = (char *) bfd_malloc (shstrtabsize);
+      if (shstrtab == NULL)
+	 return NULL;
+  
+      if (! bfd_get_section_contents (abfd, sec, shstrtab, 
+	      (file_ptr) 0, shstrtabsize))
+	 return NULL;
+
+      sec->contents = (PTR) shstrtab;
+    }
+  return shstrtab;
+}
+
+/* This is how we pick strings out of a string table section;
+   not used for the main coff string table. */
+char *
+bfd_coff_string_from_coff_section (abfd, shindex, strindex)
+     bfd * abfd;
+     unsigned int shindex;
+     unsigned int strindex;
+{
+  asection *hdr;
+
+  if (strindex == 0)
+    return "";
+
+  hdr = coff_coffsections (abfd)[shindex];
+
+  if (hdr->contents == NULL
+      && bfd_coff_get_str_section (abfd, shindex) == NULL)
+    return NULL;
+
+  return ((char *) hdr->contents) + strindex;
+}
+
+
+/* Read in the version information.  */
+
+bfd_boolean
+_bfd_coff_slurp_version_tables (abfd)
+     bfd *abfd;
+{
+  bfd_byte *contents = NULL;
+
+  if (coff_dynverdef (abfd) != 0)
+    {
+      asection *hdr;
+      coff_external_verdef *everdef;
+      coff_internal_verdef *iverdef;
+      unsigned int i;
+
+      hdr = coff_dynverdef(abfd);
+
+      dyn_data (abfd)->verdef =
+	((coff_internal_verdef *)
+	 bfd_zalloc (abfd, hdr->info_r * sizeof (coff_internal_verdef)));
+      if (dyn_data (abfd)->verdef == NULL)
+	goto error_return;
+
+      dyn_data (abfd)->cverdefs = hdr->info_r;
+
+      contents = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, hdr));
+      if (contents == NULL)
+	goto error_return;
+
+      if (!bfd_get_section_contents (abfd, hdr, contents,
+	  (file_ptr) 0, bfd_section_size(abfd, hdr)))
+        goto error_return;
+
+      everdef = (coff_external_verdef *) contents;
+      iverdef = dyn_data (abfd)->verdef;
+      for (i = 0; i < hdr->info_r; i++, iverdef++)
+	{
+	  coff_external_verdaux *everdaux;
+	  coff_internal_verdaux *iverdaux;
+	  unsigned int j;
+
+	  bfd_coff_swap_verdef_in (abfd, everdef, iverdef);
+
+	  iverdef->vd_bfd = abfd;
+
+	  iverdef->vd_auxptr = ((coff_internal_verdaux *)
+				bfd_alloc (abfd,
+					   (iverdef->vd_cnt
+					    * sizeof (coff_internal_verdaux))));
+	  if (iverdef->vd_auxptr == NULL)
+	    goto error_return;
+
+	  everdaux = ((coff_external_verdaux *)
+		      ((bfd_byte *) everdef + iverdef->vd_aux));
+	  iverdaux = iverdef->vd_auxptr;
+	  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
+	    {
+	      bfd_coff_swap_verdaux_in (abfd, everdaux, iverdaux);
+
+	      iverdaux->vda_nodename =
+		bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+						 iverdaux->vda_name);
+	      if (iverdaux->vda_nodename == NULL)
+		goto error_return;
+
+	      if (j + 1 < iverdef->vd_cnt)
+		iverdaux->vda_nextptr = iverdaux + 1;
+	      else
+		iverdaux->vda_nextptr = NULL;
+
+	      everdaux = ((coff_external_verdaux *)
+			  ((bfd_byte *) everdaux + iverdaux->vda_next));
+	    }
+
+	  iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;
+
+	  if (i + 1 < hdr->info_r)
+	    iverdef->vd_nextdef = iverdef + 1;
+	  else
+	    iverdef->vd_nextdef = NULL;
+
+	  everdef = ((coff_external_verdef *)
+		     ((bfd_byte *) everdef + iverdef->vd_next));
+	}
+
+      free (contents);
+      contents = NULL;
+    }
+
+  if (coff_dynverref (abfd) != 0)
+    {
+      asection *hdr;
+      coff_external_verneed *everneed;
+      coff_internal_verneed *iverneed;
+      unsigned int i;
+
+      hdr = coff_dynverref(abfd);
+
+      dyn_data (abfd)->verref =
+	((coff_internal_verneed *)
+	 bfd_zalloc (abfd, hdr->info_r * sizeof (coff_internal_verneed)));
+      if (dyn_data (abfd)->verref == NULL)
+	goto error_return;
+
+      dyn_data (abfd)->cverrefs = hdr->info_r;
+
+      contents = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, hdr));
+      if (contents == NULL)
+	goto error_return;
+
+      if (!bfd_get_section_contents (abfd, hdr, contents,
+	  (file_ptr) 0, bfd_section_size(abfd, hdr)))
+        goto error_return;
+
+      everneed = (coff_external_verneed *) contents;
+      iverneed = dyn_data (abfd)->verref;
+      for (i = 0; i < hdr->info_r; i++, iverneed++)
+	{
+	  coff_external_vernaux *evernaux;
+	  coff_internal_vernaux *ivernaux;
+	  unsigned int j;
+
+	  bfd_coff_swap_verneed_in (abfd, everneed, iverneed);
+
+	  iverneed->vn_bfd = abfd;
+
+	  iverneed->vn_filename =
+	    bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+					     iverneed->vn_file);
+	  if (iverneed->vn_filename == NULL)
+	    goto error_return;
+
+	  iverneed->vn_auxptr =
+	    ((coff_internal_vernaux *)
+	     bfd_alloc (abfd,
+			iverneed->vn_cnt * sizeof (coff_internal_vernaux)));
+
+	  evernaux = ((coff_external_vernaux *)
+		      ((bfd_byte *) everneed + iverneed->vn_aux));
+	  ivernaux = iverneed->vn_auxptr;
+	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
+	    {
+	      bfd_coff_swap_vernaux_in (abfd, evernaux, ivernaux);
+
+	      ivernaux->vna_nodename =
+		bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+						 ivernaux->vna_name);
+	      if (ivernaux->vna_nodename == NULL)
+		goto error_return;
+
+	      if (j + 1 < iverneed->vn_cnt)
+		ivernaux->vna_nextptr = ivernaux + 1;
+	      else
+		ivernaux->vna_nextptr = NULL;
+
+	      evernaux = ((coff_external_vernaux *)
+			  ((bfd_byte *) evernaux + ivernaux->vna_next));
+	    }
+
+	  if (i + 1 < hdr->info_r)
+	    iverneed->vn_nextref = iverneed + 1;
+	  else
+	    iverneed->vn_nextref = NULL;
+
+	  everneed = ((coff_external_verneed *)
+		      ((bfd_byte *) everneed + iverneed->vn_next));
+	}
+
+      free (contents);
+      contents = NULL;
+    }
+
+  return TRUE;
+
+ error_return:
+  if (contents == NULL)
+    free (contents);
+  return FALSE;
+}
+#endif /* ] */
+
 struct coff_comdat_info *
 bfd_coff_get_comdat_section (bfd *abfd, struct bfd_section *sec)
 {
diff -ruNbB binutils-2.17/bfd/cofflink.c binutils-2.17.sua/bfd/cofflink.c
--- binutils-2.17/bfd/cofflink.c	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/cofflink.c	2008-04-01 09:03:07 +0200
@@ -29,16 +29,50 @@
 #include "libcoff.h"
 #include "safe-ctype.h"
 
+#if defined(DYNAMIC_LINKING) && defined(USE_DLLS)
+/* DLL's require some special treatment.  There are two problems: the
+   "mechanism" symbols (e.g. __IMPORT_DESCRIPTOR_*) cannot be allowed
+   out of the the shared libs, as they will mess up subsequent links
+   against the same DLL.  (__imp_ symbols may or may not also fall under
+   this, but for different reasons.)
+
+   Secondly, it's not clear whether we want to export the DLL symbols
+   at all: do we wish to be able to override them at runtime?  If we don't
+   export, they cannot be overridden at runtime.  (This is very like
+   a "symbolic" link, except that they're not callable, either.)
+
+   Current decision: don't export any DLL symbols.  If/when we want to
+   export them, USE_DLLS should be used as a guide; mostly, that change
+   implies turning off the define.  However, a filter to remove the mechanism
+   symbols, and possibly the __imp_ symbols, needs to be added.
+   (The symbolic flag may still need to be involved?)
+
+   The runtime linker may want the __imp_ symbols to handle double
+   thunks that occur when a .so calls a DLL, and the DLL symbols were
+   provided in the main program.
+
+   Note: currently, if is_DLL_module doesn't get set, it's equivalent
+   to never recognizing that a symbol is a DLL symbol.  */
+#endif
+
 static bfd_boolean coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info);
 static bfd_boolean coff_link_check_archive_element (bfd *abfd, struct bfd_link_info *info, bfd_boolean *pneeded);
 static bfd_boolean coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info);
 
 /* Return TRUE if SYM is a weak, external symbol.  */
 #define IS_WEAK_EXTERNAL(abfd, sym)			\
-  ((sym).n_sclass == C_WEAKEXT				\
-   || (obj_pe (abfd) && (sym).n_sclass == C_NT_WEAK))
+    ((sym).n_sclass == C_WEAKEXT)
+static bfd_boolean coff_merge_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, const char *, 
+	   struct internal_syment *,
+	   enum coff_symbol_classification,
+	   asection **, bfd_vma *, struct coff_link_hash_entry **,
+	   bfd_boolean, bfd_boolean *, bfd_boolean *, bfd_boolean *));
+
+/* Return TRUE if SYM is a weak, external symbol. C_NT_WEAK, being really
+   an alias, should not be tested for this way because it almost always
+   is wrong. */
 
-/* Return TRUE if SYM is an external symbol.  */
 #define IS_EXTERNAL(abfd, sym)				\
   ((sym).n_sclass == C_EXT || IS_WEAK_EXTERNAL (abfd, sym))
 
@@ -82,6 +116,27 @@
       ret->numaux = 0;
       ret->auxbfd = NULL;
       ret->aux = NULL;
+#ifdef DYNAMIC_LINKING
+      ret->dynindx = -1;
+      ret->dynstr_index = 0;
+#ifdef USE_WEAK
+      ret->weakdef = NULL;
+#endif
+      ret->got_offset = -1;
+      ret->plt_offset = -1;
+      ret->coff_link_hash_flags = 0;
+      ret->num_long_relocs_needed = 0;
+      ret->num_relative_relocs_needed = 0;
+#ifdef USE_SIZE
+      ret->size = 0;
+#endif
+      ret->verinfo.verdef = NULL;
+      /* Assume that we have been called by a non-COFF symbol reader.
+         This flag is then reset by the code which reads a COFF input
+         file.  This ensures that a symbol created by a non-COFF symbol
+         reader will have the flag set correctly.  */
+      ret->coff_link_hash_flags = COFF_LINK_NON_COFF;
+#endif
     }
 
   return (struct bfd_hash_entry *) ret;
@@ -98,6 +153,20 @@
 				unsigned int entsize)
 {
   memset (&table->stab_info, 0, sizeof (table->stab_info));
+#ifdef DYNAMIC_LINKING
+  table->dynamic_sections_created = FALSE;
+  table->dynobj = NULL;
+  table->dynsymcount = 1; /* Dummy entry for special info. */
+  table->dynstr = NULL;
+  table->needed = NULL;
+  table->hgot = NULL;
+  table->sreloc = NULL;
+  table->sgot = NULL;
+  table->sgotplt = NULL;
+  table->srelgot = NULL;
+  table->dynamic = NULL;
+#endif
+
   return _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);
 }
 
@@ -173,6 +242,478 @@
     }
 }
 
+/* This function is called when we want to define a new symbol.  It
+   handles the various cases which arise when we find a definition in
+   a dynamic object, or when there is already a definition in a
+   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
+   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
+   OVERRIDE if the old symbol is overriding a new definition.  We set
+   TYPE_CHANGE_OK if it is OK for the type to change.  We set
+   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
+   change, we mean that we shouldn't warn if the type or size does
+   change.  */
+
+static bfd_boolean
+coff_merge_symbol (abfd, info, name, sym, classification, psec, pvalue, 
+                  sym_hash, copy, override, type_change_ok, size_change_ok)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     const char *name;
+     struct internal_syment *sym;
+     enum coff_symbol_classification classification;
+     asection **psec;
+     bfd_vma *pvalue ATTRIBUTE_UNUSED;
+     struct coff_link_hash_entry **sym_hash;
+     bfd_boolean copy;
+     bfd_boolean *override;
+     bfd_boolean *type_change_ok;
+     bfd_boolean *size_change_ok;
+{
+  asection *sec;
+  struct coff_link_hash_entry *h;
+  struct coff_link_hash_entry *h_real;
+  bfd_boolean new_is_weak;
+  bfd_boolean old_is_weak_def;
+  bfd *oldbfd;
+  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
+
+  unsigned int n_tmask = coff_data (abfd)->local_n_tmask;
+  unsigned int n_btshft = coff_data (abfd)->local_n_btshft;
+
+  *override = FALSE;
+
+  sec = *psec;
+
+  if (! bfd_is_und_section (sec))
+    h = coff_link_hash_lookup 
+	  (coff_hash_table (info), name, TRUE, copy, FALSE);
+  else
+    h = ((struct coff_link_hash_entry *)
+	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
+
+  if (h == NULL)
+    return FALSE;
+
+  *sym_hash = h;
+
+  /* This code is for coping with dynamic objects, and is only useful
+     if we are doing an COFF link.  */
+  if (abfd->xvec != info->hash->creator
+     && abfd->xvec != info->hash->creator->input_format)
+    return TRUE;
+
+  /* For merging, we only care about real symbols.
+
+     For PE Weaks, we work on the alias name.  (Weakness is a 
+     property of the alias.) */
+  while ((h->root.type == bfd_link_hash_indirect
+	   && !h->root.u.i.info.alias)
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    {
+      /* Implicitly it's an alias! */
+      old_is_weak_def = TRUE;
+    }
+  else
+    old_is_weak_def = (h->root.type == bfd_link_hash_defweak);
+
+  new_is_weak = sym->n_sclass == C_WEAKEXT
+	  || (obj_pe (abfd) && sym->n_sclass == C_NT_WEAK);
+
+
+  /* If we just created the symbol, mark it as being a COFF symbol.
+     Other than that, there is nothing to do--there is no merge issue
+     with a newly defined symbol--so we just return.  */
+
+  if (h->root.type == bfd_link_hash_new)
+    {
+      h->coff_link_hash_flags &= ~COFF_LINK_NON_COFF;
+      return TRUE;
+    }
+
+  /* OLDBFD is a BFD associated with the existing symbol.  For 
+     indirects and warnings, we'll get it from the real symbol. 
+     Don't care if it's an alias or not. */
+  h_real = h;
+  while (h_real->root.type == bfd_link_hash_indirect
+	 || h_real->root.type == bfd_link_hash_warning)
+    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+  switch (h_real->root.type)
+    {
+    default:
+      oldbfd = NULL;
+      break;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      oldbfd = h_real->root.u.undef.abfd;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      oldbfd = h_real->root.u.def.section->owner;
+      break;
+
+    case bfd_link_hash_common:
+      oldbfd = h_real->root.u.c.p->section->owner;
+      break;
+    }
+
+  /* In cases involving weak versioned symbols, we may wind up trying
+     to merge a symbol with itself.  Catch that here, to avoid the
+     confusion that results if we try to override a symbol with
+     itself.  The additional tests catch cases like
+     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
+     dynamic object, which we do want to handle here.  */
+  if (abfd == oldbfd
+      && ((abfd->flags & DYNAMIC) == 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0))
+    return TRUE;
+
+  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
+     respectively, is from a dynamic object.  */
+
+  if ((abfd->flags & DYNAMIC) != 0)
+    newdyn = TRUE;
+  else
+    newdyn = FALSE;
+
+  if (oldbfd != NULL)
+    olddyn = (oldbfd->flags & DYNAMIC) != 0;
+  else
+    {
+      /* This should be a pretty rare event.  Imposible? */
+      olddyn = FALSE;
+    }
+
+  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
+     respectively, appear to be a definition rather than reference.  */
+
+  newdef = (classification == COFF_SYMBOL_GLOBAL);
+
+  if (h->root.type == bfd_link_hash_undefined
+      || h->root.type == bfd_link_hash_undefweak
+      || h->root.type == bfd_link_hash_common)
+    olddef = FALSE;
+  else
+    olddef = TRUE;
+
+  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
+     symbol, respectively, appears to be a common symbol in a dynamic
+     object.  If a symbol appears in an uninitialized section, and is
+     not weak, and is not a function, then it may be a common symbol
+     which was resolved when the dynamic object was created.  We want
+     to treat such symbols specially, because they raise special
+     considerations when setting the symbol size: if the symbol
+     appears as a common symbol in a regular object, and the size in
+     the regular object is larger, we must make sure that we use the
+     larger size.  This problematic case can always be avoided in C,
+     but it must be handled correctly when using Fortran shared
+     libraries.
+
+     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
+     likewise for OLDDYNCOMMON and OLDDEF.
+
+     Note that this test is just a heuristic, and that it is quite
+     possible to have an uninitialized symbol in a shared object which
+     is really a definition, rather than a common symbol.  This could
+     lead to some minor confusion when the symbol really is a common
+     symbol in some regular object.  However, I think it will be
+     harmless.  */
+
+  if (newdyn
+      && newdef
+      && (sec->flags & SEC_ALLOC) != 0
+      && (sec->flags & SEC_LOAD) == 0
+#ifdef USE_SIZE
+      && sym->st_size > 0
+#endif
+      && !new_is_weak
+      && !ISFCN(sym->n_type))
+    newdyncommon = TRUE;
+  else
+    newdyncommon = FALSE;
+
+  if (olddyn
+      && olddef
+      && h->root.type == bfd_link_hash_defined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
+      && (h->root.u.def.section->flags & SEC_LOAD) == 0
+#ifdef USE_SIZE
+      && h->size > 0
+#endif
+      && !ISFCN(h->type))
+    olddyncommon = TRUE;
+  else
+    olddyncommon = FALSE;
+
+  /* It's OK to change the type if either the existing symbol or the
+     new symbol is weak.  */
+
+  if (old_is_weak_def
+      || h->root.type == bfd_link_hash_undefweak
+      || new_is_weak)
+    *type_change_ok = TRUE;
+
+  /* It's OK to change the size if either the existing symbol or the
+     new symbol is weak, or if the old symbol is undefined.  */
+
+  if (*type_change_ok
+      || h->root.type == bfd_link_hash_undefined)
+    *size_change_ok = TRUE;
+
+#ifdef USE_SIZE
+  /* If both the old and the new symbols look like common symbols in a
+     dynamic object, set the size of the symbol to the larger of the
+     two.  */
+
+  if (olddyncommon
+      && newdyncommon
+      && sym->st_size != h->size)
+    {
+      /* Since we think we have two common symbols, issue a multiple
+         common warning if desired.  Note that we only warn if the
+         size is different.  If the size is the same, we simply let
+         the old symbol override the new one as normally happens with
+         symbols defined in dynamic objects.  */
+
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return FALSE;
+
+      if (sym->st_size > h->size)
+	h->size = sym->st_size;
+
+      *size_change_ok = TRUE;
+    }
+#endif
+
+  /* If we are looking at a dynamic object, and we have found a
+     definition, we need to see if the symbol was already defined by
+     some other object.  If so, we want to use the existing
+     definition, and we do not want to report a multiple symbol
+     definition error; we do this by clobbering *PSEC to be
+     bfd_und_section_ptr.
+
+     We treat a common symbol as a definition if the symbol in the
+     shared library is a function, since common symbols always
+     represent variables; this can cause confusion in principle, but
+     any such confusion would seem to indicate an erroneous program or
+     shared library.  We also permit a common symbol in a regular
+     object to override a weak symbol in a shared object.
+
+     We prefer a non-weak definition in a shared library to a weak
+     definition in the executable.  */
+
+  if (newdyn
+      && newdef
+      && (olddef
+	  || (h->root.type == bfd_link_hash_common
+	      && (new_is_weak
+                  || ISFCN(sym->n_type))))
+      && (!old_is_weak_def
+	  || new_is_weak))
+    {
+      *override = TRUE;
+      newdef = FALSE;
+      newdyncommon = FALSE;
+
+      *psec = sec = bfd_und_section_ptr;
+      *size_change_ok = TRUE;
+
+      /* If we get here when the old symbol is a common symbol, then
+         we are explicitly letting it override a weak symbol or
+         function in a dynamic object, and we don't want to warn about
+         a type change.  If the old symbol is a defined symbol, a type
+         change warning may still be appropriate.  */
+
+      if (h->root.type == bfd_link_hash_common)
+	*type_change_ok = TRUE;
+    }
+
+  /* Handle the special case of an old common symbol merging with a
+     new symbol which looks like a common symbol in a shared object.
+     We change *PSEC and *PVALUE to make the new symbol look like a
+     common symbol, and let _bfd_generic_link_add_one_symbol will do
+     the right thing.  */
+
+  if (newdyncommon
+      && h->root.type == bfd_link_hash_common)
+    {
+      *override = TRUE;
+      newdef = FALSE;
+      newdyncommon = FALSE;
+#ifdef USE_SIZE
+      *pvalue = sym->st_size;
+#endif
+      *psec = sec = bfd_com_section_ptr;
+      *size_change_ok = TRUE;
+    }
+
+  /* If the old symbol is from a dynamic object, and the new symbol is
+     a definition which is not from a dynamic object, then the new
+     symbol overrides the old symbol.  Symbols from regular files
+     always take precedence over symbols from dynamic objects, even if
+     they are defined after the dynamic object in the link.
+
+     As above, we again permit a common symbol in a regular object to
+     override a definition in a shared object if the shared object
+     symbol is a function or is weak.
+
+     As above, we permit a non-weak definition in a shared object to
+     override a weak definition in a regular object. 
+
+     Elf doesn't permit a strong symbol which follows a weak definition
+     to override the weak definition if shared libs are not involved.
+     We do.  */
+
+  if (! newdyn
+      && (newdef
+	  || (bfd_is_com_section (sec)
+	      && (old_is_weak_def
+                  || ISFCN(h->type))))
+      && olddyn
+      && olddef
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+      && !new_is_weak)
+    {
+      /* Change the hash table entry to undefined, and let
+	 _bfd_generic_link_add_one_symbol do the right thing with the
+	 new definition.  */
+
+      h->root.type = bfd_link_hash_undefined;
+      /* grub the owner (of the target of the alias, really) out
+	 of the alias link.  (Or here, if not an indirect!) */
+      if (h_real->root.type == bfd_link_hash_undefined)
+	h->root.u.undef.abfd = h_real->root.u.undef.abfd;
+      else
+	h->root.u.undef.abfd = h_real->root.u.def.section->owner;
+
+      /* To make this work we have to frob the flags so that the rest
+         of the code does not think we are using the prior type
+	 of definition (regular or dynamic).  Elf doesn't care, but
+	 the relocation counting code is very touchy about this. */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+      else if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_DYNAMIC;
+      h->coff_link_hash_flags &= ~ (COFF_LINK_HASH_DEF_REGULAR
+				   | COFF_LINK_HASH_DEF_DYNAMIC);
+      *size_change_ok = TRUE;
+
+      olddef = FALSE;
+      olddyncommon = FALSE;
+
+      /* We again permit a type change when a common symbol may be
+         overriding a function.  */
+
+      if (bfd_is_com_section (sec))
+	*type_change_ok = TRUE;
+
+      /* This union may have been set to be non-NULL when this symbol
+	 was seen in a dynamic object.  We must force the union to be
+	 NULL, so that it is correct for a regular symbol.  */
+
+      h->verinfo.vertree = NULL;
+
+      /* In this special case, if H is the target of an indirection,
+         we want the caller to frob with H rather than with the
+         indirect symbol.  That will permit the caller to redefine the
+         target of the indirection, rather than the indirect symbol
+         itself.  FIXME: This will break the -y option if we store a
+         symbol with a different name.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a new common symbol merging with an
+     old symbol that looks like it might be a common symbol defined in
+     a shared object.  Note that we have already handled the case in
+     which a new common symbol should simply override the definition
+     in the shared library.  */
+
+  if (! newdyn
+      && bfd_is_com_section (sec)
+      && olddyncommon)
+    {
+      /* It would be best if we could set the hash table entry to a
+	 common symbol, but we don't know what to use for the section
+	 or the alignment.  */
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->root.u.c.size, abfd, bfd_link_hash_common, sym->n_value)))
+	return FALSE;
+
+#ifdef USE_SIZE
+      /* If the presumed common symbol in the dynamic object is
+         larger, pretend that the new symbol has its size.  */
+
+      if (h->size > *pvalue)
+	*pvalue = h->size;
+#endif
+
+      /* FIXME: We no longer know the alignment required by the symbol
+	 in the dynamic object, so we just wind up using the one from
+	 the regular object.  */
+
+      olddef = FALSE;
+      olddyncommon = FALSE;
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+
+      *size_change_ok = TRUE;
+      *type_change_ok = TRUE;
+
+      h->verinfo.vertree = NULL;
+    }
+
+  /* Handle the special case of a weak definition in a regular object
+     followed by a non-weak definition in a shared object.  In this
+     case, we prefer the definition in the shared object.  */
+  if (olddef
+      && old_is_weak_def
+      && newdef
+      && newdyn
+      && !new_is_weak)
+    {
+      /* To make this work we have to frob the flags so that the rest
+         of the code does not think we are using the regular
+         definition.  */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+      else if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_DYNAMIC;
+      h->coff_link_hash_flags &= ~ (COFF_LINK_HASH_DEF_REGULAR
+				   | COFF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If H is the target of an indirection, we want the caller to
+         use H rather than the indirect symbol.  Otherwise if we are
+         defining a new indirect symbol we will wind up attaching it
+         to the entry we are overriding.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a non-weak definition in a shared
+     object followed by a weak definition in a regular object.  In
+     this case we prefer to definition in the shared object.  To make
+     this work we have to tell the caller to not treat the new symbol
+     as a definition.  */
+  if (olddef
+      && olddyn
+      && ! old_is_weak_def
+      && newdef
+      && ! newdyn
+      && new_is_weak)
+    *override = TRUE;
+
+  return TRUE;
+}
+
 /* Add symbols from a COFF object file.  */
 
 static bfd_boolean
@@ -256,6 +797,10 @@
   return TRUE;
 }
 
+#ifdef DYNAMIC_LINKING
+static bfd_boolean coff_link_create_dynamic_sections
+  PARAMS ((bfd *abfd, struct bfd_link_info *info));
+#endif
 /* Check a single archive element to see if we need to include it in
    the link.  *PNEEDED is set according to whether this element is
    needed in the link or not.  This is called via
@@ -300,6 +847,23 @@
   bfd_byte *esym;
   bfd_byte *esym_end;
   bfd_size_type amt;
+  long sym_idx;
+  bfd_boolean size_change_ok, type_change_ok;
+#ifdef DYNAMIC_LINKING
+  bfd_byte *buf = NULL; /* For housekeeping purposes */
+  bfd_boolean dynamic;
+  bfd_boolean using_dynsymtab;
+  asection *dynsym = NULL;
+  char *dynstrings = NULL;
+  coff_external_versym *extversym = NULL;
+  coff_external_versym *ever;
+
+  coff_external_dyn *dynbuf = NULL;
+#ifdef USE_DLLS
+  bfd_boolean is_DLL_module;
+#endif
+#endif
+
 
   /* Keep the symbols during this function, in case the linker needs
      to read the generic symbols in order to report an error message.  */
@@ -310,2736 +874,7216 @@
     default_copy = FALSE;
   else
     default_copy = TRUE;
+#ifdef DYNAMIC_LINKING /* [ */
+#ifdef USE_DLLS
 
-  symcount = obj_raw_syment_count (abfd);
+  /* Properly this belongs in the archive reading code, but since this
+     is the only place that uses it, I'll let locality dominate. */
+  if (bfd_my_archive(abfd) != NULL)
+    {
+       struct dll_info {
+	  bfd_boolean is_DLL;
+       };
+#define ar_dllinfo(abfd) ((struct dll_info *)bfd_my_archive(abfd)->tdata.aout_ar_data->tdata)
+
+       if (ar_dllinfo(abfd) == NULL)
+	 {
+            (bfd_my_archive(abfd)->tdata.aout_ar_data->tdata)
+	       = bfd_alloc(abfd, sizeof(struct dll_info));
+	    if (bfd_my_archive(abfd)->tdata.aout_ar_data->tdata == NULL)
+	       return FALSE;
+            ar_dllinfo(abfd)->is_DLL =
+                     bfd_get_section_by_name (abfd, ".idata$6") != NULL
+                  || bfd_get_section_by_name (abfd, ".idata$2") != NULL
+                  || bfd_get_section_by_name (abfd, ".idata$3") != NULL;
+	 }
+       is_DLL_module = ar_dllinfo(abfd)->is_DLL;
+    }
+  else
+       is_DLL_module = FALSE;
 
-  /* We keep a list of the linker hash table entries that correspond
-     to particular symbols.  */
-  amt = symcount * sizeof (struct coff_link_hash_entry *);
-  sym_hash = bfd_zalloc (abfd, amt);
-  if (sym_hash == NULL && symcount != 0)
-    goto error_return;
-  obj_coff_sym_hashes (abfd) = sym_hash;
+#endif
 
-  symesz = bfd_coff_symesz (abfd);
-  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
-  esym = (bfd_byte *) obj_coff_external_syms (abfd);
-  esym_end = esym + symcount * symesz;
-  while (esym < esym_end)
+  if ((abfd->flags & DYNAMIC) == 0)
+    dynamic = FALSE;
+  else
     {
-      struct internal_syment sym;
-      enum coff_symbol_classification classification;
-      bfd_boolean copy;
+      dynamic = TRUE;
 
-      bfd_coff_swap_sym_in (abfd, esym, &sym);
+      if ((abfd->flags & NO_LINK) != 0)
+	{
+	  (*_bfd_error_handler)
+		(_("%s: Linking with this file is prohibited.\n"), abfd->filename);
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+      /* You can't use -r against a dynamic object.  Also, there's no
+	 hope of using a dynamic object which does not exactly match
+	 the format of the output file.  */
+      /* A PE shared executable is PEI, so this works for PE. */
+      if (info->relocatable || info->hash->creator != abfd->xvec)
+	{
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+    }
 
-      classification = bfd_coff_classify_symbol (abfd, &sym);
-      if (classification != COFF_SYMBOL_LOCAL)
+  /* As a GNU extension, any input sections which are named
+     .gnu.warning.SYMBOL are treated as warning symbols for the given
+     symbol.  This differs from .gnu.warning sections, which generate
+     warnings when they are included in an output file.  */
+  if (! info->shared)
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
 	{
 	  const char *name;
-	  char buf[SYMNMLEN + 1];
-	  flagword flags;
-	  asection *section;
-	  bfd_vma value;
-	  bfd_boolean addit;
 
-	  /* This symbol is externally visible.  */
+	  name = bfd_get_section_name (abfd, s);
+	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
+	    {
+	      char *msg;
+	      bfd_size_type sz;
 
-	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
-	  if (name == NULL)
-	    goto error_return;
+	      name += sizeof ".gnu.warning." - 1;
 
-	  /* We must copy the name into memory if we got it from the
-             syment itself, rather than the string table.  */
-	  copy = default_copy;
-	  if (sym._n._n_n._n_zeroes != 0
-	      || sym._n._n_n._n_offset == 0)
-	    copy = TRUE;
+	      /* If this is a shared object, then look up the symbol
+		 in the hash table.  If it is there, and it is already
+		 been defined, then we will not be using the entry
+		 from this shared object, so we don't need to warn.
+		 FIXME: If we see the definition in a regular object
+		 later on, we will warn, but we shouldn't.  The only
+		 fix is to keep track of what warnings we are supposed
+		 to emit, and then handle them all at the end of the
+		 link.  */
+	      if (dynamic
+		  && (abfd->xvec == info->hash->creator
+		     || abfd->xvec == info->hash->creator->input_format))
+		{
+		  struct coff_link_hash_entry *h;
 
-	  value = sym.n_value;
+		  h = coff_link_hash_lookup (coff_hash_table (info), name,
+					    FALSE, FALSE, TRUE);
 
-	  switch (classification)
+		  /* FIXME: What about bfd_link_hash_common?  */
+		  if (h != NULL
+		      && (h->root.type == bfd_link_hash_defined
+			  || h->root.type == bfd_link_hash_defweak))
 	    {
-	    default:
-	      abort ();
+		      /* We don't want to issue this warning.  Clobber
+                         the section size so that the warning does not
+                         get copied into the output file.  */
+		      s->size = 0;
+		      continue;
+		    }
+		}
 
-	    case COFF_SYMBOL_GLOBAL:
-	      flags = BSF_EXPORT | BSF_GLOBAL;
-	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
-	      if (! obj_pe (abfd))
-		value -= section->vma;
-	      break;
+	      sz = bfd_section_size (abfd, s);
+	      msg = (char *) bfd_alloc (abfd, sz);
+	      if (msg == NULL)
+		goto error_return;
 
-	    case COFF_SYMBOL_UNDEFINED:
-	      flags = 0;
-	      section = bfd_und_section_ptr;
-	      break;
+	      if (! bfd_get_section_contents (abfd, s, msg, (file_ptr) 0, sz))
+		goto error_return;
 
-	    case COFF_SYMBOL_COMMON:
-	      flags = BSF_GLOBAL;
-	      section = bfd_com_section_ptr;
-	      break;
+	      if (! (bfd_coff_link_add_one_symbol
+		     (info, abfd, name, BSF_WARNING, s, (bfd_vma) 0, msg,
+		      FALSE, FALSE,
+		      (struct bfd_link_hash_entry **) NULL)))
+		goto error_return;
 
-	    case COFF_SYMBOL_PE_SECTION:
-	      flags = BSF_SECTION_SYM | BSF_GLOBAL;
-	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
-	      break;
+	      if (! info->relocatable)
+		{
+		  /* Clobber the section size so that the warning does
+                     not get copied into the output file.  */
+		  s->size = 0;
+		}
+	    }
+	}
 	    }
 
-	  if (IS_WEAK_EXTERNAL (abfd, sym))
-	    flags = BSF_WEAK;
 
-	  addit = TRUE;
+  if (dynamic)
+    {
+      /* Read in any version definitions.  */
 
-	  /* In the PE format, section symbols actually refer to the
-             start of the output section.  We handle them specially
-             here.  */
-	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
+      /* Elf now uses a slurp... we could if we needed to. */
+      if (coff_dynverdef (abfd) != 0)
 	    {
-	      *sym_hash = coff_link_hash_lookup (coff_hash_table (info),
-						 name, FALSE, copy, FALSE);
-	      if (*sym_hash != NULL)
+	  asection *verdefhdr;
+	  bfd_byte *dynver;
+	  unsigned int i;
+	  const coff_external_verdef *extverdef;
+	  coff_internal_verdef *intverdef;
+
+	  /* allocate space for the internals */
+	  verdefhdr = coff_dynverdef(abfd);
+	  dyn_data (abfd)->verdef =
+	    ((coff_internal_verdef *)
+	     bfd_zalloc (abfd,
+			 verdefhdr->info_r * sizeof (coff_internal_verdef)));
+	  if (dyn_data (abfd)->verdef == NULL)
+	    goto error_return;
+
+	  /* make temp space for the externals */
+	  dynver = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, verdefhdr));
+	  if (dynver == NULL)
+	    goto error_return;
+
+          if (!bfd_get_section_contents (abfd, verdefhdr, dynver, 
+	      (file_ptr) 0, bfd_section_size(abfd, verdefhdr)))
+	    goto error_return;
+
+	  extverdef = (const coff_external_verdef *) dynver;
+	  intverdef = dyn_data (abfd)->verdef;
+	  for (i = 0; i < verdefhdr->info_r; i++, intverdef++)
 		{
-		  if (((*sym_hash)->coff_link_hash_flags
-		       & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0
-		      && (*sym_hash)->root.type != bfd_link_hash_undefined
-		      && (*sym_hash)->root.type != bfd_link_hash_undefweak)
-		    (*_bfd_error_handler)
-		      ("Warning: symbol `%s' is both section and non-section",
-		       name);
+	      const coff_external_verdaux *extverdaux;
+	      coff_internal_verdaux intverdaux;
 
-		  addit = FALSE;
+	      bfd_coff_swap_verdef_in (abfd, extverdef, intverdef);
+
+	      /* Pick up the name of the version.  */
+	      extverdaux = ((const coff_external_verdaux *)
+			    ((bfd_byte *) extverdef + intverdef->vd_aux));
+	      bfd_coff_swap_verdaux_in (abfd, extverdaux, &intverdaux);
+
+	      intverdef->vd_bfd = abfd;
+	      intverdef->vd_nodename =
+		bfd_coff_string_from_coff_section (abfd, verdefhdr->link_index,
+						 intverdaux.vda_name);
+
+	      extverdef = ((const coff_external_verdef *)
+			   ((bfd_byte *) extverdef + intverdef->vd_next));
 		}
+
+	  free (dynver);
+	  dynver = NULL;
 	    }
 
-	  /* The Microsoft Visual C compiler does string pooling by
-	     hashing the constants to an internal symbol name, and
-	     relying on the linker comdat support to discard
-	     duplicate names.  However, if one string is a literal and
-	     one is a data initializer, one will end up in the .data
-	     section and one will end up in the .rdata section.  The
-	     Microsoft linker will combine them into the .data
-	     section, which seems to be wrong since it might cause the
-	     literal to change.
+      /* Read in the symbol versions, but don't bother to convert them
+         to internal format.  */
+      if (coff_dynversym (abfd) != 0)
+	{
+	  asection *versymhdr;
 
-	     As long as there are no external references to the
-	     symbols, which there shouldn't be, we can treat the .data
-	     and .rdata instances as separate symbols.  The comdat
-	     code in the linker will do the appropriate merging.  Here
-	     we avoid getting a multiple definition error for one of
-	     these special symbols.
+	  versymhdr = coff_dynversym(abfd);
+	  extversym = (coff_external_versym *) 
+	      bfd_malloc (bfd_section_size(abfd, versymhdr));
+	  if (extversym == NULL)
+	    goto error_return;
+          if (!bfd_get_section_contents (abfd, versymhdr, extversym, 
+	      (file_ptr) 0, bfd_section_size(abfd, versymhdr)))
+	    goto error_return;
+	}
+    }
 
-	     FIXME: I don't think this will work in the case where
-	     there are two object files which use the constants as a
-	     literal and two object files which use it as a data
-	     initializer.  One or the other of the second object files
-	     is going to wind up with an inappropriate reference.  */
-	  if (obj_pe (abfd)
-	      && (classification == COFF_SYMBOL_GLOBAL
-		  || classification == COFF_SYMBOL_PE_SECTION)
-	      && coff_section_data (abfd, section) != NULL
-	      && coff_section_data (abfd, section)->comdat != NULL
-	      && strncmp (name, "??_", 3) == 0
-	      && strcmp (name, coff_section_data (abfd, section)->comdat->name) == 0)
+  if (dynamic)
+      symcount = coff_get_dynamic_symtab_upper_bound (abfd);
+    else
+#endif /* ] */
+
+  symcount = obj_raw_syment_count (abfd);
+
+  /* We keep a list of the linker hash table entries that correspond
+     to particular symbols.  */
+  amt = symcount * sizeof (struct coff_link_hash_entry *);
+  sym_hash = bfd_zalloc (abfd, amt);
+  if (sym_hash == NULL && symcount != 0)
+    goto error_return;
+  obj_coff_sym_hashes (abfd) = sym_hash;
+
+  symesz = bfd_coff_symesz (abfd);
+  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If this is a dynamic object, we always link against the .dynsym
+     symbol table, not the main symbol table.  The dynamic linker
+     will only see the .dynsym symbol table, so there is no reason to
+     look at the main one for a dynamic object. 
+
+     This must be done at this point, because if this is the first
+     bfd which is dynamic, the code below will "recycle" it to use
+     it to hold the output dynamic sections, after having tossed
+     the input sections (which, rightly, should not participate
+     in the link.)  */
+
+  if (dynamic) 
+      dynsym = coff_dynsymtab(abfd);
+  if (! dynamic || dynsym == NULL)
 	    {
-	      if (*sym_hash == NULL)
-		*sym_hash = coff_link_hash_lookup (coff_hash_table (info),
-						   name, FALSE, copy, FALSE);
-	      if (*sym_hash != NULL
-		  && (*sym_hash)->root.type == bfd_link_hash_defined
-		  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL
-		  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,
-			     coff_section_data (abfd, section)->comdat->name) == 0)
-		addit = FALSE;
+      esym = (bfd_byte *) obj_coff_external_syms (abfd);
+      esym_end = esym + symcount * symesz;
+      using_dynsymtab = FALSE;
+      sym_idx=0;
 	    }
-
-	  if (addit)
+  else
 	    {
-	      if (! (bfd_coff_link_add_one_symbol
-		     (info, abfd, name, flags, section, value,
-		      (const char *) NULL, copy, FALSE,
-		      (struct bfd_link_hash_entry **) sym_hash)))
+      int size;
+
+      /* We have to get the actual count from the header, rather than dealing
+	 with the size, because we don't have an "actual" size, but rather
+	 a rounded one. */
+      symcount = dynsym->info_r;
+
+      if (symcount == 0)
+	 goto error_return;
+
+      size = symcount * symesz;
+      buf = esym = (bfd_byte *) bfd_malloc (size);
+      if (esym == NULL)
+	 goto error_return;
+      
+      if (! bfd_get_section_contents (abfd, dynsym, 
+				      (bfd_byte *)esym, (file_ptr) 0, size))
 		goto error_return;
+
+      esym_end = esym + symcount * symesz;
+
+      /* Skip the first (junk) entry */
+      esym = esym + symesz;
+      /* But the hash table has to match. */
+      sym_hash++;
+
+      dynstrings = bfd_coff_get_str_section (abfd, dynsym->link_index);
+
+      using_dynsymtab = TRUE;
+      sym_idx=1;
 	    }
+#else /* ][ */
 
-	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
-	    (*sym_hash)->coff_link_hash_flags |=
-	      COFF_LINK_HASH_PE_SECTION_SYMBOL;
+  esym = (bfd_byte *) obj_coff_external_syms (abfd);
+  esym_end = esym + symcount * symesz;
+  sym_idx=0;
+#endif /* ] */
 
-	  /* Limit the alignment of a common symbol to the possible
-             alignment of a section.  There is no point to permitting
-             a higher alignment for a common symbol: we can not
-             guarantee it, and it may cause us to allocate extra space
-             in the common section.  */
-	  if (section == bfd_com_section_ptr
-	      && (*sym_hash)->root.type == bfd_link_hash_common
-	      && ((*sym_hash)->root.u.c.p->alignment_power
-		  > bfd_coff_default_section_alignment_power (abfd)))
-	    (*sym_hash)->root.u.c.p->alignment_power
-	      = bfd_coff_default_section_alignment_power (abfd);
 
-	  if (info->hash->creator->flavour == bfd_get_flavour (abfd))
-	    {
-	      /* If we don't have any symbol information currently in
-                 the hash table, or if we are looking at a symbol
-                 definition, then update the symbol class and type in
-                 the hash table.  */
-  	      if (((*sym_hash)->class == C_NULL
-  		   && (*sym_hash)->type == T_NULL)
-  		  || sym.n_scnum != 0
-  		  || (sym.n_value != 0
-  		      && (*sym_hash)->root.type != bfd_link_hash_defined
-  		      && (*sym_hash)->root.type != bfd_link_hash_defweak))
+#ifdef DYNAMIC_LINKING /* [ */
+  if (! dynamic)
   		{
-  		  (*sym_hash)->class = sym.n_sclass;
-  		  if (sym.n_type != T_NULL)
+      /* If we are creating a shared library, create all the dynamic
+         sections immediately.  We need to attach them to something,
+         so we attach them to this BFD, provided it is the right
+         format.  FIXME: If there are no input BFD's of the same
+         format as the output, we can't make a shared library.  */
+      if (info->shared
+	  && ! coff_hash_table (info)->dynamic_sections_created
+	  && (abfd->xvec == info->hash->creator
+	     || abfd->xvec == info->hash->creator->input_format)
+	  )
   		    {
-  		      /* We want to warn if the type changed, but not
-  			 if it changed from an unspecified type.
-  			 Testing the whole type byte may work, but the
-  			 change from (e.g.) a function of unspecified
-  			 type to function of known type also wants to
-  			 skip the warning.  */
-  		      if ((*sym_hash)->type != T_NULL
-  			  && (*sym_hash)->type != sym.n_type
-  		          && !(DTYPE ((*sym_hash)->type) == DTYPE (sym.n_type)
-  		               && (BTYPE ((*sym_hash)->type) == T_NULL
-  		                   || BTYPE (sym.n_type) == T_NULL)))
-  			(*_bfd_error_handler)
-  			  (_("Warning: type of symbol `%s' changed from %d to %d in %B"),
-  			   abfd, name, (*sym_hash)->type, sym.n_type);
-
-  		      /* We don't want to change from a meaningful
-  			 base type to a null one, but if we know
-  			 nothing, take what little we might now know.  */
-  		      if (BTYPE (sym.n_type) != T_NULL
-  			  || (*sym_hash)->type == T_NULL)
-			(*sym_hash)->type = sym.n_type;
+	  if (! coff_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
   		    }
-  		  (*sym_hash)->auxbfd = abfd;
-		  if (sym.n_numaux != 0)
+    }
+  else
 		    {
-		      union internal_auxent *alloc;
-		      unsigned int i;
-		      bfd_byte *eaux;
-		      union internal_auxent *iaux;
+      asection *s;
+      bfd_boolean add_needed;
+      const char *name;
+      bfd_size_type oldsize;
+      bfd_size_type strindex;
 
-		      (*sym_hash)->numaux = sym.n_numaux;
-		      alloc = ((union internal_auxent *)
-			       bfd_hash_allocate (&info->hash->table,
-						  (sym.n_numaux
-						   * sizeof (*alloc))));
-		      if (alloc == NULL)
+      /* Find the name to use in a DT_NEEDED entry that refers to this
+	 object.  If the object has a DT_SONAME entry, we use it.
+	 Otherwise, if the generic linker stuck something in
+	 coff_dt_name, we use that.  Otherwise, we just use the file
+	 name.  If the generic linker put a null string into
+	 coff_dt_name, we don't make a DT_NEEDED entry at all, even if
+	 there is a DT_SONAME entry.  */
+      add_needed = TRUE;
+      name = bfd_get_filename (abfd);
+      if (coff_dt_name (abfd) != NULL)
+	{
+	  name = coff_dt_name (abfd);
+	  if (*name == '\0')
+	    add_needed = FALSE;
+	}
+
+      /* Now get the .dynamic section from this file and merge it into ours. */
+      s = coff_dynamic(abfd);
+      if (s != NULL)
+	{
+	  coff_external_dyn *extdyn;
+	  coff_external_dyn *extdynend;
+	  unsigned long link;
+
+	  dynbuf = (coff_external_dyn *) bfd_malloc ((size_t) s->size);
+	  if (dynbuf == NULL)
 			goto error_return;
-		      for (i = 0, eaux = esym + symesz, iaux = alloc;
-			   i < sym.n_numaux;
-			   i++, eaux += symesz, iaux++)
-			bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,
-					      sym.n_sclass, (int) i,
-					      sym.n_numaux, iaux);
-		      (*sym_hash)->aux = alloc;
-		    }
-		}
-	    }
 
-	  if (classification == COFF_SYMBOL_PE_SECTION
-	      && (*sym_hash)->numaux != 0)
+	  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf,
+					  (file_ptr) 0, s->size))
+	    goto error_return;
+
+	  link = s->link_index;
+
+	  extdyn = dynbuf;
+	  extdynend = extdyn + s->size / sizeof (coff_external_dyn);
+	  for (; extdyn < extdynend; extdyn++)
 	    {
-	      /* Some PE sections (such as .bss) have a zero size in
-                 the section header, but a non-zero size in the AUX
-                 record.  Correct that here.
+	      coff_internal_dyn dyn;
 
-		 FIXME: This is not at all the right place to do this.
-		 For example, it won't help objdump.  This needs to be
-		 done when we swap in the section header.  */
-	      BFD_ASSERT ((*sym_hash)->numaux == 1);
-	      if (section->size == 0)
-		section->size = (*sym_hash)->aux[0].x_scn.x_scnlen;
+	      bfd_coff_swap_dyn_in (abfd, extdyn, &dyn);
+	      if (dyn.d_tag == DT_SONAME)
+		{
+		  name = bfd_coff_string_from_coff_section (abfd, link,
+							  dyn.d_un.d_val);
+		  if (name == NULL)
+		    goto error_return;
+		}
+	      if (dyn.d_tag == DT_NEEDED)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
 
-	      /* FIXME: We could test whether the section sizes
-                 matches the size in the aux entry, but apparently
-                 that sometimes fails unexpectedly.  */
+		  n = ((struct bfd_link_needed_list *)
+		       bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
+		  fnm = bfd_coff_string_from_coff_section (abfd, link,
+							 dyn.d_un.d_val);
+		  if (n == NULL || fnm == NULL)
+		    goto error_return;
+		  anm = bfd_alloc (abfd, strlen (fnm) + 1);
+		  if (anm == NULL)
+		    goto error_return;
+		  strcpy (anm, fnm);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = &coff_hash_table (info)->needed;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
 	    }
 	}
 
-      esym += (sym.n_numaux + 1) * symesz;
-      sym_hash += sym.n_numaux + 1;
-    }
+	  free (dynbuf);
+	  dynbuf = NULL;
+	}
+
+#if 0
+      this is how elf handles things
+//MAYANK
+	     /* We do not want to include any of the sections in a dynamic
+	 object in the output file.  We hack by simply clobbering the
+	 list of sections in the BFD.  This could be handled more
+	 cleanly by, say, a new section flag; the existing
+	 SEC_NEVER_LOAD flag is not the one we want, because that one
+	 still implies that the section takes up space in the output
+	 file.  */
+      bfd_section_list_clear (abfd);
+#endif
 
-  /* If this is a non-traditional, non-relocatable link, try to
-     optimize the handling of any .stab/.stabstr sections.  */
-  if (! info->relocatable
-      && ! info->traditional_format
-      && info->hash->creator->flavour == bfd_get_flavour (abfd)
-      && (info->strip != strip_all && info->strip != strip_debugger))
-    {
-      asection *stabstr;
 
-      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
+      /* If this is the first dynamic object found in the link, create
+	 the special sections required for dynamic linking.  */
+      if (! coff_hash_table (info)->dynamic_sections_created)
+	{
+	  if (! coff_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
+	}
 
-      if (stabstr != NULL)
+      if (add_needed)
 	{
-	  bfd_size_type string_offset = 0;
-	  asection *stab;
+	  /* Add a DT_NEEDED entry for this dynamic object.  */
+	  oldsize = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+	  strindex = _bfd_stringtab_add (coff_hash_table (info)->dynstr, name,
+					 TRUE, FALSE);
+	  if (strindex == (bfd_size_type) -1)
+	    goto error_return;
 	  
-	  for (stab = abfd->sections; stab; stab = stab->next)
-	    if (strncmp (".stab", stab->name, 5) == 0
-		&& (!stab->name[5]
-		    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))
+	  if (oldsize == _bfd_stringtab_size (coff_hash_table (info)->dynstr))
 	    {
-	      struct coff_link_hash_table *table;
-	      struct coff_section_tdata *secdata
-		= coff_section_data (abfd, stab);
+	      asection *sdyn;
+	      coff_external_dyn *dyncon, *dynconend;
 	      
-	      if (secdata == NULL)
+	      /* The hash table size did not change, which means that
+		 the dynamic object name was already entered.  If we
+		 have already included this dynamic object in the
+		 link, just ignore it.  There is no reason to include
+		 a particular dynamic object more than once.  */
+	      sdyn = coff_hash_table (info)->dynamic;
+	      BFD_ASSERT (sdyn != NULL);
+
+	      dyncon = (coff_external_dyn *) sdyn->contents;
+	      dynconend = (coff_external_dyn *) (sdyn->contents +
+						sdyn->size);
+	      for (; dyncon < dynconend; dyncon++)
+		{
+		  coff_internal_dyn dyn;
+
+		  bfd_coff_swap_dyn_in (coff_hash_table (info)->dynobj, dyncon,
+				   &dyn);
+		  if (dyn.d_tag == DT_NEEDED
+		      && dyn.d_un.d_val == strindex)
 		{
-		  amt = sizeof (struct coff_section_tdata);
-		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
-		  if (stab->used_by_bfd == NULL)
-		    goto error_return;
-		  secdata = coff_section_data (abfd, stab);
-		}
+		      if (buf != NULL)
+			free (buf);
+		      if (extversym != NULL)
+			free (extversym);
 
-	      table = coff_hash_table (info);
+		      /* We do not want to include any of the sections in a
+			 dynamic object in the output file.  We hack by simply
+			 clobbering the list of sections in the BFD.  This could
+			 be handled more cleanly by, say, a new section flag;
+			 the existing SEC_NEVER_LOAD flag is not the one we
+			 want, because that one still implies that the section
+			 takes up space in the output file.  We do this after
+			 having extracted the section information from the
+			 symbol table.  Because we need the section information
+			 until after the symbols are examined, we do this here
+			 and after they are examined */
+		      abfd->sections = NULL;
+		      abfd->section_count = 0;
 
-	      if (! _bfd_link_section_stabs (abfd, &table->stab_info,
-					     stab, stabstr,
-					     &secdata->stab_info,
-					     &string_offset))
-		goto error_return;
+		      return TRUE;
 	    }
 	}
     }
 
-  obj_coff_keep_syms (abfd) = keep_syms;
+	  if (! coff_add_dynamic_entry (info, DT_NEEDED, strindex))
+	    goto error_return;
+	}
 
-  return TRUE;
+      /* Save the SONAME, if there is one, because sometimes the
+         linker emulation code will need to know it.  */
+      if (*name == '\0')
+	name = bfd_get_filename (abfd);
+      coff_dt_name (abfd) = name;
+    }
 
- error_return:
-  obj_coff_keep_syms (abfd) = keep_syms;
-  return FALSE;
-}
+#ifdef USE_WEAK
+    weaks = NULL;
+#endif
 
-/* Do the final link step.  */
+    ever = extversym;
+#endif /* ] */
 
-bfd_boolean
-_bfd_coff_final_link (bfd *abfd,
-		      struct bfd_link_info *info)
-{
-  bfd_size_type symesz;
-  struct coff_final_link_info finfo;
-  bfd_boolean debug_merge_allocated;
-  bfd_boolean long_section_names;
-  asection *o;
-  struct bfd_link_order *p;
-  bfd_size_type max_sym_count;
-  bfd_size_type max_lineno_count;
-  bfd_size_type max_reloc_count;
-  bfd_size_type max_output_reloc_count;
-  bfd_size_type max_contents_size;
-  file_ptr rel_filepos;
-  unsigned int relsz;
-  file_ptr line_filepos;
-  unsigned int linesz;
-  bfd *sub;
-  bfd_byte *external_relocs = NULL;
-  char strbuf[STRING_SIZE_SIZE];
-  bfd_size_type amt;
+  while (esym < esym_end)
+    {
+      struct internal_syment sym;
+      enum coff_symbol_classification classification;
+      bfd_boolean copy=FALSE;
 
-  symesz = bfd_coff_symesz (abfd);
+#ifdef DYNAMIC_LINKING
+      bfd_boolean definition;
+      struct coff_link_hash_entry *h = NULL;
+      struct coff_link_hash_entry *h_real;
 
-  finfo.info = info;
-  finfo.output_bfd = abfd;
-  finfo.strtab = NULL;
-  finfo.section_info = NULL;
-  finfo.last_file_index = -1;
-  finfo.last_bf_index = -1;
-  finfo.internal_syms = NULL;
-  finfo.sec_ptrs = NULL;
-  finfo.sym_indices = NULL;
-  finfo.outsyms = NULL;
-  finfo.linenos = NULL;
-  finfo.contents = NULL;
-  finfo.external_relocs = NULL;
-  finfo.internal_relocs = NULL;
-  finfo.global_to_static = FALSE;
-  debug_merge_allocated = FALSE;
+      if (ever != NULL) ever++;
+#endif
 
-  coff_data (abfd)->link_info = info;
+      bfd_coff_swap_sym_in (abfd, esym, &sym);
 
-  finfo.strtab = _bfd_stringtab_init ();
-  if (finfo.strtab == NULL)
-    goto error_return;
+#ifdef DYNAMIC_LINKING
+      /* A symbol coming from a .so can be one of three things:
+	 A definition (in that .so).
+	 An (as yet) unsatisfied symbol 
+	 A reference from that .so to some other .so it was linked against.
+
+	 The latter two both look like undefined symbols at this point.
+
+	 The third class is transformed into the first (or second) because the 
+	 generic linker looks thru the DT_NEEDED entries of all .so's and 
+	 calls this routine for all the libraries thus mentioned.
+       */
+#endif
 
-  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
-    goto error_return;
-  debug_merge_allocated = TRUE;
 
-  /* Compute the file positions for all the sections.  */
-  if (! abfd->output_has_begun)
+      classification = bfd_coff_classify_symbol (abfd, &sym);
+      if (strncmp(sym._n._n_name,"___sF",5)==0)
     {
-      if (! bfd_coff_compute_section_file_positions (abfd))
-	goto error_return;
+	      char name[100];
+	      name[0]=1;
     }
+      if (classification != COFF_SYMBOL_LOCAL)
+	{
+	  const char *name;
+	  char buf[SYMNMLEN + 4];  /* +1 +3 for possible sequence# */
+	  flagword flags;
+	  asection *section;
+	  bfd_vma value;
+	  bfd_boolean addit;
+	  const char *alias_target_name = NULL;
 
-  /* Count the line numbers and relocation entries required for the
-     output file.  Set the file positions for the relocs.  */
-  rel_filepos = obj_relocbase (abfd);
-  relsz = bfd_coff_relsz (abfd);
-  max_contents_size = 0;
-  max_lineno_count = 0;
-  max_reloc_count = 0;
 
-  long_section_names = FALSE;
-  for (o = abfd->sections; o != NULL; o = o->next)
+	  /* This symbol is externally visible.  */
+
+#ifdef DYNAMIC_LINKING
+	  if (using_dynsymtab)
     {
-      o->reloc_count = 0;
-      o->lineno_count = 0;
-      for (p = o->map_head.link_order; p != NULL; p = p->next)
+	      if (sym._n._n_n._n_zeroes != 0
+		  || sym._n._n_n._n_offset == 0)
 	{
-	  if (p->type == bfd_indirect_link_order)
+		   memcpy (buf, sym._n._n_name, SYMNMLEN);
+		   buf[SYMNMLEN] = '\0';
+		   name=buf;
+		   copy=TRUE;
+		}
+	      else
 	    {
-	      asection *sec;
+		   name = dynstrings + sym._n._n_n._n_offset;
+		}
+	    }
+	  else
+#endif
+            { // NOTE: more delayed indentation fix
 
-	      sec = p->u.indirect.section;
 
-	      /* Mark all sections which are to be included in the
-		 link.  This will normally be every section.  We need
-		 to do this so that we can identify any sections which
-		 the linker has decided to not include.  */
-	      sec->linker_mark = TRUE;
+	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
+	  if (name == NULL)
+	    goto error_return;
 
-	      if (info->strip == strip_none
-		  || info->strip == strip_some)
-		o->lineno_count += sec->lineno_count;
+	  /* We must copy the name into memory if we got it from the
+             syment itself, rather than the string table.  */
+	  copy = default_copy;
+	  if (sym._n._n_n._n_zeroes != 0
+	      || sym._n._n_n._n_offset == 0)
+	    copy = TRUE;
 
-	      if (info->relocatable)
-		o->reloc_count += sec->reloc_count;
+    	} // END DELAY
 
-	      if (sec->rawsize > max_contents_size)
-		max_contents_size = sec->rawsize;
-	      if (sec->size > max_contents_size)
-		max_contents_size = sec->size;
-	      if (sec->lineno_count > max_lineno_count)
-		max_lineno_count = sec->lineno_count;
-	      if (sec->reloc_count > max_reloc_count)
-		max_reloc_count = sec->reloc_count;
+	  value = sym.n_value;
+
+	  /* This is horrible, but I can't think of a better way to do it.
+
+	     For PE/PEI format stuff, LIB.EXE-generated .LIB files
+	     for DLLs use the symbols .idata$*.  (see ld/emultempl/pe.em).
+	     All such .LIB files use the same symbols in the same
+	     way.  However, the .idata$4 and .idata$5 symbols behave
+	     as if they had a scope of exactly that archive!  (That
+	     is, .idata$5 symbols from one .LIB are not related to
+	     those from another.)  The other .idata$* symbols have
+	     that characteristic to some degree, but in particular,
+	     .idata$2 does NOT!  (Specifically, the archive member
+	     which defines the import directory table for a given
+	     .LIB wants it's reference to .idata$5 (the "Thunk table")
+	     to refer to a list of .idata$5 entries ONLY from that one
+	     library (similarly, .idata$4.) .   However, .idata$2 itself
+	     wants to be collected with the other .idata$2 sections.)
+
+	     To accomplish this in the context of ld, the easiest way seems
+	     to be to mangle the names of .idata$[45] symbols to include
+	     an archive indicator.  We do that here.
+
+	     Because the section symbols .idata$4 and .idata$5 are also
+	     required, we don't mangle the symbols in the very first
+	     library.  That will come out first, and all will be well.
+
+	     (Note that the first instance of .idata$2, .idata$4 and
+	     .idata$5 in each LIB.EXE built archive is storage class 104
+	     (C_SECTION).  Because we don't neccessarily see the archive
+	     in order I wasn't able to figure out a way to use that
+	     information.  However, it might be a way around this mess.)
+
+	     (Putting this in _bfd_coff_internal_syment_name has nasty
+	     side-effects.)  */
+
+	  if (name[0]=='.' && name[1] == 'i' &&
+	      strncmp(name, ".idata$",7)==0 && (name[7]=='4'||name[7]=='5'))
+	    {
+	      static bfd* this_archive = NULL;
+	      static int arch_sequence = -1;
+	      /* we're assuming we handle all of each archive before going
+		 on to the next, and that if we search the same .a file twice,
+		 we treat them separately.  (The later (probably) won't work
+		 at runtime, but because DLL libs are always all leaf routines,
+		 we should never search one twice to begin with.) */
+	      if (this_archive != abfd->my_archive)
+		{
+		 this_archive = abfd->my_archive;
+		 arch_sequence++;
 	    }
-	  else if (info->relocatable
-		   && (p->type == bfd_section_reloc_link_order
-		       || p->type == bfd_symbol_reloc_link_order))
-	    ++o->reloc_count;
+	      if (arch_sequence>0)
+		{
+		 /* in case it's in the string table, put it into the buffer */
+		 if (name != &buf[0])
+		   {
+		     strcpy (buf, name);
+		     name = &buf[0];
+		     copy = TRUE;
 	}
-      if (o->reloc_count == 0)
-	o->rel_filepos = 0;
-      else
+		   buf[8]=0x7f;
+		   /* we'll try to put out a decimal number, but if it
+		      overflows in the left digit, there's no loss */
+		   buf[9]=arch_sequence/10+'0';
+		   buf[10]=arch_sequence%10+'0';
+		   buf[11]=0;
+		}
+	    }
+
+	  switch (classification)
 	{
-	  o->flags |= SEC_RELOC;
-	  o->rel_filepos = rel_filepos;
-	  rel_filepos += o->reloc_count * relsz;
-	  /* In PE COFF, if there are at least 0xffff relocations an
-	     extra relocation will be written out to encode the count.  */
-	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
-	    rel_filepos += relsz;
+	    default:
+	      abort ();
+
+	    case COFF_SYMBOL_GLOBAL:
+	      flags = BSF_EXPORT | BSF_GLOBAL;
+	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
+	      value -= section->vma;
+	      break;
+
+	    case COFF_SYMBOL_UNDEFINED:
+	      flags = 0;
+	      section = bfd_und_section_ptr;
+	      break;
+
+	    case COFF_SYMBOL_COMMON:
+	      flags = BSF_GLOBAL;
+	      section = bfd_com_section_ptr;
+	      break;
+
+	    case COFF_SYMBOL_PE_SECTION:
+	      flags = BSF_SECTION_SYM | BSF_GLOBAL;
+	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
+	      break;
 	}
+#ifdef DYNAMIC_LINKING /* [ */
+	  definition = (classification == COFF_SYMBOL_GLOBAL);
+	  /* Common is not a definition (in this sense); if defined in a 
+	     shared lib it's become an ordinary symbol.  Defined ordinary
+	     symbol plus common has the ordinary symbol dominate anyway,
+	     which is generally what we want.
+
+	     USE_COPY_RELOC may affect this.  */
+
+#ifdef USE_SIZE
+	  size_change_ok = FALSE;
+	  /* type_chang_ok is a kluge left over from ELF where certain
+	     machines misrecorded types; that seems more likely in COFF,
+	     so that is left as a guide. */
+	  type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
+#else
+	  type_change_ok = FALSE;
+	  size_change_ok = FALSE;
+#endif
+#endif /* ] */
+	  if (info->hash->creator->flavour == bfd_target_coff_flavour)
+	    {
+	     bfd_boolean override;
+#ifdef DYNAMIC_LINKING /* [ */
+	      coff_internal_versym iver;
+	      unsigned int vernum = -1;
+
+	      if (ever != NULL)
+		{
+		  bfd_coff_swap_versym_in (abfd, ever, &iver);
+		  vernum = iver.vs_vers & VERSYM_VERSION;
+
+		  /* If this is a hidden symbol, or if it is not version
+		     1, we append the version name to the symbol name.
+		     However, we do not modify a non-hidden absolute
+		     symbol, because it might be the version symbol
+		     itself.  FIXME: What if it isn't?  */
+		  if ((iver.vs_vers & VERSYM_HIDDEN) != 0
+		      || (vernum > 1 && ! bfd_is_abs_section (section)))
+		    {
+		      const char *verstr;
+		      int namelen, newlen;
+		      char *newname, *p;
 
-      if (bfd_coff_long_section_names (abfd)
-	  && strlen (o->name) > SCNNMLEN)
+		      if (sym.n_scnum != N_UNDEF)
 	{
-	  /* This section has a long name which must go in the string
-             table.  This must correspond to the code in
-             coff_write_object_contents which puts the string index
-             into the s_name field of the section header.  That is why
-             we pass hash as FALSE.  */
-	  if (_bfd_stringtab_add (finfo.strtab, o->name, FALSE, FALSE)
-	      == (bfd_size_type) -1)
+			  if (vernum > dyn_data (abfd)->dynverdef->info_r)
+			    {
+			      (*_bfd_error_handler)
+				(_("%s: %s: invalid version %d (max %d)"),
+				 abfd->filename, name, vernum,
+				 dyn_data (abfd)->dynverdef->info_r);
+			      bfd_set_error (bfd_error_bad_value);
 	    goto error_return;
-	  long_section_names = TRUE;
 	}
+			  else if (vernum > 1)
+			    verstr = 
+			       dyn_data (abfd)->verdef[vernum - 1].vd_nodename;
+			  else
+			    verstr = "";
     }
-
-  /* If doing a relocatable link, allocate space for the pointers we
-     need to keep.  */
-  if (info->relocatable)
+		      else
     {
-      unsigned int i;
-
-      /* We use section_count + 1, rather than section_count, because
-         the target_index fields are 1 based.  */
-      amt = abfd->section_count + 1;
-      amt *= sizeof (struct coff_link_section_info);
-      finfo.section_info = bfd_malloc (amt);
-      if (finfo.section_info == NULL)
-	goto error_return;
-      for (i = 0; i <= abfd->section_count; i++)
+			  /* We cannot simply test for the number of
+			     entries in the VERNEED section since the
+			     numbers for the needed versions do not start
+			     at 0.  */
+			  coff_internal_verneed *t;
+
+			  verstr = NULL;
+			  for (t = dyn_data (abfd)->verref;
+			       t != NULL;
+			       t = t->vn_nextref)
+			    {
+			      coff_internal_vernaux *a;
+
+			      for (a = t->vn_auxptr; 
+				   a != NULL; 
+				   a = a->vna_nextptr)
 	{
-	  finfo.section_info[i].relocs = NULL;
-	  finfo.section_info[i].rel_hashes = NULL;
+				  if (a->vna_other == vernum)
+				    {
+				      verstr = a->vna_nodename;
+				      break;
 	}
     }
-
-  /* We now know the size of the relocs, so we can determine the file
-     positions of the line numbers.  */
-  line_filepos = rel_filepos;
-  linesz = bfd_coff_linesz (abfd);
-  max_output_reloc_count = 0;
-  for (o = abfd->sections; o != NULL; o = o->next)
-    {
-      if (o->lineno_count == 0)
-	o->line_filepos = 0;
-      else
+			      if (a != NULL)
+				break;
+			    }
+			  if (verstr == NULL)
 	{
-	  o->line_filepos = line_filepos;
-	  line_filepos += o->lineno_count * linesz;
+			      (*_bfd_error_handler)
+				(_("%s: %s: invalid needed version %d"),
+				 bfd_get_filename (abfd), name, vernum);
+			      bfd_set_error (bfd_error_bad_value);
+			      goto error_return;
+			    }
 	}
 
-      if (o->reloc_count != 0)
-	{
-	  /* We don't know the indices of global symbols until we have
-             written out all the local symbols.  For each section in
-             the output file, we keep an array of pointers to hash
-             table entries.  Each entry in the array corresponds to a
-             reloc.  When we find a reloc against a global symbol, we
-             set the corresponding entry in this array so that we can
-             fix up the symbol index after we have written out all the
-             local symbols.
+		      namelen = strlen (name);
+		      newlen = namelen + strlen (verstr) + 2;
+		      if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
+			++newlen;
 
-	     Because of this problem, we also keep the relocs in
-	     memory until the end of the link.  This wastes memory,
-	     but only when doing a relocatable link, which is not the
-	     common case.  */
-	  BFD_ASSERT (info->relocatable);
-	  amt = o->reloc_count;
-	  amt *= sizeof (struct internal_reloc);
-	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
-	  amt = o->reloc_count;
-	  amt *= sizeof (struct coff_link_hash_entry *);
-	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
-	  if (finfo.section_info[o->target_index].relocs == NULL
-	      || finfo.section_info[o->target_index].rel_hashes == NULL)
+		      newname = (char *) bfd_alloc (abfd, newlen);
+		      if (newname == NULL)
 	    goto error_return;
+		      strcpy (newname, name);
+		      p = newname + namelen;
+		      *p++ = COFF_VER_CHR;
+		      /* If this is a defined non-hidden version symbol,
+			 we add another @ to the name.  This indicates the
+			 default version of the symbol.  */
+		      if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+                          && sym.n_scnum != N_UNDEF)
+			*p++ = COFF_VER_CHR;
+		      strcpy (p, verstr);
 
-	  if (o->reloc_count > max_output_reloc_count)
-	    max_output_reloc_count = o->reloc_count;
+		      name = newname;
 	}
-
-      /* Reset the reloc and lineno counts, so that we can use them to
-	 count the number of entries we have output so far.  */
-      o->reloc_count = 0;
-      o->lineno_count = 0;
     }
 
-  obj_sym_filepos (abfd) = line_filepos;
-
-  /* Figure out the largest number of symbols in an input BFD.  Take
-     the opportunity to clear the output_has_begun fields of all the
-     input BFD's.  */
-  max_sym_count = 0;
-  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+#endif /* ] */
+	      /* PE weak symbols are aliases... we need to get the aliased
+		 real symbol. */
+	      if (obj_pe(abfd) && sym.n_sclass == C_NT_WEAK)
     {
-      size_t sz;
+		  /* It's a PE weak symbol (type IMAGE_WEAK_EXTERN_SEARCH_ALIAS)
+		     That's implemented as an indirect in our parlance. 
+		     Find the aux entry, get the referenced symbol, and insert
+		     its name.  */
 
-      sub->output_has_begun = FALSE;
-      sz = obj_raw_syment_count (sub);
-      if (sz > max_sym_count)
-	max_sym_count = sz;
-    }
+		  int target_idx;
+		  union internal_auxent auxent;
 
-  /* Allocate some buffers used while linking.  */
-  amt = max_sym_count * sizeof (struct internal_syment);
-  finfo.internal_syms = bfd_malloc (amt);
-  amt = max_sym_count * sizeof (asection *);
-  finfo.sec_ptrs = bfd_malloc (amt);
-  amt = max_sym_count * sizeof (long);
-  finfo.sym_indices = bfd_malloc (amt);
-  finfo.outsyms = bfd_malloc ((max_sym_count + 1) * symesz);
-  amt = max_lineno_count * bfd_coff_linesz (abfd);
-  finfo.linenos = bfd_malloc (amt);
-  finfo.contents = bfd_malloc (max_contents_size);
-  amt = max_reloc_count * relsz;
-  finfo.external_relocs = bfd_malloc (amt);
-  if (! info->relocatable)
-    {
-      amt = max_reloc_count * sizeof (struct internal_reloc);
-      finfo.internal_relocs = bfd_malloc (amt);
+		  BFD_ASSERT (sym.n_numaux == 1);
+
+		  /* Read in the aux information */
+
+		  bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz), sym.n_type,
+				        sym.n_sclass, 0, sym.n_numaux,
+				        (PTR) &auxent);
+		  /* From the aux information, get the backing "strong"
+		     local symbol index. */
+		  target_idx = auxent.x_sym.x_tagndx.l;
+
+		  /* Check for IMAGE_WEAK_EXTERN_SEARCH_ALIAS; it's all
+		     we currently support.  (See the 3/98 or later PE docs;
+		     there used to be only two types.) */
+		  BFD_ASSERT (auxent.x_sym.x_misc.x_fsize == 3);
+
+		  /* Now that we've caught it... 
+
+		     For the moment (unless/until proven otherwise) we'll
+		     assume the real symbol is already declared in this
+		     file (possibly as an UNDEF, but it exists). */
+
+		  BFD_ASSERT(target_idx < sym_idx);
+
+		  /* It's an alias (weak symbol).  Treat it that way. */
+		  flags = BSF_WEAK | BSF_INDIRECT;
+
+		  /* From the aux entry, get the name as a string. */
+		  alias_target_name = 
+		      (obj_coff_sym_hashes (abfd))[target_idx]->
+				    root.root.string;
+		  /* We'll add the symbol later (after symbol merge). */
     }
-  if ((finfo.internal_syms == NULL && max_sym_count > 0)
-      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
-      || (finfo.sym_indices == NULL && max_sym_count > 0)
-      || finfo.outsyms == NULL
-      || (finfo.linenos == NULL && max_lineno_count > 0)
-      || (finfo.contents == NULL && max_contents_size > 0)
-      || (finfo.external_relocs == NULL && max_reloc_count > 0)
-      || (! info->relocatable
-	  && finfo.internal_relocs == NULL
-	  && max_reloc_count > 0))
+
+	      if (! coff_merge_symbol (abfd, info, name, &sym, classification,
+				       &section, &value,
+				       sym_hash, copy,
+				       &override, &type_change_ok,
+				       &size_change_ok))
     goto error_return;
 
-  /* We now know the position of everything in the file, except that
-     we don't know the size of the symbol table and therefore we don't
-     know where the string table starts.  We just build the string
-     table in memory as we go along.  We process all the relocations
-     for a single input file at once.  */
-  obj_raw_syment_count (abfd) = 0;
+	      if (override)
+		definition = FALSE;
 
-  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
+	      h = *sym_hash;
+
+	      while ((h->root.type == bfd_link_hash_indirect
+	  	       && !h->root.u.i.info.alias)
+		     || h->root.type == bfd_link_hash_warning)
+		h = (struct coff_link_hash_entry *) h->root.u.i.link;
+
+#ifdef DYNAMIC_LINKING /* [ */
+	      if (dynamic
+		  && dyn_data (abfd)->verdef != NULL
+		  && ! override
+		  && vernum > 1
+		  && definition)
+		h->verinfo.verdef = &dyn_data (abfd)->verdef[vernum - 1];
+#endif /* ] */
+
+	      /* If it's a section definition, we now know the section;
+		 Above, we may have munged the section name in the
+		 symbol table, but it's not munged in the section entry
+		 itself.  There are two possible places to put it;
+		 the section name entry itself, or in the section symbol
+		 name.  We use the latter as less likely to cause
+		 side effects.  We wait until now so we both have the
+		 section, and so we have a permanent copy of the munged
+		 name handy (without duplication). */
+	      if (classification == COFF_SYMBOL_PE_SECTION)
     {
-      if (! bfd_coff_start_final_link (abfd, info))
-	goto error_return;
+		   section->symbol->name = h->root.root.string;
+		}
     }
 
-  for (o = abfd->sections; o != NULL; o = o->next)
-    {
-      for (p = o->map_head.link_order; p != NULL; p = p->next)
-	{
-	  if (p->type == bfd_indirect_link_order
-	      && bfd_family_coff (p->u.indirect.section->owner))
-	    {
-	      sub = p->u.indirect.section->owner;
-	      if (! bfd_coff_link_output_has_begun (sub, & finfo))
+	  addit = TRUE;
+
+	  if (sym.n_sclass == C_WEAKEXT) /* NOT NT_WEAK! */
+	    flags = BSF_WEAK;
+
+
+	  /* In the PE format, section symbols actually refer to the
+             start of the output section.  We handle them specially
+             here.  */
+	  if ( (flags & BSF_SECTION_SYM) != 0
+	      && obj_pe (abfd) 
+	      && (*sym_hash)->root.type != bfd_link_hash_new)
+
 		{
-		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
-		    goto error_return;
-		  sub->output_has_begun = TRUE;
-		}
+
+	      if ((*sym_hash)->root.type != bfd_link_hash_undefined
+	      && (*sym_hash)->root.type != bfd_link_hash_undefweak
+	      && ((*sym_hash)->coff_link_hash_flags
+		   & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0)
+		(*_bfd_error_handler)
+		  (_("Warning: symbol `%s' is both section and non-section"),
+		   name);
+
+	      addit = FALSE;
+	      
 	    }
-	  else if (p->type == bfd_section_reloc_link_order
-		   || p->type == bfd_symbol_reloc_link_order)
+
+	  /* The Microsoft Visual C compiler does string pooling by
+	     hashing the constants to an internal symbol name, and
+	     relying on the linker comdat support to discard
+	     duplicate names.  However, if one string is a literal and
+	     one is a data initializer, one will end up in the .data
+	     section and one will end up in the .rdata section.  The
+	     Microsoft linker will combine them into the .data
+	     section, which seems to be wrong since it might cause the
+	     literal to change.
+
+	     As long as there are no external references to the
+	     symbols, which there shouldn't be, we can treat the .data
+	     and .rdata instances as separate symbols.  The comdat
+	     code in the linker will do the appropriate merging.  Here
+	     we avoid getting a multiple definition error for one of
+	     these special symbols.
+
+	     FIXME: I don't think this will work in the case where
+	     there are two object files which use the constants as a
+	     literal and two object files which use it as a data
+	     initializer.  One or the other of the second object files
+	     is going to wind up with an inappropriate reference.  */
+	  if (obj_pe (abfd)
+	      && (classification == COFF_SYMBOL_GLOBAL
+		  || classification == COFF_SYMBOL_PE_SECTION)
+	      && coff_section_data (abfd, section) != NULL
+	      && coff_section_data (abfd, section)->comdat != NULL
+	      && strncmp (name, "??_", 3) == 0
+	      && strcmp (name, coff_section_data (abfd, section)->comdat->name) == 0)
 	    {
-	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
-		goto error_return;
+	      if (*sym_hash == NULL)
+		*sym_hash = coff_link_hash_lookup (coff_hash_table (info),
+						   name, FALSE, copy, FALSE);
+	      if (*sym_hash != NULL
+		  && (*sym_hash)->root.type == bfd_link_hash_defined
+		  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL
+		  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,
+			     coff_section_data (abfd, section)->comdat->name) == 0)
+		addit = FALSE;
 	    }
-	  else
+
+	  if (addit)
 	    {
-	      if (! _bfd_default_link_order (abfd, info, o, p))
+	      if (! (bfd_coff_link_add_one_symbol
+		     (info, abfd, name, flags, section, value,
+		      alias_target_name, copy, FALSE,
+		      (struct bfd_link_hash_entry **) sym_hash)))
 		goto error_return;
 	    }
-	}
+
+	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
+	    (*sym_hash)->coff_link_hash_flags |=
+	      COFF_LINK_HASH_PE_SECTION_SYMBOL;
+	  /* If this is a weak alias, propigate the REF flags into
+	     the corresponding strong symbol, so it gets properly
+	     emitted as well. */
+	  h_real = *sym_hash;
+	  while ((h_real->root.type == bfd_link_hash_indirect
+		   && h_real->root.u.i.info.alias))
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+	  h_real->coff_link_hash_flags |=
+	    h->coff_link_hash_flags & 
+			      (COFF_LINK_HASH_REF_DYNAMIC |
+			      COFF_LINK_HASH_REF_REGULAR);
+         /* We're going to remember h_real for later use (way
+            down below). */
+ 
+	 /* If it's common (and presuming we actually emit it), it should
+	    be marked as DEF_REGULAR or DEF_DYNAMIC, as needed.  ld converts 
+	    it to bfd_link_hash_defined when it decides to keep it. */
+	 if ((*sym_hash)->root.type == bfd_link_hash_common)
+	   {
+	     (*sym_hash)->coff_link_hash_flags |=
+			     dynamic? COFF_LINK_HASH_DEF_DYNAMIC 
+				    : COFF_LINK_HASH_DEF_REGULAR;
+	     
     }
 
-  if (! bfd_coff_final_link_postscript (abfd, & finfo))
-    goto error_return;
+          /* Now deal with real indirect symbols. */
+	  h = *sym_hash;
+	  while ((h->root.type == bfd_link_hash_indirect
+		   && !h->root.u.i.info.alias)
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+	  *sym_hash = h;
 
-  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */
+#ifdef DYNAMIC_LINKING /* [ */
 
-  coff_debug_merge_hash_table_free (&finfo.debug_merge);
-  debug_merge_allocated = FALSE;
+#ifdef USE_WEAK
+	  new_weakdef = FALSE;
+	  if (dynamic
+	      && definition
+	      && (flags & BSF_WEAK) != 0
+	      && ELF_ST_TYPE (sym.st_info) != STT_FUNC
+	      && info->hash->creator->flavour == bfd_target_elf_flavour
+	      && h->weakdef == NULL)
+	    {
+	      /* Keep a list of all weak defined non function symbols from
+		 a dynamic object, using the weakdef field.  Later in this
+		 function we will set the weakdef field to the correct
+		 value.  We only put non-function symbols from dynamic
+		 objects on this list, because that happens to be the only
+		 time we need to know the normal symbol corresponding to a
+		 weak symbol, and the information is time consuming to
+		 figure out.  If the weakdef field is not already NULL,
+		 then this symbol was already defined by some previous
+		 dynamic object, and we will be using that previous
+		 definition anyhow.  */
+
+	      h->weakdef = weaks;
+	      weaks = h;
+	      new_weakdef = TRUE;
+	    }
+#endif
+#endif /* ] */
 
-  if (finfo.internal_syms != NULL)
+	  /* Limit the alignment of a common symbol to the possible
+             alignment of a section.  There is no point to permitting
+             a higher alignment for a common symbol: we can not
+             guarantee it, and it may cause us to allocate extra space
+             in the common section.  */
+	  if (section == bfd_com_section_ptr
+	      && (*sym_hash)->root.type == bfd_link_hash_common
+	      && ((*sym_hash)->root.u.c.p->alignment_power
+		  > bfd_coff_default_section_alignment_power (abfd)))
+	    (*sym_hash)->root.u.c.p->alignment_power
+	      = bfd_coff_default_section_alignment_power (abfd);
+
+	  if (info->hash->creator->flavour == bfd_get_flavour (abfd))
     {
-      free (finfo.internal_syms);
-      finfo.internal_syms = NULL;
-    }
-  if (finfo.sec_ptrs != NULL)
+#ifdef DYNAMIC_LINKING
+	      int old_flags;
+	      bfd_boolean is_dynsym;
+	      int new_flag;
+#endif
+	      /* If we don't have any symbol information currently in
+                 the hash table, or if we are looking at a symbol
+                 definition, then update the symbol class and type in
+                 the hash table.  */
+  	      if (((*sym_hash)->class == C_NULL
+  		   && (*sym_hash)->type == T_NULL)
+  		  || sym.n_scnum != 0
+  		  || (sym.n_value != 0
+  		      && (*sym_hash)->root.type != bfd_link_hash_defined
+  		      && (*sym_hash)->root.type != bfd_link_hash_defweak))
     {
-      free (finfo.sec_ptrs);
-      finfo.sec_ptrs = NULL;
-    }
-  if (finfo.sym_indices != NULL)
+  		  (*sym_hash)->class = sym.n_sclass;
+  		  if (sym.n_type != T_NULL)
     {
-      free (finfo.sym_indices);
-      finfo.sym_indices = NULL;
+  		      /* We want to warn if the type changed, but not
+  			 if it changed from an unspecified type.
+  			 Testing the whole type byte may work, but the
+  			 change from (e.g.) a function of unspecified
+  			 type to function of known type also wants to
+  			 skip the warning.  */
+  		      if ((*sym_hash)->type != T_NULL
+  			  && (*sym_hash)->type != sym.n_type
+  		          && !(DTYPE ((*sym_hash)->type) == DTYPE (sym.n_type)
+  		               && (BTYPE ((*sym_hash)->type) == T_NULL
+  		                   || BTYPE (sym.n_type) == T_NULL)))
+  			(*_bfd_error_handler)
+  			  (_("Warning: type of symbol `%s' changed from %d to %d in %B"),
+  			   abfd, name, (*sym_hash)->type, sym.n_type);
+
+  		      /* We don't want to change from a meaningful
+  			 base type to a null one, but if we know
+  			 nothing, take what little we might now know.  */
+  		      if (BTYPE (sym.n_type) != T_NULL
+  			  || (*sym_hash)->type == T_NULL)
+			(*sym_hash)->type = sym.n_type;
     }
-  if (finfo.linenos != NULL)
+  		  (*sym_hash)->auxbfd = abfd;
+		  if (sym.n_numaux != 0)
     {
-      free (finfo.linenos);
-      finfo.linenos = NULL;
+		      union internal_auxent *alloc;
+		      unsigned int i;
+		      bfd_byte *eaux;
+		      union internal_auxent *iaux;
+
+		      (*sym_hash)->numaux = sym.n_numaux;
+		      alloc = ((union internal_auxent *)
+			       bfd_hash_allocate (&info->hash->table,
+						  (sym.n_numaux
+						   * sizeof (*alloc))));
+		      if (alloc == NULL)
+			goto error_return;
+		      for (i = 0, eaux = esym + symesz, iaux = alloc;
+			   i < sym.n_numaux;
+			   i++, eaux += symesz, iaux++)
+			bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,
+					      sym.n_sclass, (int) i,
+					      sym.n_numaux, iaux);
+		      (*sym_hash)->aux = alloc;
     }
-  if (finfo.contents != NULL)
+		}
+#ifdef DYNAMIC_LINKING /* [ */
+#ifdef USE_SIZE
+	      /* If USE_COPY_RELOC is defined, this code probably needs
+		 to be turned on as well, and if it is, the relationship
+		 between the type checking here and that already present
+		 for native coff */
+	      /* Remember the symbol size and type.  */
+	      if (sym.st_size != 0
+		  && (definition || h->size == 0))
     {
-      free (finfo.contents);
-      finfo.contents = NULL;
+		  if (h->size != 0 && h->size != sym.st_size && ! size_change_ok)
+		    (*_bfd_error_handler)
+		      (_("Warning: size of symbol `%s' changed from %lu to %lu in %s"),
+		       name, (unsigned long) h->size, (unsigned long) sym.st_size,
+		       bfd_get_filename (abfd));
+
+		  h->size = sym.st_size;
+		}
+	      if (ELF_ST_TYPE (sym.st_info) != STT_NOTYPE
+		  && (definition || h->type == STT_NOTYPE))
+		{
+		  if (h->type != STT_NOTYPE
+		      && h->type != ELF_ST_TYPE (sym.st_info)
+		      && ! type_change_ok)
+		    (*_bfd_error_handler)
+		      (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
+		       name, h->type, ELF_ST_TYPE (sym.st_info),
+		       bfd_get_filename (abfd));
+
+		  h->type = ELF_ST_TYPE (sym.st_info);
     }
-  if (finfo.external_relocs != NULL)
+
+	      if (sym.st_other != 0
+		  && (definition || h->other == 0))
+		h->other = sym.st_other;
+#endif
+
+	      /* Set a flag in the hash table entry indicating the type of
+		 reference or definition we just found.  Keep a count of
+		 the number of dynamic symbols we find.  A dynamic symbol
+		 is one which is referenced or defined by both a regular
+		 object and a shared object.  */
+	      old_flags = (*sym_hash)->coff_link_hash_flags;
+	      is_dynsym = FALSE;
+		  
+	      if (! dynamic)
     {
-      free (finfo.external_relocs);
-      finfo.external_relocs = NULL;
+		  if (! definition)
+		    new_flag = COFF_LINK_HASH_REF_REGULAR;
+		  else
+		    new_flag = COFF_LINK_HASH_DEF_REGULAR;
+		  if ((info->shared && classification != COFF_SYMBOL_PE_SECTION)
+		      || (old_flags & (COFF_LINK_HASH_DEF_DYNAMIC
+				       | COFF_LINK_HASH_REF_DYNAMIC)) != 0)
+		    {
+#ifdef USE_DLLS
+			/* If we find a symbol is a DLL symbol, hide it from
+			   the shared library stuff completely */
+			if (!is_DLL_module)
+#endif
+		            is_dynsym = TRUE;
     }
-  if (finfo.internal_relocs != NULL)
+		}
+	      else
     {
-      free (finfo.internal_relocs);
-      finfo.internal_relocs = NULL;
+		  if (! definition)
+		    new_flag = COFF_LINK_HASH_REF_DYNAMIC;
+		  else
+		    new_flag = COFF_LINK_HASH_DEF_DYNAMIC;
+		  if ((old_flags & (COFF_LINK_HASH_DEF_REGULAR
+				    | COFF_LINK_HASH_REF_REGULAR)) != 0
+#ifdef USE_WEAK
+		      || ((*sym_hash)->weakdef != NULL
+			  && ! new_weakdef
+			  && (*sym_hash)->weakdef->dynindx != -1)
+#endif
+			  )
+		    is_dynsym = TRUE;
     }
 
-  /* The value of the last C_FILE symbol is supposed to be the symbol
-     index of the first external symbol.  Write it out again if
-     necessary.  */
-  if (finfo.last_file_index != -1
-      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
-    {
-      file_ptr pos;
+#ifdef USE_DLLS
+	      /* We flag symbols defined in a DLL so we know to not export
+		 them; if we find the definition first (__imp_* symbols and
+		 the various housekeeping symbols) we skip entering them as
+		 dynamic symbols.  However, for forward refs, we can't know
+		 until later, thus a flag. We'll not flag sections, because
+		 they are neither definition nor reference, really, and it
+		 doesn't work if we do.
+
+		 BUT!!!, we treat __imp_ symbols as ordinary, as
+		 they will need a dynamic reloc, at least until we
+		 generate .reloc sections. */
+
+	      if (definition 
+		  && is_DLL_module 
+		  && classification != COFF_SYMBOL_PE_SECTION
+		  && strncmp(h->root.root.string, "__imp_",6) != 0)
+		    new_flag |= COFF_LINK_HASH_DLL_DEFINED;
+#endif
 
-      finfo.last_file.n_value = obj_raw_syment_count (abfd);
-      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
-			     finfo.outsyms);
+	      (*sym_hash)->coff_link_hash_flags |= new_flag;
 
-      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
-      if (bfd_seek (abfd, pos, SEEK_SET) != 0
-	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
-	return FALSE;
-    }
+	      /* If this symbol has a version, and it is the default
+		 version, we create an indirect symbol from the default
+		 name to the fully decorated name.  This will cause
+		 external references which do not specify a version to be
+		 bound to this version of the symbol.  */
+	      if (definition)
+		{
+		  char *p;
+
+		  p = strchr (name, COFF_VER_CHR);
+		  /* MSVC compiler generated symbols can have @ in them,
+		     but they begin with ?, so leave them alone. */
+		  if (name[0] != '?' && p != NULL && p[1] == COFF_VER_CHR)
+		    {
+		      char *shortname;
+		      struct coff_link_hash_entry *hi;
+		      bfd_boolean override;
+
+		      shortname = bfd_hash_allocate (&info->hash->table,
+						     p - name + 1);
+		      if (shortname == NULL)
+			goto error_return;
+		      strncpy (shortname, name, p - name);
+		      shortname[p - name] = '\0';
 
-  /* If doing task linking (ld --task-link) then make a pass through the
-     global symbols, writing out any that are defined, and making them
-     static.  */
-  if (info->task_link)
+		      /* We are going to create a new symbol.  Merge it
+			 with any existing symbol with this name.  For the
+			 purposes of the merge, act as though we were
+			 defining the symbol we just defined, although we
+			 actually going to define an indirect symbol.  */
+		      type_change_ok = FALSE;
+		      size_change_ok = FALSE;
+		      if (! coff_merge_symbol (abfd, info, shortname, &sym, 
+					      classification,
+					      &section, &value, &hi, copy, &override,
+					      &type_change_ok, &size_change_ok))
+			goto error_return;
+
+		      if (! override)
     {
-      finfo.failed = FALSE;
-      coff_link_hash_traverse (coff_hash_table (info),
-			       _bfd_coff_write_task_globals, &finfo);
-      if (finfo.failed)
+				/*
+				 * FIXME
+				 * mayank@20th June, 2007
+				 * a better way to get away with the "dereferencing    type-punned pointer will break strict-aliasing rules"
+				 * error is to pass &h.root
+				 */
+			  if (! (_bfd_generic_link_add_one_symbol
+				 (info, abfd, shortname, BSF_INDIRECT,
+				  bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE,
+				  FALSE, ((struct bfd_link_hash_entry **) ((void *)&hi)))))
 	goto error_return;
     }
-
-  /* Write out the global symbols.  */
-  finfo.failed = FALSE;
-  coff_link_hash_traverse (coff_hash_table (info),
-			   _bfd_coff_write_global_sym, &finfo);
-  if (finfo.failed)
+		      else
+			{
+			  /* In this case the symbol named SHORTNAME is
+			     overriding the indirect symbol we want to
+			     add.  We were planning on making SHORTNAME an
+			     indirect symbol referring to NAME.  SHORTNAME
+			     is the name without a version.  NAME is the
+			     fully versioned name, and it is the default
+			     version.
+
+			     Overriding means that we already saw a
+			     definition for the symbol SHORTNAME in a
+			     regular object, and it is overriding the
+			     symbol defined in the dynamic object.
+
+			     When this happens, we actually want to change
+			     NAME, the symbol we just added, to refer to
+			     SHORTNAME.  This will cause references to
+			     NAME in the shared object to become
+			     references to SHORTNAME in the regular
+			     object.  This is what we expect when we
+			     override a function in a shared object: that
+			     the references in the shared object will be
+			     mapped to the definition in the regular
+			     object.  */
+
+			  while ((hi->root.type == bfd_link_hash_indirect
+				   && !hi->root.u.i.info.alias)
+				 || hi->root.type == bfd_link_hash_warning)
+			    hi = 
+			      (struct coff_link_hash_entry *) hi->root.u.i.link;
+
+			  h->root.type = bfd_link_hash_indirect;
+			  h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
+			  h->root.u.i.info.alias = FALSE;
+			  if (h->coff_link_hash_flags 
+			      & COFF_LINK_HASH_DEF_DYNAMIC)
+			    {
+			      h->coff_link_hash_flags 
+				  &=~ COFF_LINK_HASH_DEF_DYNAMIC;
+			      hi->coff_link_hash_flags 
+				  |= COFF_LINK_HASH_REF_DYNAMIC;
+			      if (hi->coff_link_hash_flags
+				  & (COFF_LINK_HASH_REF_REGULAR
+				     | COFF_LINK_HASH_DEF_REGULAR))
+				{
+				  if (! _bfd_coff_link_record_dynamic_symbol 
+					(info, hi))
     goto error_return;
+				}
+			    }
 
-  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
-  if (finfo.outsyms != NULL)
+			  /* Now set HI to H, so that the following code
+			     will set the other fields correctly.  */
+			  hi = h;
+			}
+
+		      /* If there is a duplicate definition somewhere,
+			 then HI may not point to an indirect symbol.  We
+			 will have reported an error to the user in that
+			 case.  */
+
+		      if (hi->root.type == bfd_link_hash_indirect
+			   && !hi->root.u.i.info.alias)
+			{
+			  struct coff_link_hash_entry *ht;
+
+			  /* If the symbol became indirect, then we assume
+			     that we have not seen a definition before.  */
+			  BFD_ASSERT ((hi->coff_link_hash_flags
+				       & (COFF_LINK_HASH_DEF_DYNAMIC
+					  | COFF_LINK_HASH_DEF_REGULAR))
+				      == 0);
+
+			  ht = 
+			      (struct coff_link_hash_entry *) hi->root.u.i.link;
+
+			  /* See if the new flags lead us to realize that
+			     the symbol must be dynamic.  */
+			  if (! is_dynsym)
+			    {
+			      if (! dynamic)
+				{
+				  if (info->shared
+				      || ((hi->coff_link_hash_flags
+					   & COFF_LINK_HASH_REF_DYNAMIC)
+					  != 0))
+				    is_dynsym = TRUE;
+				}
+			      else
     {
-      free (finfo.outsyms);
-      finfo.outsyms = NULL;
+				  if ((hi->coff_link_hash_flags
+				       & COFF_LINK_HASH_REF_REGULAR) != 0)
+				    is_dynsym = TRUE;
+				}
+			    }
     }
 
-  if (info->relocatable && max_output_reloc_count > 0)
-    {
-      /* Now that we have written out all the global symbols, we know
-	 the symbol indices to use for relocs against them, and we can
-	 finally write out the relocs.  */
-      amt = max_output_reloc_count * relsz;
-      external_relocs = bfd_malloc (amt);
-      if (external_relocs == NULL)
+		      /* We also need to define an indirection from the
+			 nondefault version of the symbol.  */
+
+		      shortname = bfd_hash_allocate (&info->hash->table,
+						     strlen (name));
+		      if (shortname == NULL)
 	goto error_return;
+		      strncpy (shortname, name, p - name);
+		      strcpy (shortname + (p - name), p + 1);
 
-      for (o = abfd->sections; o != NULL; o = o->next)
-	{
-	  struct internal_reloc *irel;
-	  struct internal_reloc *irelend;
-	  struct coff_link_hash_entry **rel_hash;
-	  bfd_byte *erel;
-
-	  if (o->reloc_count == 0)
-	    continue;
+		      /* Once again, merge with any existing symbol.  */
+		      type_change_ok = FALSE;
+		      size_change_ok = FALSE;
+		      if (! coff_merge_symbol (abfd, info, shortname, &sym,
+					      classification,
+					      &section, &value, &hi, copy, &override,
+					      &type_change_ok, &size_change_ok))
+			goto error_return;
 
-	  irel = finfo.section_info[o->target_index].relocs;
-	  irelend = irel + o->reloc_count;
-	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
-	  erel = external_relocs;
-	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
+		      if (override)
 	    {
-	      if (*rel_hash != NULL)
+			  /* Here SHORTNAME is a versioned name, so we
+			     don't expect to see the type of override we
+			     do in the case above.  */
+			  (*_bfd_error_handler)
+			    (_("%s: warning: unexpected redefinition of `%s'"),
+			     bfd_get_filename (abfd), shortname);
+			}
+		      else
 		{
-		  BFD_ASSERT ((*rel_hash)->indx >= 0);
-		  irel->r_symndx = (*rel_hash)->indx;
+			  if (! (bfd_coff_link_add_one_symbol
+				 (info, abfd, shortname, BSF_INDIRECT,
+				  bfd_ind_section_ptr, (bfd_vma) 0, name, 
+				  FALSE, FALSE,
+				  ((struct bfd_link_hash_entry **)((void *) &hi)))))
+			    goto error_return;
+
+			  /* If there is a duplicate definition somewhere,
+			     then HI may not point to an indirect symbol.
+			     We will have reported an error to the user in
+			     that case.  */
+
+			  if (hi->root.type == bfd_link_hash_indirect
+				&& !hi->root.u.i.info.alias)
+			    {
+			      /* If the symbol became indirect, then we
+				 assume that we have not seen a definition
+				 before.  */
+			      BFD_ASSERT ((hi->coff_link_hash_flags
+					   & (COFF_LINK_HASH_DEF_DYNAMIC
+					      | COFF_LINK_HASH_DEF_REGULAR))
+					  == 0);
+
+			      /* See if the new flags lead us to realize
+				 that the symbol must be dynamic.  */
+			      if (! is_dynsym)
+				{
+				  if (! dynamic)
+				    {
+				      if (info->shared
+					  || ((hi->coff_link_hash_flags
+					       & COFF_LINK_HASH_REF_DYNAMIC)
+					      != 0))
+					is_dynsym = TRUE;
+				    }
+				  else
+				    {
+				      if ((hi->coff_link_hash_flags
+					   & COFF_LINK_HASH_REF_REGULAR) != 0)
+					is_dynsym = TRUE;
+				    }
+				}
+			    }
+			}
 		}
-	      bfd_coff_swap_reloc_out (abfd, irel, erel);
 	    }
 
-	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)
+	      if (is_dynsym)
+		{
+		  if ((*sym_hash)->dynindx == -1)
+		    {
+		      if (!_bfd_coff_link_record_dynamic_symbol (info, 
+			  (*sym_hash)))
 	    goto error_return;
-	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
+#ifdef USE_WEAK
+		      if ((*sym_hash)->weakdef != NULL
+			  && ! new_weakdef
+			  && (*sym_hash)->weakdef->dynindx == -1)
 	    {
-	      /* In PE COFF, write the count of relocs as the first
-		 reloc.  The header overflow bit will be set
-		 elsewhere. */
-	      struct internal_reloc incount;
-	      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);
-	      
-	      memset (&incount, 0, sizeof (incount));
-	      incount.r_vaddr = o->reloc_count + 1;
-	      bfd_coff_swap_reloc_out (abfd, (PTR) &incount, (PTR) excount);
-	      if (bfd_bwrite (excount, relsz, abfd) != relsz)
-		/* We'll leak, but it's an error anyway. */
+			  if (! _bfd_coff_link_record_dynamic_symbol 
+					   (info, (*sym_hash)->weakdef))
 		goto error_return;
-	      free (excount);
 	    }
-	  if (bfd_bwrite (external_relocs,
-			  (bfd_size_type) relsz * o->reloc_count, abfd)
-	      != (bfd_size_type) relsz * o->reloc_count)
+#endif
+		    }
+		  /* If this is a weak/indirect symbol, we need to get
+		     the real symbol taken care of, too. (*sym_hash and
+		     h_real will be the same if this isn't weak, so
+		     don't do things twice.) */
+		  if (h_real != (*sym_hash)
+		      && h_real->dynindx == -1)
+		    {
+		      if (!_bfd_coff_link_record_dynamic_symbol (info, h_real))
+			goto error_return;
+#ifdef USE_WEAK
+		      if (h_real->weakdef != NULL
+			  && ! new_weakdef
+			  && h_real->weakdef->dynindx == -1)
+			{
+			  if (! _bfd_coff_link_record_dynamic_symbol 
+					   (info, h_real->weakdef))
 	    goto error_return;
 	}
-
-      free (external_relocs);
-      external_relocs = NULL;
+#endif
+		    }
+		}
     }
+#endif /* ] */
 
-  /* Free up the section information.  */
-  if (finfo.section_info != NULL)
-    {
-      unsigned int i;
 
-      for (i = 0; i < abfd->section_count; i++)
+	  if (classification == COFF_SYMBOL_PE_SECTION
+	      && (*sym_hash)->numaux != 0)
 	{
-	  if (finfo.section_info[i].relocs != NULL)
-	    free (finfo.section_info[i].relocs);
-	  if (finfo.section_info[i].rel_hashes != NULL)
-	    free (finfo.section_info[i].rel_hashes);
+	      /* Some PE sections (such as .bss) have a zero size in
+                 the section header, but a non-zero size in the AUX
+                 record.  Correct that here.
+
+		 FIXME: This is not at all the right place to do this.
+		 For example, it won't help objdump.  This needs to be
+		 done when we swap in the section header.  */
+	      BFD_ASSERT ((*sym_hash)->numaux == 1);
+	      if (section->size == 0)
+		section->size = (*sym_hash)->aux[0].x_scn.x_scnlen;
+
+	      /* FIXME: We could test whether the section sizes
+                 matches the size in the aux entry, but apparently
+                 that sometimes fails unexpectedly.  */
 	}
-      free (finfo.section_info);
-      finfo.section_info = NULL;
     }
 
-  /* If we have optimized stabs strings, output them.  */
-  if (coff_hash_table (info)->stab_info.stabstr != NULL)
-    {
-      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
-	return FALSE;
+      esym += (sym.n_numaux + 1) * symesz;
+      sym_hash += sym.n_numaux + 1;
+      sym_idx += sym.n_numaux + 1;
     }
 
-  /* Write out the string table.  */
-  if (obj_raw_syment_count (abfd) != 0 || long_section_names)
+#ifdef USE_WEAK
+  /* Now set the weakdefs field correctly for all the weak defined
+     symbols we found.  The only way to do this is to search all the
+     symbols.  Since we only need the information for non functions in
+     dynamic objects, that's the only time we actually put anything on
+     the list WEAKS.  We need this information so that if a regular
+     object refers to a symbol defined weakly in a dynamic object, the
+     real symbol in the dynamic object is also put in the dynamic
+     symbols; we also must arrange for both symbols to point to the
+     same memory location.  We could handle the general case of symbol
+     aliasing, but a general symbol alias can only be generated in
+     assembler code, handling it correctly would be very time
+     consuming, and other ELF linkers don't handle general aliasing
+     either.  */
+  while (weaks != NULL)
+    {
+      struct elf_link_hash_entry *hlook;
+      asection *slook;
+      bfd_vma vlook;
+      struct elf_link_hash_entry **hpp;
+      struct elf_link_hash_entry **hppend;
+
+      hlook = weaks;
+      weaks = hlook->weakdef;
+      hlook->weakdef = NULL;
+
+      BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
+		  || hlook->root.type == bfd_link_hash_defweak
+		  || hlook->root.type == bfd_link_hash_common
+		  || hlook->root.type == bfd_link_hash_indirect);
+      slook = hlook->root.u.def.section;
+      vlook = hlook->root.u.def.value;
+
+      hpp = elf_sym_hashes (abfd);
+      hppend = hpp + extsymcount;
+      for (; hpp < hppend; hpp++)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = *hpp;
+	  if (h != NULL && h != hlook
+	      && h->root.type == bfd_link_hash_defined
+	      && h->root.u.def.section == slook
+	      && h->root.u.def.value == vlook)
+	    {
+	      hlook->weakdef = h;
+
+	      /* If the weak definition is in the list of dynamic
+		 symbols, make sure the real definition is put there
+		 as well.  */
+	      if (hlook->dynindx != -1
+		  && h->dynindx == -1)
     {
-      file_ptr pos;
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		    goto error_return;
+		}
 
-      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
-      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
-	return FALSE;
+	      /* If the real definition is in the list of dynamic
+                 symbols, make sure the weak definition is put there
+                 as well.  If we don't do this, then the dynamic
+                 loader might not merge the entries for the real
+                 definition and the weak definition.  */
+	      if (h->dynindx != -1
+		  && hlook->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
+		    goto error_return;
+		}
 
-#if STRING_SIZE_SIZE == 4
-      H_PUT_32 (abfd,
-		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
-		strbuf);
-#else
- #error Change H_PUT_32 above
+	      break;
+	    }
+	}
+    }
 #endif
 
-      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
-	  != STRING_SIZE_SIZE)
-	return FALSE;
-
-      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
-	return FALSE;
+#ifdef DYNAMIC_LINKING /* [ */
+    if (dynamic) 
+      {
+	/* We do not want to include any of the sections in a dynamic
+	   object in the output file.  We hack by simply clobbering the
+	   list of sections in the BFD.  This could be handled more
+	   cleanly by, say, a new section flag; the existing
+	   SEC_NEVER_LOAD flag is not the one we want, because that one
+	   still implies that the section takes up space in the output
+	   file.  We do this after having extracted the section information
+	   from the symbol table. */
 
-      obj_coff_strings_written (abfd) = TRUE;
+	abfd->sections = NULL;
+	abfd->section_count = 0;
     }
 
-  _bfd_stringtab_free (finfo.strtab);
-
-  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
-     not try to write out the symbols.  */
-  bfd_get_symcount (abfd) = 0;
-
-  return TRUE;
+    if (buf != NULL)
+      free (buf);
 
- error_return:
-  if (debug_merge_allocated)
-    coff_debug_merge_hash_table_free (&finfo.debug_merge);
-  if (finfo.strtab != NULL)
-    _bfd_stringtab_free (finfo.strtab);
-  if (finfo.section_info != NULL)
+  /* If this object is the same format as the output object, and it is
+     not a shared library, then let the backend look through the
+     relocs.
+
+     This is required to build global offset table entries and to
+     arrange for dynamic relocs.  It is not required for the
+     particular common case of linking non PIC code, even when linking
+     against shared libraries, but unfortunately there is no way of
+     knowing whether an object file has been compiled PIC or not.
+     Looking through the relocs is not particularly time consuming.
+     The problem is that we must either (1) keep the relocs in memory,
+     which causes the linker to require additional runtime memory or
+     (2) read the relocs twice from the input file, which wastes time.
+     This would be a good case for using mmap.
+
+     I have no idea how to handle linking PIC code into a file of a
+     different format.  It probably can't be done.  */
+
+  if (! dynamic
+      && (abfd->xvec == info->hash->creator
+         || abfd->xvec == info->hash->creator->input_format)
+      )
     {
-      unsigned int i;
+      asection *o;
 
-      for (i = 0; i < abfd->section_count; i++)
+      for (o = abfd->sections; o != NULL; o = o->next)
 	{
-	  if (finfo.section_info[i].relocs != NULL)
-	    free (finfo.section_info[i].relocs);
-	  if (finfo.section_info[i].rel_hashes != NULL)
-	    free (finfo.section_info[i].rel_hashes);
-	}
-      free (finfo.section_info);
-    }
-  if (finfo.internal_syms != NULL)
-    free (finfo.internal_syms);
-  if (finfo.sec_ptrs != NULL)
-    free (finfo.sec_ptrs);
-  if (finfo.sym_indices != NULL)
-    free (finfo.sym_indices);
-  if (finfo.outsyms != NULL)
-    free (finfo.outsyms);
-  if (finfo.linenos != NULL)
-    free (finfo.linenos);
-  if (finfo.contents != NULL)
-    free (finfo.contents);
-  if (finfo.external_relocs != NULL)
-    free (finfo.external_relocs);
-  if (finfo.internal_relocs != NULL)
-    free (finfo.internal_relocs);
-  if (external_relocs != NULL)
-    free (external_relocs);
-  return FALSE;
-}
+	  struct internal_reloc *internal_relocs;
+	  bfd_boolean ok;
 
-/* Parse out a -heap <reserved>,<commit> line.  */
+	  if (o->reloc_count == 0)
+	     continue;
 
-static char *
-dores_com (char *ptr, bfd *output_bfd, int heap)
-{
-  if (coff_data(output_bfd)->pe)
-    {
-      int val = strtoul (ptr, &ptr, 0);
+	  internal_relocs = _bfd_coff_read_internal_relocs
+			     (abfd, o, info->keep_memory, NULL,
+			      FALSE, NULL);
 
-      if (heap)
-	pe_data(output_bfd)->pe_opthdr.SizeOfHeapReserve = val;
-      else
-	pe_data(output_bfd)->pe_opthdr.SizeOfStackReserve = val;
+	  if (internal_relocs == NULL)
+	    goto error_return;
 
-      if (ptr[0] == ',')
-	{
-	  val = strtoul (ptr+1, &ptr, 0);
-	  if (heap)
-	    pe_data(output_bfd)->pe_opthdr.SizeOfHeapCommit = val;
-	  else
-	    pe_data(output_bfd)->pe_opthdr.SizeOfStackCommit = val;
+	  ok = bfd_coff_backend_check_relocs(abfd, info, o, internal_relocs);
+
+	  if (! info->keep_memory)
+	    free (internal_relocs);
+
+	  if (! ok)
+	    goto error_return;
 	}
     }
-  return ptr;
-}
+#endif /* ] */
 
-static char *
-get_name (char *ptr, char **dst)
-{
-  while (*ptr == ' ')
-    ptr++;
-  *dst = ptr;
-  while (*ptr && *ptr != ' ')
-    ptr++;
-  *ptr = 0;
-  return ptr+1;
-}
 
-/* Process any magic embedded commands in a section called .drectve.  */
+  /* If this is a non-traditional, non-relocatable link, try to
+     optimize the handling of any .stab/.stabstr sections.  */
+  if (! info->relocatable
+      && ! info->traditional_format
+      && info->hash->creator->flavour == bfd_get_flavour (abfd)
+      && (info->strip != strip_all && info->strip != strip_debugger))
+    {
+      asection *stab, *stabstr;
 
-static int
-process_embedded_commands (bfd *output_bfd,
-			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
-			   bfd *abfd)
-{
-  asection *sec = bfd_get_section_by_name (abfd, ".drectve");
-  char *s;
-  char *e;
-  bfd_byte *copy;
+      stab = bfd_get_section_by_name (abfd, ".stab");
+      if (stab != NULL)
+	{
 
-  if (!sec)
-    return 1;
+      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
 
-  if (!bfd_malloc_and_get_section (abfd, sec, &copy))
+      if (stabstr != NULL)
     {
-      if (copy != NULL)
-	free (copy);
-      return 0;
-    }
-  e = (char *) copy + sec->size;
+	  bfd_size_type string_offset = 0;
+	  asection *stab;
 
-  for (s = (char *) copy; s < e ; )
-    {
-      if (s[0] != '-')
+	  for (stab = abfd->sections; stab; stab = stab->next)
+	    if (strncmp (".stab", stab->name, 5) == 0
+		&& (!stab->name[5]
+		    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))
 	{
-	  s++;
-	  continue;
-	}
-      if (strncmp (s, "-attr", 5) == 0)
+	      struct coff_link_hash_table *table;
+	      struct coff_section_tdata *secdata
+		= coff_section_data (abfd, stab);
+	      
+	      if (secdata == NULL)
 	{
-	  char *name;
-	  char *attribs;
-	  asection *asec;
-	  int loop = 1;
-	  int had_write = 0;
-	  int had_read = 0;
-	  int had_exec= 0;
-	  int had_shared= 0;
+		  amt = sizeof (struct coff_section_tdata);
+		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
+		  if (stab->used_by_bfd == NULL)
+		    goto error_return;
+		  secdata = coff_section_data (abfd, stab);
+		}
 
-	  s += 5;
-	  s = get_name (s, &name);
-	  s = get_name (s, &attribs);
+	      table = coff_hash_table (info);
 
-	  while (loop)
-	    {
-	      switch (*attribs++)
-		{
-		case 'W':
-		  had_write = 1;
-		  break;
-		case 'R':
-		  had_read = 1;
-		  break;
-		case 'S':
-		  had_shared = 1;
-		  break;
-		case 'X':
-		  had_exec = 1;
-		  break;
-		default:
-		  loop = 0;
+	      if (! _bfd_link_section_stabs (abfd, &table->stab_info,
+					     stab, stabstr,
+					     &secdata->stab_info,
+					     &string_offset))
+		goto error_return;
 		}
 	    }
-	  asec = bfd_get_section_by_name (abfd, name);
-	  if (asec)
-	    {
-	      if (had_exec)
-		asec->flags |= SEC_CODE;
-	      if (!had_write)
-		asec->flags |= SEC_READONLY;
 	    }
 	}
-      else if (strncmp (s,"-heap", 5) == 0)
-	s = dores_com (s+5, output_bfd, 1);
 
-      else if (strncmp (s,"-stack", 6) == 0)
-	s = dores_com (s+6, output_bfd, 0);
+  obj_coff_keep_syms (abfd) = keep_syms;
 
-      else
-	s++;
-    }
-  free (copy);
-  return 1;
+  return TRUE;
+
+ error_return:
+#ifdef DYNAMIC_LINKING
+  if (buf != NULL)
+    free (buf);
+#endif
+
+  obj_coff_keep_syms (abfd) = keep_syms;
+  return FALSE;
 }
 
-/* Place a marker against all symbols which are used by relocations.
-   This marker can be picked up by the 'do we skip this symbol ?'
-   loop in _bfd_coff_link_input_bfd() and used to prevent skipping
-   that symbol.  */
+/* Do the final link step.  */
 
-static void
-mark_relocs (struct coff_final_link_info *finfo, bfd *input_bfd)
+bfd_boolean
+_bfd_coff_final_link (bfd *abfd,
+		      struct bfd_link_info *info)
 {
-  asection * a;
-
-  if ((bfd_get_file_flags (input_bfd) & HAS_SYMS) == 0)
-    return;
+#ifdef DYNAMIC_LINKING
+  bfd_boolean dynamic;
+  bfd *dynobj;
+#endif
 
-  for (a = input_bfd->sections; a != (asection *) NULL; a = a->next)
-    {
-      struct internal_reloc *	internal_relocs;
-      struct internal_reloc *	irel;
-      struct internal_reloc *	irelend;
+  bfd_size_type symesz;
+  struct coff_final_link_info finfo;
+  bfd_boolean debug_merge_allocated;
+  bfd_boolean long_section_names;
+  asection *o;
+  struct bfd_link_order *p;
+  bfd_size_type max_sym_count;
+  bfd_size_type max_lineno_count;
+  bfd_size_type max_reloc_count;
+  bfd_size_type max_output_reloc_count;
+  bfd_size_type max_contents_size;
+  file_ptr rel_filepos;
+  unsigned int relsz;
+  file_ptr line_filepos;
+  unsigned int linesz;
+  bfd *sub;
+  bfd_byte *external_relocs = NULL;
+  char strbuf[STRING_SIZE_SIZE];
+  bfd_size_type amt;
 
-      if ((a->flags & SEC_RELOC) == 0 || a->reloc_count  < 1)
-	continue;
-      /* Don't mark relocs in excluded sections.  */
-      if (a->output_section == bfd_abs_section_ptr)
-	continue;
+#ifdef DYNAMIC_LINKING
+  if (info->shared)
+    abfd->flags |= DYNAMIC;
 
-      /* Read in the relocs.  */
-      internal_relocs = _bfd_coff_read_internal_relocs
-	(input_bfd, a, FALSE,
-	 finfo->external_relocs,
-	 finfo->info->relocatable,
-	 (finfo->info->relocatable
-	  ? (finfo->section_info[ a->output_section->target_index ].relocs + a->output_section->reloc_count)
-	  : finfo->internal_relocs)
-	);
+  dynamic = coff_hash_table (info)->dynamic_sections_created;
+  dynobj = coff_hash_table (info)->dynobj;
+#endif
 
-      if (internal_relocs == NULL)
-	continue;
+  symesz = bfd_coff_symesz (abfd);
 
-      irel     = internal_relocs;
-      irelend  = irel + a->reloc_count;
+  finfo.info = info;
+  finfo.output_bfd = abfd;
+  finfo.strtab = NULL;
+  finfo.section_info = NULL;
+  finfo.last_file_index = -1;
+  finfo.last_bf_index = -1;
+  finfo.internal_syms = NULL;
+  finfo.sec_ptrs = NULL;
+  finfo.sym_indices = NULL;
+  finfo.outsyms = NULL;
+  finfo.linenos = NULL;
+  finfo.contents = NULL;
+  finfo.external_relocs = NULL;
+  finfo.internal_relocs = NULL;
+  finfo.global_to_static = FALSE;
+  debug_merge_allocated = FALSE;
 
-      /* Place a mark in the sym_indices array (whose entries have
-	 been initialised to 0) for all of the symbols that are used
-	 in the relocation table.  This will then be picked up in the
-	 skip/don't-skip pass.  */
-      for (; irel < irelend; irel++)
-	finfo->sym_indices[ irel->r_symndx ] = -1;
+#ifdef DYNAMIC_LINKING
+  if (! dynamic)
+    {
+      finfo.dynsym_sec = NULL;
+      finfo.hash_sec = NULL;
+      finfo.symver_sec = NULL;
     }
-}
-
-/* Link an input file into the linker output file.  This function
-   handles all the sections and relocations of the input file at once.  */
-
-bfd_boolean
-_bfd_coff_link_input_bfd (struct coff_final_link_info *finfo, bfd *input_bfd)
-{
-  unsigned int n_tmask = coff_data (input_bfd)->local_n_tmask;
-  unsigned int n_btshft = coff_data (input_bfd)->local_n_btshft;
-  bfd_boolean (*adjust_symndx)
-    (bfd *, struct bfd_link_info *, bfd *, asection *,
-     struct internal_reloc *, bfd_boolean *);
-  bfd *output_bfd;
-  const char *strings;
-  bfd_size_type syment_base;
-  bfd_boolean copy, hash;
-  bfd_size_type isymesz;
-  bfd_size_type osymesz;
-  bfd_size_type linesz;
-  bfd_byte *esym;
-  bfd_byte *esym_end;
-  struct internal_syment *isymp;
-  asection **secpp;
-  long *indexp;
-  unsigned long output_index;
-  bfd_byte *outsym;
-  struct coff_link_hash_entry **sym_hash;
-  asection *o;
-
-  /* Move all the symbols to the output file.  */
-
-  output_bfd = finfo->output_bfd;
-  strings = NULL;
-  syment_base = obj_raw_syment_count (output_bfd);
-  isymesz = bfd_coff_symesz (input_bfd);
-  osymesz = bfd_coff_symesz (output_bfd);
-  linesz = bfd_coff_linesz (input_bfd);
-  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));
+  else
+    {
+      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
+      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
+      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
+      /* Note that it is OK if symver_sec is NULL.  */
+    }
+#endif
 
-  copy = FALSE;
-  if (! finfo->info->keep_memory)
-    copy = TRUE;
-  hash = TRUE;
-  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
-    hash = FALSE;
 
-  if (! _bfd_coff_get_external_symbols (input_bfd))
-    return FALSE;
+  coff_data (abfd)->link_info = info;
 
-  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
-  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
-  isymp = finfo->internal_syms;
-  secpp = finfo->sec_ptrs;
-  indexp = finfo->sym_indices;
-  output_index = syment_base;
-  outsym = finfo->outsyms;
+  finfo.strtab = _bfd_stringtab_init ();
+  if (finfo.strtab == NULL)
+    goto error_return;
 
-  if (coff_data (output_bfd)->pe
-      && ! process_embedded_commands (output_bfd, finfo->info, input_bfd))
-    return FALSE;
+  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
+    goto error_return;
+  debug_merge_allocated = TRUE;
 
-  /* If we are going to perform relocations and also strip/discard some
-     symbols then we must make sure that we do not strip/discard those
-     symbols that are going to be involved in the relocations.  */
-  if ((   finfo->info->strip   != strip_none
-       || finfo->info->discard != discard_none)
-      && finfo->info->relocatable)
+  /* Compute the file positions for all the sections.  */
+  if (! abfd->output_has_begun)
     {
-      /* Mark the symbol array as 'not-used'.  */
-      memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp);
-
-      mark_relocs (finfo, input_bfd);
+      if (! bfd_coff_compute_section_file_positions (abfd))
+	goto error_return;
     }
 
-  while (esym < esym_end)
+  /* Count the line numbers and relocation entries required for the
+     output file.  Set the file positions for the relocs.  */
+  rel_filepos = obj_relocbase (abfd);
+  relsz = bfd_coff_relsz (abfd);
+  max_contents_size = 0;
+  max_lineno_count = 0;
+  max_reloc_count = 0;
+
+  long_section_names = FALSE;
+  for (o = abfd->sections; o != NULL; o = o->next)
     {
-      struct internal_syment isym;
-      enum coff_symbol_classification classification;
-      bfd_boolean skip;
-      bfd_boolean global;
-      bfd_boolean dont_skip_symbol;
-      int add;
+      o->reloc_count = 0;
+      o->lineno_count = 0;
+      for (p = o->map_head.link_order; p != NULL; p = p->next)
+	{
+	  if (p->type == bfd_indirect_link_order)
+	    {
+	      asection *sec;
 
-      bfd_coff_swap_sym_in (input_bfd, esym, isymp);
+	      sec = p->u.indirect.section;
 
-      /* Make a copy of *isymp so that the relocate_section function
+	      /* Mark all sections which are to be included in the
+		 link.  This will normally be every section.  We need
+		 to do this so that we can identify any sections which
+		 the linker has decided to not include.  */
+	      sec->linker_mark = TRUE;
+
+	      if (info->strip == strip_none
+		  || info->strip == strip_some)
+		o->lineno_count += sec->lineno_count;
+
+	      if (info->relocatable)
+		o->reloc_count += sec->reloc_count;
+
+	      if (sec->size > max_contents_size)
+		max_contents_size = sec->size;
+	      if (sec->size > max_contents_size)
+		max_contents_size = sec->size;
+	      if (sec->lineno_count > max_lineno_count)
+		max_lineno_count = sec->lineno_count;
+	      if (sec->reloc_count > max_reloc_count)
+		max_reloc_count = sec->reloc_count;
+	    }
+	  else if (info->relocatable
+		   && (p->type == bfd_section_reloc_link_order
+		       || p->type == bfd_symbol_reloc_link_order))
+	    ++o->reloc_count;
+	}
+      if (o->reloc_count == 0)
+	o->rel_filepos = 0;
+      else
+	{
+	  o->flags |= SEC_RELOC;
+	  o->rel_filepos = rel_filepos;
+	  rel_filepos += o->reloc_count * relsz;
+	  /* In PE COFF, if there are at least 0xffff relocations an
+	     extra relocation will be written out to encode the count.  */
+	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
+	    rel_filepos += relsz;
+	}
+
+      if (bfd_coff_long_section_names (abfd)
+	  && strlen (o->name) > SCNNMLEN)
+	{
+	  /* This section has a long name which must go in the string
+             table.  This must correspond to the code in
+             coff_write_object_contents which puts the string index
+             into the s_name field of the section header.  That is why
+             we pass hash as FALSE.  */
+	  if (_bfd_stringtab_add (finfo.strtab, o->name, FALSE, FALSE)
+	      == (bfd_size_type) -1)
+	    goto error_return;
+	  long_section_names = TRUE;
+	}
+    }
+
+  /* If doing a relocatable link, allocate space for the pointers we
+     need to keep.  */
+  if (info->relocatable)
+    {
+      unsigned int i;
+
+      /* We use section_count + 1, rather than section_count, because
+         the target_index fields are 1 based.  */
+      amt = abfd->section_count + 1;
+      amt *= sizeof (struct coff_link_section_info);
+      finfo.section_info = bfd_malloc (amt);
+      if (finfo.section_info == NULL)
+	goto error_return;
+      for (i = 0; i <= abfd->section_count; i++)
+	{
+	  finfo.section_info[i].relocs = NULL;
+	  finfo.section_info[i].rel_hashes = NULL;
+	}
+    }
+
+  /* We now know the size of the relocs, so we can determine the file
+     positions of the line numbers.  */
+  line_filepos = rel_filepos;
+  linesz = bfd_coff_linesz (abfd);
+  max_output_reloc_count = 0;
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      if (o->lineno_count == 0)
+	o->line_filepos = 0;
+      else
+	{
+	  o->line_filepos = line_filepos;
+	  line_filepos += o->lineno_count * linesz;
+	}
+
+      if (o->reloc_count != 0)
+	{
+	  /* We don't know the indices of global symbols until we have
+             written out all the local symbols.  For each section in
+             the output file, we keep an array of pointers to hash
+             table entries.  Each entry in the array corresponds to a
+             reloc.  When we find a reloc against a global symbol, we
+             set the corresponding entry in this array so that we can
+             fix up the symbol index after we have written out all the
+             local symbols.
+
+	     Because of this problem, we also keep the relocs in
+	     memory until the end of the link.  This wastes memory,
+	     but only when doing a relocatable link, which is not the
+	     common case.  */
+	  BFD_ASSERT (info->relocatable);
+	  amt = o->reloc_count;
+	  amt *= sizeof (struct internal_reloc);
+	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
+	  amt = o->reloc_count;
+	  amt *= sizeof (struct coff_link_hash_entry *);
+	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
+	  if (finfo.section_info[o->target_index].relocs == NULL
+	      || finfo.section_info[o->target_index].rel_hashes == NULL)
+	    goto error_return;
+
+	  if (o->reloc_count > max_output_reloc_count)
+	    max_output_reloc_count = o->reloc_count;
+	}
+
+      /* Reset the reloc and lineno counts, so that we can use them to
+	 count the number of entries we have output so far.  */
+      o->reloc_count = 0;
+      o->lineno_count = 0;
+    }
+
+  obj_sym_filepos (abfd) = line_filepos;
+
+  /* Figure out the largest number of symbols in an input BFD.  Take
+     the opportunity to clear the output_has_begun fields of all the
+     input BFD's.  */
+  max_sym_count = 0;
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      size_t sz;
+
+      sub->output_has_begun = FALSE;
+      sz = obj_raw_syment_count (sub);
+      if (sz > max_sym_count)
+	max_sym_count = sz;
+    }
+
+  /* Allocate some buffers used while linking.  */
+  amt = max_sym_count * sizeof (struct internal_syment);
+  finfo.internal_syms = bfd_malloc (amt);
+  amt = max_sym_count * sizeof (asection *);
+  finfo.sec_ptrs = bfd_malloc (amt);
+  amt = max_sym_count * sizeof (long);
+  finfo.sym_indices = bfd_malloc (amt);
+  finfo.outsyms = bfd_malloc ((max_sym_count + 1) * symesz);
+  amt = max_lineno_count * bfd_coff_linesz (abfd);
+  finfo.linenos = bfd_malloc (amt);
+  finfo.contents = bfd_malloc (max_contents_size);
+  amt = max_reloc_count * relsz;
+  finfo.external_relocs = bfd_malloc (amt);
+  if (! info->relocatable)
+    {
+      amt = max_reloc_count * sizeof (struct internal_reloc);
+      finfo.internal_relocs = bfd_malloc (amt);
+    }
+  if ((finfo.internal_syms == NULL && max_sym_count > 0)
+      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
+      || (finfo.sym_indices == NULL && max_sym_count > 0)
+      || finfo.outsyms == NULL
+      || (finfo.linenos == NULL && max_lineno_count > 0)
+      || (finfo.contents == NULL && max_contents_size > 0)
+      || (finfo.external_relocs == NULL && max_reloc_count > 0)
+      || (! info->relocatable
+	  && finfo.internal_relocs == NULL
+	  && max_reloc_count > 0))
+    goto error_return;
+
+  /* We now know the position of everything in the file, except that
+     we don't know the size of the symbol table and therefore we don't
+     know where the string table starts.  We just build the string
+     table in memory as we go along.  We process all the relocations
+     for a single input file at once.  */
+  obj_raw_syment_count (abfd) = 0;
+
+  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
+    {
+      if (! bfd_coff_start_final_link (abfd, info))
+	goto error_return;
+    }
+
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+      for (p = o->map_head.link_order; p != NULL; p = p->next)
+	{
+	  if (p->type == bfd_indirect_link_order
+	      && bfd_family_coff (p->u.indirect.section->owner))
+	    {
+	      sub = p->u.indirect.section->owner;
+	      if (! bfd_coff_link_output_has_begun (sub, & finfo))
+		{
+		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
+		    goto error_return;
+		  sub->output_has_begun = TRUE;
+		}
+	    }
+	  else if (p->type == bfd_section_reloc_link_order
+		   || p->type == bfd_symbol_reloc_link_order)
+	    {
+	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
+		goto error_return;
+	    }
+	  else
+	    {
+	      if (! _bfd_default_link_order (abfd, info, o, p))
+		goto error_return;
+	    }
+	}
+    }
+
+  /* Are there any input bfd's for which output_has_begun didn't
+     get set?  If so, the symbols still participate, but the 
+     sections don't.  The per-section linker_mark flag should
+     keep the individual sections from being linked.
+     This also covers the case of section-less .o files. */
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      if (! bfd_coff_link_output_has_begun (sub, & finfo))
+	{
+	  if (! _bfd_coff_link_input_bfd (&finfo, sub))
+	    goto error_return;
+	  sub->output_has_begun = TRUE;
+	}
+    }
+
+  if (! bfd_coff_final_link_postscript (abfd, & finfo))
+    goto error_return;
+
+  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */
+
+  coff_debug_merge_hash_table_free (&finfo.debug_merge);
+  debug_merge_allocated = FALSE;
+
+  if (finfo.internal_syms != NULL)
+    {
+      free (finfo.internal_syms);
+      finfo.internal_syms = NULL;
+    }
+  if (finfo.sec_ptrs != NULL)
+    {
+      free (finfo.sec_ptrs);
+      finfo.sec_ptrs = NULL;
+    }
+  if (finfo.sym_indices != NULL)
+    {
+      free (finfo.sym_indices);
+      finfo.sym_indices = NULL;
+    }
+  if (finfo.linenos != NULL)
+    {
+      free (finfo.linenos);
+      finfo.linenos = NULL;
+    }
+  if (finfo.contents != NULL)
+    {
+      free (finfo.contents);
+      finfo.contents = NULL;
+    }
+  if (finfo.external_relocs != NULL)
+    {
+      free (finfo.external_relocs);
+      finfo.external_relocs = NULL;
+    }
+  if (finfo.internal_relocs != NULL)
+    {
+      free (finfo.internal_relocs);
+      finfo.internal_relocs = NULL;
+    }
+
+  /* The value of the last C_FILE symbol is supposed to be the symbol
+     index of the first external symbol.  Write it out again if
+     necessary.  */
+  if (finfo.last_file_index != -1
+      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
+    {
+      file_ptr pos;
+
+      finfo.last_file.n_value = obj_raw_syment_count (abfd);
+      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
+			     finfo.outsyms);
+
+      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
+      if (bfd_seek (abfd, pos, SEEK_SET) != 0
+	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
+	return FALSE;
+    }
+
+  /* If doing task linking (ld --task-link) then make a pass through the
+     global symbols, writing out any that are defined, and making them
+     static.  */
+  if (info->task_link)
+    {
+      finfo.failed = FALSE;
+      coff_link_hash_traverse (coff_hash_table (info),
+			       _bfd_coff_write_task_globals, &finfo);
+      if (finfo.failed)
+	goto error_return;
+    }
+
+  /* Write out the global symbols.  */
+  finfo.failed = FALSE;
+  coff_link_hash_traverse (coff_hash_table (info),
+			   _bfd_coff_write_global_sym, &finfo);
+  if (finfo.failed)
+    goto error_return;
+
+  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
+  if (finfo.outsyms != NULL)
+    {
+      free (finfo.outsyms);
+      finfo.outsyms = NULL;
+    }
+
+  if (info->relocatable && max_output_reloc_count > 0)
+    {
+      /* Now that we have written out all the global symbols, we know
+	 the symbol indices to use for relocs against them, and we can
+	 finally write out the relocs.  */
+      amt = max_output_reloc_count * relsz;
+      external_relocs = bfd_malloc (amt);
+      if (external_relocs == NULL)
+	goto error_return;
+
+      for (o = abfd->sections; o != NULL; o = o->next)
+	{
+	  struct internal_reloc *irel;
+	  struct internal_reloc *irelend;
+	  struct coff_link_hash_entry **rel_hash;
+	  bfd_byte *erel;
+
+	  if (o->reloc_count == 0)
+	    continue;
+
+	  irel = finfo.section_info[o->target_index].relocs;
+	  irelend = irel + o->reloc_count;
+	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
+	  erel = external_relocs;
+	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
+	    {
+	      if (*rel_hash != NULL)
+		{
+		  BFD_ASSERT ((*rel_hash)->indx >= 0);
+		  irel->r_symndx = (*rel_hash)->indx;
+		}
+	      bfd_coff_swap_reloc_out (abfd, irel, erel);
+	    }
+
+	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)
+	    goto error_return;
+	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
+	    {
+	      /* In PE COFF, write the count of relocs as the first
+		 reloc.  The header overflow bit will be set
+		 elsewhere. */
+	      struct internal_reloc incount;
+	      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);
+	      
+	      memset (&incount, 0, sizeof (incount));
+	      incount.r_vaddr = o->reloc_count + 1;
+	      bfd_coff_swap_reloc_out (abfd, (PTR) &incount, (PTR) excount);
+	      if (bfd_bwrite (excount, relsz, abfd) != relsz)
+		/* We'll leak, but it's an error anyway. */
+		goto error_return;
+	      free (excount);
+	    }
+	  if (bfd_bwrite (external_relocs,
+			  (bfd_size_type) relsz * o->reloc_count, abfd)
+	      != (bfd_size_type) relsz * o->reloc_count)
+	    goto error_return;
+	}
+
+      free (external_relocs);
+      external_relocs = NULL;
+    }
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If we are linking against a dynamic object, or generating a
+     shared library, finish up the dynamic linking information.  */
+  if (dynamic)
+    {
+      coff_external_dyn *dyncon, *dynconend;
+
+      /* Fix up .dynamic entries.  */
+      o = coff_hash_table (info)->dynamic;
+      BFD_ASSERT (o != NULL);
+
+      dyncon = (coff_external_dyn *) o->contents;
+      dynconend = (coff_external_dyn *) (o->contents + o->size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  coff_internal_dyn dyn;
+	  const char *name;
+
+	  bfd_coff_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  /* In the PE environment, the "addresses" here end up being
+	     RVAs (ImageBase not applied) */
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	      /* SVR4 linkers seem to set DT_INIT and DT_FINI based on
+                 magic _init and _fini symbols.  This is pretty ugly,
+                 but we are compatible.  */
+	    case DT_INIT:
+	      name = &"__init"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1];
+	      goto get_sym;
+	    case DT_FINI:
+	      name = &"__fini"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1];
+	    get_sym:
+	      {
+		struct coff_link_hash_entry *h;
+
+		h = coff_link_hash_lookup (coff_hash_table (info), name,
+					  FALSE, FALSE, TRUE);
+		if (h != NULL
+		    && (h->root.type == bfd_link_hash_defined
+			|| h->root.type == bfd_link_hash_defweak))
+		  {
+		    dyn.d_un.d_val = h->root.u.def.value;
+		    o = h->root.u.def.section;
+		    if (o->output_section != NULL
+      			&& (h->coff_link_hash_flags 
+			    & COFF_LINK_HASH_DEF_REGULAR) != 0)
+		      dyn.d_un.d_val += (o->output_section->vma
+					 + o->output_offset);
+		    else
+		      {
+			/* The symbol is imported from another shared
+			   library and does not apply to this one.  */
+			dyn.d_un.d_val = 0;
+		      }
+
+		    bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		  }
+	      }
+	      break;
+
+	    case DT_HASH:
+	      name = ".hash";
+	      goto get_vma;
+	    case DT_STRTAB:
+	      name = ".dynstr";
+	      goto get_vma;
+	    case DT_SYMTAB:
+	      name = ".dynsym";
+	      goto get_vma;
+	    case DT_VERDEF:
+	      name = ".gnu.version_d";
+	      goto get_vma;
+	    case DT_VERNEED:
+	      name = ".gnu.version_r";
+	      goto get_vma;
+	    case DT_VERSYM:
+	      name = ".gnu.version";
+	    get_vma:
+	      o = bfd_get_section_by_name (dynobj, name);
+	      BFD_ASSERT (o != NULL);
+	      dyn.d_un.d_ptr = o->output_section->vma 
+			       + o->vma + o->output_offset;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_RELSZ:
+	      {
+		 asection *sec;
+		/* Get the number of relocations */
+		sec = bfd_get_section_by_name(abfd, ".rel.dyn");
+		dyn.d_un.d_val = sec->size;
+		bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		break;
+	      }
+
+	    case DT_REL:
+	      {
+		asection *sec;
+		/* Get the location of the dynamic relocation section */
+		sec = bfd_get_section_by_name(abfd, ".rel.dyn");
+		dyn.d_un.d_val = sec->vma + sec->output_offset;
+		bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		break;
+		}
+	    }
+	}
+
+      if (! bfd_coff_backend_finish_dynamic_sections (abfd, info))
+	goto error_return;
+    }
+
+  /* This needs to be done even for simple static loads in case some
+     PIC code slipped into our world, but only if they actually did. */
+  if (dynobj != NULL)
+    {
+      for (o = dynobj->sections; o != NULL; o = o->next)
+	{
+#if 1
+	  /*
+	   * mayank@10th sept, 2007
+	   * HACK
+	   */
+	if (strncmp(o->name,".stabstr",8)==0 )
+		o->flags =o->flags & (~SEC_LINKER_CREATED);
+#endif
+
+	  if ((o->flags & SEC_HAS_CONTENTS) == 0
+	      || o->size == 0)
+	    continue;
+
+	  if ((o->flags & SEC_LINKER_CREATED) == 0)
+	    {
+	      /* At this point, we are only interested in sections
+		 created by coff_link_create_dynamic_sections.  */
+	      continue;
+	    }
+
+	  if (strcmp (bfd_get_section_name (abfd, o), ".rel.internal") == 0
+	      || strcmp (bfd_get_section_name (abfd, o), ".rel.got") == 0
+	      || strcmp (bfd_get_section_name (abfd, o), ".rel.plt") == 0)
+	    {
+    if(o->size != o->reloc_count*bfd_coff_relsz(abfd)) fprintf(stderr, "%s %ld %d:\n",bfd_get_section_name(abfd,o), o->size, o->reloc_count * bfd_coff_relsz(abfd)); //
+	       /* Dynamic reloc section */
+	       BFD_ASSERT(o->size == o->reloc_count*bfd_coff_relsz(abfd));
+
+	       /* even tho the assert fails, it returns, and not zeroing it
+		  out creates havoc later.  If the section was too short,
+		  the havoc has already happened. */
+	       if (o->size > o->reloc_count*bfd_coff_relsz(abfd))
+		   memset (o->contents+o->reloc_count*bfd_coff_relsz(abfd), 0, 
+		     o->size - o->reloc_count*bfd_coff_relsz(abfd));
+	       if (strcmp (bfd_get_section_name(abfd, o), ".rel.internal") == 0)
+		 {
+		   extern int reloc_compar(const void *, const void *);
+
+		   /* sort the relocations.  It only really works to sort
+		      rel.internal: GOT is in a separate section, and 
+		      merging them together is a pain.  PLT must be a separate
+		      chunk at runtime.  Both PLT and GOT should have only
+		      one entry per symbol.  Thus, we just sort .rel.internal.
+		      We sort it so that at runtime, the runtime linker
+		      can cluster symbol lookups to the same symbol. */
+
+		   qsort(o->contents, o->reloc_count, bfd_coff_relsz(abfd),
+		      reloc_compar);
+		 }
+	    }
+
+	  if (strcmp (bfd_get_section_name (abfd, o), ".dynstr") == 0)
+	    {
+	      file_ptr off;
+
+	      /* The contents of the .dynstr section are actually in a
+		 stringtab.  */
+	      off = o->output_section->filepos;
+	      if (bfd_seek (abfd, off, SEEK_SET) != 0
+		  || ! _bfd_stringtab_emit (abfd,
+					    coff_hash_table (info)->dynstr))
+		goto error_return;
+	    }
+	  else
+	    {
+	      /* all other sections are not string sections */
+	      if (! bfd_set_section_contents (abfd, o->output_section,
+					      o->contents, o->output_offset,
+					      o->size))
+		goto error_return;
+	    }
+	}
+    }
+#endif /* ] */
+
+  /* Free up the section information.  */
+  if (finfo.section_info != NULL)
+    {
+      unsigned int i;
+
+      for (i = 0; i < abfd->section_count; i++)
+	{
+	  if (finfo.section_info[i].relocs != NULL)
+	    free (finfo.section_info[i].relocs);
+	  if (finfo.section_info[i].rel_hashes != NULL)
+	    free (finfo.section_info[i].rel_hashes);
+	}
+      free (finfo.section_info);
+      finfo.section_info = NULL;
+    }
+
+  /* If we have optimized stabs strings, output them.  */
+  if (coff_hash_table (info)->stab_info.stabstr != NULL)
+    {
+      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
+	return FALSE;
+    }
+
+  /* Write out the string table.  */
+  if (obj_raw_syment_count (abfd) != 0 || long_section_names)
+    {
+      file_ptr pos;
+
+      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
+      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
+	return FALSE;
+
+#if STRING_SIZE_SIZE == 4
+      H_PUT_32 (abfd,
+		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
+		strbuf);
+#else
+ #error Change H_PUT_32 above
+#endif
+
+      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
+	  != STRING_SIZE_SIZE)
+	return FALSE;
+
+      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
+	return FALSE;
+
+      obj_coff_strings_written (abfd) = TRUE;
+    }
+
+  _bfd_stringtab_free (finfo.strtab);
+
+  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
+     not try to write out the symbols.  */
+  bfd_get_symcount (abfd) = 0;
+
+  return TRUE;
+
+ error_return:
+  if (debug_merge_allocated)
+    coff_debug_merge_hash_table_free (&finfo.debug_merge);
+  if (finfo.strtab != NULL)
+    _bfd_stringtab_free (finfo.strtab);
+  if (finfo.section_info != NULL)
+    {
+      unsigned int i;
+
+      for (i = 0; i < abfd->section_count; i++)
+	{
+	  if (finfo.section_info[i].relocs != NULL)
+	    free (finfo.section_info[i].relocs);
+	  if (finfo.section_info[i].rel_hashes != NULL)
+	    free (finfo.section_info[i].rel_hashes);
+	}
+      free (finfo.section_info);
+    }
+  if (finfo.internal_syms != NULL)
+    free (finfo.internal_syms);
+  if (finfo.sec_ptrs != NULL)
+    free (finfo.sec_ptrs);
+  if (finfo.sym_indices != NULL)
+    free (finfo.sym_indices);
+  if (finfo.outsyms != NULL)
+    free (finfo.outsyms);
+  if (finfo.linenos != NULL)
+    free (finfo.linenos);
+  if (finfo.contents != NULL)
+    free (finfo.contents);
+  if (finfo.external_relocs != NULL)
+    free (finfo.external_relocs);
+  if (finfo.internal_relocs != NULL)
+    free (finfo.internal_relocs);
+  if (external_relocs != NULL)
+    free (external_relocs);
+  return FALSE;
+}
+
+/* Parse out a -heap <reserved>,<commit> line.  */
+
+static char *
+dores_com (char *ptr, bfd *output_bfd, int heap)
+{
+  if (coff_data(output_bfd)->pe)
+    {
+      int val = strtoul (ptr, &ptr, 0);
+
+      if (heap)
+	pe_data(output_bfd)->pe_opthdr.SizeOfHeapReserve = val;
+      else
+	pe_data(output_bfd)->pe_opthdr.SizeOfStackReserve = val;
+
+      if (ptr[0] == ',')
+	{
+	  val = strtoul (ptr+1, &ptr, 0);
+	  if (heap)
+	    pe_data(output_bfd)->pe_opthdr.SizeOfHeapCommit = val;
+	  else
+	    pe_data(output_bfd)->pe_opthdr.SizeOfStackCommit = val;
+	}
+    }
+  return ptr;
+}
+
+static char *
+get_name (char *ptr, char **dst)
+{
+  while (*ptr == ' ')
+    ptr++;
+  *dst = ptr;
+  while (*ptr && *ptr != ' ')
+    ptr++;
+  *ptr = 0;
+  return ptr+1;
+}
+
+/* Process any magic embedded commands in a section called .drectve.  */
+
+static int
+process_embedded_commands (bfd *output_bfd,
+			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			   bfd *abfd)
+{
+  asection *sec = bfd_get_section_by_name (abfd, ".drectve");
+  char *s;
+  char *e;
+  bfd_byte *copy;
+
+  if (!sec)
+    return 1;
+
+
+  if (!bfd_malloc_and_get_section (abfd, sec, &copy))
+    {
+      if (copy != NULL)
+	free (copy);
+      return 0;
+    }
+  e = (char *) copy + sec->size;
+
+  for (s = (char *) copy; s < e ; )
+    {
+      if (s[0] != '-')
+	{
+	  s++;
+	  continue;
+	}
+      if (strncmp (s, "-attr", 5) == 0)
+	{
+	  char *name;
+	  char *attribs;
+	  asection *asec;
+	  int loop = 1;
+	  int had_write = 0;
+	  int had_read = 0;
+	  int had_exec= 0;
+	  int had_shared= 0;
+
+	  s += 5;
+	  s = get_name (s, &name);
+	  s = get_name (s, &attribs);
+
+	  while (loop)
+	    {
+	      switch (*attribs++)
+		{
+		case 'W':
+		  had_write = 1;
+		  break;
+		case 'R':
+		  had_read = 1;
+		  break;
+		case 'S':
+		  had_shared = 1;
+		  break;
+		case 'X':
+		  had_exec = 1;
+		  break;
+		default:
+		  loop = 0;
+		}
+	    }
+	  asec = bfd_get_section_by_name (abfd, name);
+	  if (asec)
+	    {
+	      if (had_exec)
+		asec->flags |= SEC_CODE;
+	      if (!had_write)
+		asec->flags |= SEC_READONLY;
+	    }
+	}
+      else if (strncmp (s,"-heap", 5) == 0)
+	s = dores_com (s+5, output_bfd, 1);
+
+      else if (strncmp (s,"-stack", 6) == 0)
+	s = dores_com (s+6, output_bfd, 0);
+
+      else
+	s++;
+    }
+  free (copy);
+  return 1;
+}
+
+/* Place a marker against all symbols which are used by relocations.
+   This marker can be picked up by the 'do we skip this symbol ?'
+   loop in _bfd_coff_link_input_bfd() and used to prevent skipping
+   that symbol.  */
+
+static void
+mark_relocs (struct coff_final_link_info *finfo, bfd *input_bfd)
+{
+  asection * a;
+
+  if ((bfd_get_file_flags (input_bfd) & HAS_SYMS) == 0)
+    return;
+
+  for (a = input_bfd->sections; a != (asection *) NULL; a = a->next)
+    {
+      struct internal_reloc *	internal_relocs;
+      struct internal_reloc *	irel;
+      struct internal_reloc *	irelend;
+
+      if ((a->flags & SEC_RELOC) == 0 || a->reloc_count  < 1
+	|| a->linker_mark == 0)
+	continue;
+      /* Don't mark relocs in excluded sections.  */
+      if (a->output_section == bfd_abs_section_ptr)
+	continue;
+
+      /* Read in the relocs.  */
+      internal_relocs = _bfd_coff_read_internal_relocs
+	(input_bfd, a, FALSE,
+	 finfo->external_relocs,
+	 finfo->info->relocatable,
+	 (finfo->info->relocatable
+	  ? (finfo->section_info[ a->output_section->target_index ].relocs + a->output_section->reloc_count)
+	  : finfo->internal_relocs)
+	);
+
+      if (internal_relocs == NULL)
+	continue;
+
+      irel     = internal_relocs;
+      irelend  = irel + a->reloc_count;
+
+      /* Place a mark in the sym_indices array (whose entries have
+	 been initialised to 0) for all of the symbols that are used
+	 in the relocation table.  This will then be picked up in the
+	 skip/don't-skip pass.  */
+      for (; irel < irelend; irel++)
+	finfo->sym_indices[ irel->r_symndx ] = -1;
+    }
+}
+
+#ifdef DYNAMIC_LINKING /* [ */
+/* Standard ELF hash function.  Could be changed for COFF, but why bother */
+static unsigned long bfd_coff_hash PARAMS((CONST unsigned char *name));
+static unsigned long
+bfd_coff_hash (name)
+     CONST unsigned char *name;
+{
+  unsigned long h = 0;
+  unsigned long g;
+  int ch;
+
+  while ((ch = *name++) != '\0')
+    {
+      h = (h << 4) + ch;
+      if ((g = (h & 0xf0000000)) != 0)
+        {
+          h ^= g >> 24;
+          h &= ~g;
+        }
+    }
+  return h;
+}
+
+static void _bfd_coff_output_dynamic_symbol PARAMS((struct internal_syment *, 
+    struct coff_link_hash_entry *, struct coff_final_link_info *finfo));
+
+/* Actually output the dynamic symbol (and it's hash and stringtable
+   supporting information) as needed */
+static void 
+_bfd_coff_output_dynamic_symbol(isym, h, finfo)
+    struct internal_syment *isym;
+    struct coff_link_hash_entry *h;
+    struct coff_final_link_info *finfo;
+{
+  char *p, *copy;
+  const char *name;
+  size_t bucketcount;
+  size_t bucket;
+  bfd_byte *bucketpos;
+  bfd_vma chain;
+  bfd_size_type symesz;
+
+  symesz = bfd_coff_symesz (finfo->output_bfd);
+
+  /* If this goes into a string table entry, we need to change the
+     index; if not, the inline symbol is just fine */
+  if (strlen (h->root.root.string) > SYMNMLEN)
+      isym->_n._n_n._n_offset = h->dynstr_index;
+
+  /* In general, we aren't interested in AUX entries.  However, for 
+     C_NT_WEAK we need the indirect symbol, which is in the AUX entry,
+     which needs to be updated for the dynindx.
+     Oh well...  */
+  if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias)
+    {
+      union internal_auxent aux;
+      struct coff_link_hash_entry *h_real = h;
+
+      /* Usually, an aux entry is present, but if the stars align just wrong,
+	 there isn't one.  Thus, just create one. */
+      while (h_real->root.type == bfd_link_hash_indirect
+	      && h_real->root.u.i.info.alias)
+	h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+      memset((PTR)&aux, 0, sizeof(aux));
+      aux.x_sym.x_tagndx.l = h_real->dynindx;
+      aux.x_sym.x_misc.x_fsize = 3;
+      isym->n_numaux = 1;
+
+      bfd_coff_swap_aux_out (finfo->output_bfd, (PTR)&aux, isym->n_type,
+			     isym->n_sclass, 0, 1,
+			     (PTR) (finfo->dynsym_sec->contents
+				  + (h->dynindx+1) * symesz));
+    }
+  else
+    {
+      isym->n_numaux = 0;
+    }
+
+  /* We're writing into an array here, so it's a bit more convenient
+     to write the real symbol after the AUX.  */
+
+  bfd_coff_swap_sym_out (finfo->output_bfd, isym,
+		       (PTR) (finfo->dynsym_sec->contents
+			      + h->dynindx * symesz));
+
+  /* We didn't include the version string in the dynamic string
+     table, so we must not consider it in the hash table.  */
+  name = h->root.root.string;
+  if (name[0] == '?' || (p = strchr (name, COFF_VER_CHR)) == NULL)
+    copy = NULL;
+  else
+    {
+      copy = bfd_alloc (finfo->output_bfd, p - name + 1);
+      strncpy (copy, name, p - name);
+      copy[p - name] = '\0';
+      name = copy;
+    }
+
+  bucketcount = coff_hash_table (finfo->info)->bucketcount;
+  bucket = bfd_coff_hash ((const unsigned char *) name) % bucketcount;
+  bucketpos = ((bfd_byte *) finfo->hash_sec->contents
+	       + (bucket + 2) * (ARCH_SIZE / 8));
+  chain = bfd_h_get_32 (finfo->output_bfd, bucketpos);
+  bfd_h_put_32 (finfo->output_bfd, h->dynindx, bucketpos);
+  bfd_h_put_32 (finfo->output_bfd, chain,
+	    ((bfd_byte *) finfo->hash_sec->contents
+	     + (bucketcount + 2 + h->dynindx) * (ARCH_SIZE / 8)));
+
+  if (copy != NULL)
+    bfd_release (finfo->output_bfd, copy);
+
+  if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
+    {
+      coff_internal_versym iversym;
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  if (h->verinfo.verdef == NULL)
+	    iversym.vs_vers = 0;
+	  else
+	    iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
+	}
+      else
+	{
+	  if (h->verinfo.vertree == NULL)
+	    iversym.vs_vers = 1;
+	  else
+	    iversym.vs_vers = h->verinfo.vertree->vernum + 1;
+	}
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HIDDEN) != 0)
+	iversym.vs_vers |= VERSYM_HIDDEN;
+
+      bfd_coff_swap_versym_out (finfo->output_bfd, &iversym,
+				(((coff_external_versym *)
+				  finfo->symver_sec->contents)
+				 + h->dynindx));
+    }
+    return;
+}
+#endif /* ] */
+
+
+/* Link an input file into the linker output file.  This function
+   handles all the sections and relocations of the input file at once.  */
+
+bfd_boolean
+_bfd_coff_link_input_bfd (struct coff_final_link_info *finfo, bfd *input_bfd)
+{
+  unsigned int n_tmask = coff_data (input_bfd)->local_n_tmask;
+  unsigned int n_btshft = coff_data (input_bfd)->local_n_btshft;
+  bfd_boolean (*adjust_symndx)
+    (bfd *, struct bfd_link_info *, bfd *, asection *,
+     struct internal_reloc *, bfd_boolean *);
+  bfd *output_bfd;
+  const char *strings;
+  bfd_size_type syment_base;
+  bfd_boolean copy, hash;
+  bfd_size_type isymesz;
+  bfd_size_type osymesz;
+  bfd_size_type linesz;
+  bfd_byte *esym;
+  bfd_byte *esym_end;
+  struct internal_syment *isymp;
+  asection **secpp;
+  long *indexp;
+  unsigned long output_index;
+  bfd_byte *outsym;
+  struct coff_link_hash_entry **sym_hash;
+  asection *o;
+  struct coff_link_hash_entry *h;
+  long indx;
+
+
+#ifdef DYNAMIC_LINKING
+  /* If this is a dynamic object, we don't want to do anything here:
+     we don't want the local symbols, and we don't want the section
+     contents.  */
+  if ((input_bfd->flags & DYNAMIC) != 0)
+     return TRUE;
+#endif
+
+
+  /* Move all the symbols to the output file.  */
+
+  output_bfd = finfo->output_bfd;
+  strings = NULL;
+  syment_base = obj_raw_syment_count (output_bfd);
+  isymesz = bfd_coff_symesz (input_bfd);
+  osymesz = bfd_coff_symesz (output_bfd);
+  linesz = bfd_coff_linesz (input_bfd);
+  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));
+
+  copy = FALSE;
+  if (! finfo->info->keep_memory)
+    copy = TRUE;
+  hash = TRUE;
+  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
+    hash = FALSE;
+
+  if (! _bfd_coff_get_external_symbols (input_bfd))
+    return FALSE;
+
+  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
+  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
+  isymp = finfo->internal_syms;
+  secpp = finfo->sec_ptrs;
+  indexp = finfo->sym_indices;
+  output_index = syment_base;
+  outsym = finfo->outsyms;
+
+  if (coff_data (output_bfd)->pe
+      && ! process_embedded_commands (output_bfd, finfo->info, input_bfd))
+    return FALSE;
+
+  /* If we are going to perform relocations and also strip/discard some
+     symbols then we must make sure that we do not strip/discard those
+     symbols that are going to be involved in the relocations.  */
+  if ((   finfo->info->strip   != strip_none
+       || finfo->info->discard != discard_none)
+      && finfo->info->relocatable)
+    {
+      /* Mark the symbol array as 'not-used'.  */
+      memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp);
+
+      mark_relocs (finfo, input_bfd);
+    }
+
+  while (esym < esym_end)
+    {
+      struct internal_syment isym;
+      enum coff_symbol_classification classification;
+      bfd_boolean skip;
+      bfd_boolean global;
+      bfd_boolean dont_skip_symbol;
+      int add;
+
+      bfd_coff_swap_sym_in (input_bfd, esym, isymp);
+
+      /* Make a copy of *isymp so that the relocate_section function
 	 always sees the original values.  This is more reliable than
 	 always recomputing the symbol value even if we are stripping
 	 the symbol.  */
       isym = *isymp;
 
-      classification = bfd_coff_classify_symbol (input_bfd, &isym);
-      switch (classification)
+      classification = bfd_coff_classify_symbol (input_bfd, &isym);
+      switch (classification)
+	{
+	default:
+	  abort ();
+	case COFF_SYMBOL_GLOBAL:
+	case COFF_SYMBOL_PE_SECTION:
+	case COFF_SYMBOL_LOCAL:
+	  *secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);
+	  break;
+	case COFF_SYMBOL_COMMON:
+	  *secpp = bfd_com_section_ptr;
+	  break;
+	case COFF_SYMBOL_UNDEFINED:
+	  *secpp = bfd_und_section_ptr;
+	  break;
+	}
+
+      /* Extract the flag indicating if this symbol is used by a
+         relocation.  */
+      if ((finfo->info->strip != strip_none
+	   || finfo->info->discard != discard_none)
+	  && finfo->info->relocatable)
+	dont_skip_symbol = *indexp;
+      else
+	dont_skip_symbol = FALSE;
+
+      *indexp = -1;
+
+      skip = FALSE;
+      global = FALSE;
+      add = 1 + isym.n_numaux;
+
+      /* If we are stripping all symbols, we want to skip this one.  */
+      if (finfo->info->strip == strip_all && ! dont_skip_symbol)
+	skip = TRUE;
+
+      /* NT_WEAKs need to come out after the real symbol, so we skip
+	 them here; when we write globals we'll discover they're leftovers
+	 and write them then. */
+      if (obj_pe(input_bfd) && isym.n_sclass == C_NT_WEAK)
+	skip = TRUE;
+
+      indx = (esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
+	   / isymesz;
+      h = obj_coff_sym_hashes (input_bfd)[indx];
+
+      if (! skip)
+	{
+	  switch (classification)
+	    {
+	    default:
+	      abort ();
+	    case COFF_SYMBOL_PE_SECTION:
+	      /* For relocatable links, we want to keep the comdat info
+		 around. If it's a section symbol that we're going to emit,
+		 and it's a section with a comdat symbol, we must
+		 emit it now (so it's corresponding COMDAT symbol
+		 comes out in the right order).  Any other section
+		 symbol (and non-relocateable) gets sorted out later. */
+	      if (! finfo->info->relocatable
+		  || (h->coff_link_hash_flags 
+			  & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0
+		  || h->root.u.def.section->output_section == NULL
+		  || h->root.u.def.section->comdat == NULL)
+		skip = TRUE;
+	      global = TRUE;
+	      break;
+
+	    case COFF_SYMBOL_GLOBAL:
+	    case COFF_SYMBOL_COMMON:
+	      /* This is a global symbol.  Global symbols come at the
+		 end of the symbol table, so skip them for now.
+		 Locally defined function symbols, however, are an
+		 exception, and are not moved to the end.  */
+	      global = TRUE;
+	      if (! ISFCN (isym.n_type))
+		skip = TRUE;
+	      break;
+
+	    case COFF_SYMBOL_UNDEFINED:
+	      /* Undefined symbols are left for the end.  */
+	      global = TRUE;
+	      skip = TRUE;
+	      break;
+
+	    case COFF_SYMBOL_LOCAL:
+	      /* This is a local symbol.  Skip it if we are discarding
+                 local symbols.  */
+	      if (finfo->info->discard == discard_all && ! dont_skip_symbol)
+		skip = TRUE;
+	      break;
+	    }
+	}
+
+#ifndef COFF_WITH_PE
+      /* Skip section symbols for sections which are not going to be
+	 emitted.  */
+      if (!skip
+	  && dont_skip_symbol == 0
+	  && isym.n_sclass == C_STAT
+	  && isym.n_type == T_NULL
+          && isym.n_numaux > 0
+	  && (*secpp)->output_section == bfd_abs_section_ptr)
+	skip = TRUE;
+#endif
+
+      /* If we stripping debugging symbols, and this is a debugging
+         symbol, then skip it.  FIXME: gas sets the section to N_ABS
+         for some types of debugging symbols; I don't know if this is
+         a bug or not.  In any case, we handle it here.  */
+      if (! skip
+	  && finfo->info->strip == strip_debugger
+	  && ! dont_skip_symbol
+	  && (isym.n_scnum == N_DEBUG
+	      || (isym.n_scnum == N_ABS
+		  && (isym.n_sclass == C_AUTO
+		      || isym.n_sclass == C_REG
+		      || isym.n_sclass == C_MOS
+		      || isym.n_sclass == C_MOE
+		      || isym.n_sclass == C_MOU
+		      || isym.n_sclass == C_ARG
+		      || isym.n_sclass == C_REGPARM
+		      || isym.n_sclass == C_FIELD
+		      || isym.n_sclass == C_EOS))))
+	skip = TRUE;
+
+      /* If some symbols are stripped based on the name, work out the
+	 name and decide whether to skip this symbol.  Symbol table
+	 symbols with an index of -2 are "must keep", so don't strip them. */
+      if (! skip && (h == NULL  || h->indx != -2)
+	  && (finfo->info->strip == strip_some
+	      || finfo->info->discard == discard_l))
+	{
+	  const char *name;
+	  char buf[SYMNMLEN + 1];
+
+	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
+	  if (name == NULL)
+	    return FALSE;
+
+	  if (! dont_skip_symbol
+	      && ((finfo->info->strip == strip_some
+		   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
+				    FALSE) == NULL))
+		   || (! global
+		       && finfo->info->discard == discard_l
+		       && bfd_is_local_label_name (input_bfd, name))))
+	    skip = TRUE;
+	}
+
+      /* If this is an enum, struct, or union tag, see if we have
+         already output an identical type.  */
+      if (! skip
+	  && (finfo->output_bfd->flags & BFD_TRADITIONAL_FORMAT) == 0
+	  && (isym.n_sclass == C_ENTAG
+	      || isym.n_sclass == C_STRTAG
+	      || isym.n_sclass == C_UNTAG)
+	  && isym.n_numaux == 1)
+	{
+	  const char *name;
+	  char buf[SYMNMLEN + 1];
+	  struct coff_debug_merge_hash_entry *mh;
+	  struct coff_debug_merge_type *mt;
+	  union internal_auxent aux;
+	  struct coff_debug_merge_element **epp;
+	  bfd_byte *esl, *eslend;
+	  struct internal_syment *islp;
+	  bfd_size_type amt;
+
+	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
+	  if (name == NULL)
+	    return FALSE;
+
+	  /* Ignore fake names invented by compiler; treat them all as
+             the same name.  */
+	  if (*name == '~' || *name == '.' || *name == '$'
+	      || (*name == bfd_get_symbol_leading_char (input_bfd)
+		  && (name[1] == '~' || name[1] == '.' || name[1] == '$')))
+	    name = "";
+
+	  mh = coff_debug_merge_hash_lookup (&finfo->debug_merge, name,
+					     TRUE, TRUE);
+	  if (mh == NULL)
+	    return FALSE;
+
+	  /* Allocate memory to hold type information.  If this turns
+             out to be a duplicate, we pass this address to
+             bfd_release.  */
+	  amt = sizeof (struct coff_debug_merge_type);
+	  mt = bfd_alloc (input_bfd, amt);
+	  if (mt == NULL)
+	    return FALSE;
+	  mt->class = isym.n_sclass;
+
+	  /* Pick up the aux entry, which points to the end of the tag
+             entries.  */
+	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
+				isym.n_type, isym.n_sclass, 0, isym.n_numaux,
+				&aux);
+
+	  /* Gather the elements.  */
+	  epp = &mt->elements;
+	  mt->elements = NULL;
+	  islp = isymp + 2;
+	  esl = esym + 2 * isymesz;
+	  eslend = ((bfd_byte *) obj_coff_external_syms (input_bfd)
+		    + aux.x_sym.x_fcnary.x_fcn.x_endndx.l * isymesz);
+	  while (esl < eslend)
+	    {
+	      const char *elename;
+	      char elebuf[SYMNMLEN + 1];
+	      char *name_copy;
+
+	      bfd_coff_swap_sym_in (input_bfd, esl, islp);
+
+	      amt = sizeof (struct coff_debug_merge_element);
+	      *epp = bfd_alloc (input_bfd, amt);
+	      if (*epp == NULL)
+		return FALSE;
+
+	      elename = _bfd_coff_internal_syment_name (input_bfd, islp,
+							elebuf);
+	      if (elename == NULL)
+		return FALSE;
+
+	      amt = strlen (elename) + 1;
+	      name_copy = bfd_alloc (input_bfd, amt);
+	      if (name_copy == NULL)
+		return FALSE;
+	      strcpy (name_copy, elename);
+
+	      (*epp)->name = name_copy;
+	      (*epp)->type = islp->n_type;
+	      (*epp)->tagndx = 0;
+	      if (islp->n_numaux >= 1
+		  && islp->n_type != T_NULL
+		  && islp->n_sclass != C_EOS)
+		{
+		  union internal_auxent eleaux;
+		  long indx;
+
+		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
+					islp->n_type, islp->n_sclass, 0,
+					islp->n_numaux, &eleaux);
+		  indx = eleaux.x_sym.x_tagndx.l;
+
+		  /* FIXME: If this tagndx entry refers to a symbol
+		     defined later in this file, we just ignore it.
+		     Handling this correctly would be tedious, and may
+		     not be required.  */
+		  if (indx > 0
+		      && (indx
+			  < ((esym -
+			      (bfd_byte *) obj_coff_external_syms (input_bfd))
+			     / (long) isymesz)))
+		    {
+		      (*epp)->tagndx = finfo->sym_indices[indx];
+		      if ((*epp)->tagndx < 0)
+			(*epp)->tagndx = 0;
+		    }
+		}
+	      epp = &(*epp)->next;
+	      *epp = NULL;
+
+	      esl += (islp->n_numaux + 1) * isymesz;
+	      islp += islp->n_numaux + 1;
+	    }
+
+	  /* See if we already have a definition which matches this
+             type.  We always output the type if it has no elements,
+             for simplicity.  */
+	  if (mt->elements == NULL)
+	    bfd_release (input_bfd, mt);
+	  else
+	    {
+	      struct coff_debug_merge_type *mtl;
+
+	      for (mtl = mh->types; mtl != NULL; mtl = mtl->next)
+		{
+		  struct coff_debug_merge_element *me, *mel;
+
+		  if (mtl->class != mt->class)
+		    continue;
+
+		  for (me = mt->elements, mel = mtl->elements;
+		       me != NULL && mel != NULL;
+		       me = me->next, mel = mel->next)
+		    {
+		      if (strcmp (me->name, mel->name) != 0
+			  || me->type != mel->type
+			  || me->tagndx != mel->tagndx)
+			break;
+		    }
+
+		  if (me == NULL && mel == NULL)
+		    break;
+		}
+
+	      if (mtl == NULL || (bfd_size_type) mtl->indx >= syment_base)
+		{
+		  /* This is the first definition of this type.  */
+		  mt->indx = output_index;
+		  mt->next = mh->types;
+		  mh->types = mt;
+		}
+	      else
+		{
+		  /* This is a redefinition which can be merged.  */
+		  bfd_release (input_bfd, mt);
+		  *indexp = mtl->indx;
+		  add = (eslend - esym) / isymesz;
+		  skip = TRUE;
+		}
+	    }
+	}
+
+      /* We now know whether we are to skip this symbol or not.  */
+      if (! skip)
+	{
+	  /* Adjust the symbol in order to output it.  */
+
+	  if (isym._n._n_n._n_zeroes == 0
+	      && isym._n._n_n._n_offset != 0)
+	    {
+	      const char *name;
+	      bfd_size_type indx;
+
+	      /* This symbol has a long name.  Enter it in the string
+		 table we are building.  Note that we do not check
+		 bfd_coff_symname_in_debug.  That is only TRUE for
+		 XCOFF, and XCOFF requires different linking code
+		 anyhow.  */
+	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
+	      if (name == NULL)
+		return FALSE;
+	      indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
+	      if (indx == (bfd_size_type) -1)
+		return FALSE;
+	      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
+	    }
+
+	  switch (isym.n_sclass)
+	    {
+	    case C_AUTO:
+	    case C_MOS:
+	    case C_EOS:
+	    case C_MOE:
+	    case C_MOU:
+	    case C_UNTAG:
+	    case C_STRTAG:
+	    case C_ENTAG:
+	    case C_TPDEF:
+	    case C_ARG:
+	    case C_USTATIC:
+	    case C_REG:
+	    case C_REGPARM:
+	    case C_FIELD:
+	      /* The symbol value should not be modified.  */
+	      break;
+
+	    case C_FCN:
+	      if (obj_pe (input_bfd)
+		  && strcmp (isym.n_name, ".bf") != 0
+		  && isym.n_scnum > 0)
+		{
+		  /* For PE, .lf and .ef get their value left alone,
+		     while .bf gets relocated.  However, they all have
+		     "real" section numbers, and need to be moved into
+		     the new section.  */
+		  isym.n_scnum = (*secpp)->output_section->target_index;
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	    case C_LABEL:  /* Not completely sure about these 2 */
+	    case C_EXTDEF:
+	    case C_BLOCK:
+	    case C_EFCN:
+	    case C_NULL:
+	    case C_EXT:
+	    case C_STAT:
+	    case C_SECTION:
+	      /* Compute new symbol location.  */
+	    if (isym.n_scnum > 0)
+	      {
+		isym.n_scnum = (*secpp)->output_section->target_index;
+		isym.n_value += ((*secpp)->output_offset
+		                 + (*secpp)->output_section->vma
+		                 - (*secpp)->vma);
+
+	      }
+	    break;
+
+	    case C_FILE:
+	      /* The value of a C_FILE symbol is the symbol index of
+		 the next C_FILE symbol.  The value of the last C_FILE
+		 symbol is the symbol index to the first external
+		 symbol (actually, coff_renumber_symbols does not get
+		 this right--it just sets the value of the last C_FILE
+		 symbol to zero--and nobody has ever complained about
+		 it).  We try to get this right, below, just before we
+		 write the symbols out, but in the general case we may
+		 have to write the symbol out twice.  */
+	      if (finfo->last_file_index != -1
+		  && finfo->last_file.n_value != (bfd_vma) output_index)
+		{
+		  /* We must correct the value of the last C_FILE
+                     entry.  */
+		  finfo->last_file.n_value = output_index;
+		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
+		    {
+		      /* The last C_FILE symbol is in this input file.  */
+		      bfd_coff_swap_sym_out (output_bfd,
+					     &finfo->last_file,
+					     (finfo->outsyms
+					      + ((finfo->last_file_index
+						  - syment_base)
+						 * osymesz)));
+		    }
+		  else
+		    {
+		      file_ptr pos;
+
+		      /* We have already written out the last C_FILE
+			 symbol.  We need to write it out again.  We
+			 borrow *outsym temporarily.  */
+		      bfd_coff_swap_sym_out (output_bfd,
+					     &finfo->last_file, outsym);
+		      pos = obj_sym_filepos (output_bfd);
+		      pos += finfo->last_file_index * osymesz;
+		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
+			  || bfd_bwrite (outsym, osymesz, output_bfd) != osymesz)
+			return FALSE;
+		    }
+		}
+
+	      finfo->last_file_index = output_index;
+	      finfo->last_file = isym;
+	      break;
+	    case C_NT_WEAK:
+	      BFD_ASSERT(FALSE);
+
+	    }
+
+	  /* If doing task linking, convert normal global function symbols to
+	     static functions.  */
+	  if (finfo->info->task_link && IS_EXTERNAL (input_bfd, isym))
+	    isym.n_sclass = C_STAT;
+
+	  /* Output the symbol.  */
+	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);
+
+	  *indexp = output_index;
+
+	  if (global)
+	    {
+	      if (h == NULL)
+		{
+		  /* This can happen if there were errors earlier in
+                     the link.  */
+		  bfd_set_error (bfd_error_bad_value);
+		  return FALSE;
+		}
+	      h->indx = output_index;
+	    }
+
+	  output_index += add;
+	  outsym += add * osymesz;
+	}
+
+      esym += add * isymesz;
+      isymp += add;
+      ++secpp;
+      ++indexp;
+      for (--add; add > 0; --add)
+	{
+	  *secpp++ = NULL;
+	  *indexp++ = -1;
+	}
+    }
+
+  /* Fix up the aux entries.  This must be done in a separate pass,
+     because we don't know the correct symbol indices until we have
+     already decided which symbols we are going to keep.  */
+  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
+  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
+  isymp = finfo->internal_syms;
+  indexp = finfo->sym_indices;
+  sym_hash = obj_coff_sym_hashes (input_bfd);
+  outsym = finfo->outsyms;
+
+  while (esym < esym_end)
+    {
+      int add;
+
+      add = 1 + isymp->n_numaux;
+
+      if ((*indexp < 0
+	   || (bfd_size_type) *indexp < syment_base)
+	  && (*sym_hash == NULL
+	      || (*sym_hash)->auxbfd != input_bfd))
+	esym += add * isymesz;
+      else
+	{
+	  struct coff_link_hash_entry *h;
+	  int i;
+
+	  h = NULL;
+	  if (*indexp < 0)
+	    {
+	      h = *sym_hash;
+
+	      /* The m68k-motorola-sysv assembler will sometimes
+                 generate two symbols with the same name, but only one
+                 will have aux entries.  */
+	      BFD_ASSERT (isymp->n_numaux == 0
+			  || h->numaux == isymp->n_numaux);
+	    }
+
+	  esym += isymesz;
+
+	  if (h == NULL)
+	    outsym += osymesz;
+
+	  /* Handle the aux entries.  This handling is based on
+	     coff_pointerize_aux.  I don't know if it always correct.  */
+	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
+	    {
+	      union internal_auxent aux;
+	      union internal_auxent *auxp;
+
+	      if (h != NULL)
+		auxp = h->aux + i;
+	      else
+		{
+		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
+					isymp->n_sclass, i, isymp->n_numaux, &aux);
+		  auxp = &aux;
+		}
+
+	      if (isymp->n_sclass == C_FILE)
+		{
+		  /* If this is a long filename, we must put it in the
+		     string table.  */
+		  if (auxp->x_file.x_n.x_zeroes == 0
+		      && auxp->x_file.x_n.x_offset != 0)
+		    {
+		      const char *filename;
+		      bfd_size_type indx;
+
+		      BFD_ASSERT (auxp->x_file.x_n.x_offset
+				  >= STRING_SIZE_SIZE);
+		      if (strings == NULL)
+			{
+			  strings = _bfd_coff_read_string_table (input_bfd);
+			  if (strings == NULL)
+			    return FALSE;
+			}
+		      filename = strings + auxp->x_file.x_n.x_offset;
+		      indx = _bfd_stringtab_add (finfo->strtab, filename,
+						 hash, copy);
+		      if (indx == (bfd_size_type) -1)
+			return FALSE;
+		      auxp->x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
+		    }
+		}
+	      else if (isymp->n_sclass == C_NT_WEAK)
+		{
+		  struct coff_link_hash_entry *h1 = *sym_hash;
+		  BFD_ASSERT(h1->root.type == bfd_link_hash_indirect
+	      		 && h1->root.u.i.info.alias);
+		  /* C_NT_WEAK needs to propigate the change in the AUX
+		     entry.  (Path used in .so case, only.) */
+		  while (h1->root.type == bfd_link_hash_indirect
+	      		 && h1->root.u.i.info.alias)
+		    h1 = (struct coff_link_hash_entry *) h1->root.u.i.link;
+		  auxp->x_sym.x_tagndx.l = h1->indx;
+		}
+
+	      else if ((isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
+		       && isymp->n_sclass != C_NT_WEAK
+		       )
+		{
+		  unsigned long indx;
+
+		  if (ISFCN (isymp->n_type)
+		      || ISTAG (isymp->n_sclass)
+		      || isymp->n_sclass == C_BLOCK
+		      || isymp->n_sclass == C_FCN)
+		    {
+		      indx = auxp->x_sym.x_fcnary.x_fcn.x_endndx.l;
+		      if (indx > 0
+			  && indx < obj_raw_syment_count (input_bfd))
+			{
+			  /* We look forward through the symbol for
+                             the index of the next symbol we are going
+                             to include.  I don't know if this is
+                             entirely right.  */
+			  while ((finfo->sym_indices[indx] < 0
+				  || ((bfd_size_type) finfo->sym_indices[indx]
+				      < syment_base))
+				 && indx < obj_raw_syment_count (input_bfd))
+			    ++indx;
+			  if (indx >= obj_raw_syment_count (input_bfd))
+			    indx = output_index;
+			  else
+			    indx = finfo->sym_indices[indx];
+			  auxp->x_sym.x_fcnary.x_fcn.x_endndx.l = indx;
+			}
+		    }
+
+		  indx = auxp->x_sym.x_tagndx.l;
+		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
+		    {
+		      long symindx;
+
+		      symindx = finfo->sym_indices[indx];
+		      if (symindx < 0)
+			auxp->x_sym.x_tagndx.l = 0;
+		      else
+			auxp->x_sym.x_tagndx.l = symindx;
+		    }
+
+		  /* The .bf symbols are supposed to be linked through
+		     the endndx field.  We need to carry this list
+		     across object files.  */
+		  if (i == 0
+		      && h == NULL
+		      && isymp->n_sclass == C_FCN
+		      && (isymp->_n._n_n._n_zeroes != 0
+			  || isymp->_n._n_n._n_offset == 0)
+		      && isymp->_n._n_name[0] == '.'
+		      && isymp->_n._n_name[1] == 'b'
+		      && isymp->_n._n_name[2] == 'f'
+		      && isymp->_n._n_name[3] == '\0')
+		    {
+		      if (finfo->last_bf_index != -1)
+			{
+			  finfo->last_bf.x_sym.x_fcnary.x_fcn.x_endndx.l =
+			    *indexp;
+
+			  if ((bfd_size_type) finfo->last_bf_index
+			      >= syment_base)
+			    {
+			      void *auxout;
+
+			      /* The last .bf symbol is in this input
+				 file.  This will only happen if the
+				 assembler did not set up the .bf
+				 endndx symbols correctly.  */
+			      auxout = (finfo->outsyms
+					+ ((finfo->last_bf_index
+					    - syment_base)
+					   * osymesz));
+
+			      bfd_coff_swap_aux_out (output_bfd,
+						     &finfo->last_bf,
+						     isymp->n_type,
+						     isymp->n_sclass,
+						     0, isymp->n_numaux,
+						     auxout);
+			    }
+			  else
+			    {
+			      file_ptr pos;
+
+			      /* We have already written out the last
+                                 .bf aux entry.  We need to write it
+                                 out again.  We borrow *outsym
+                                 temporarily.  FIXME: This case should
+                                 be made faster.  */
+			      bfd_coff_swap_aux_out (output_bfd,
+						     &finfo->last_bf,
+						     isymp->n_type,
+						     isymp->n_sclass,
+						     0, isymp->n_numaux,
+						     outsym);
+			      pos = obj_sym_filepos (output_bfd);
+			      pos += finfo->last_bf_index * osymesz;
+			      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
+				  || (bfd_bwrite (outsym, osymesz, output_bfd)
+				      != osymesz))
+				return FALSE;
+			    }
+			}
+
+		      if (auxp->x_sym.x_fcnary.x_fcn.x_endndx.l != 0)
+			finfo->last_bf_index = -1;
+		      else
+			{
+			  /* The endndx field of this aux entry must
+                             be updated with the symbol number of the
+                             next .bf symbol.  */
+			  finfo->last_bf = *auxp;
+			  finfo->last_bf_index = (((outsym - finfo->outsyms)
+						   / osymesz)
+						  + syment_base);
+			}
+		    }
+		}
+
+	      if (h == NULL)
+		{
+		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
+					 isymp->n_sclass, i, isymp->n_numaux,
+					 outsym);
+		  outsym += osymesz;
+		}
+
+	      esym += isymesz;
+	    }
+	}
+
+      indexp += add;
+      isymp += add;
+      sym_hash += add;
+    }
+
+  /* Relocate the line numbers, unless we are stripping them.  */
+  if (finfo->info->strip == strip_none
+      || finfo->info->strip == strip_some)
+    {
+      for (o = input_bfd->sections; o != NULL; o = o->next)
+	{
+	  bfd_vma offset;
+	  bfd_byte *eline;
+	  bfd_byte *elineend;
+	  bfd_byte *oeline;
+	  bfd_boolean skipping;
+	  file_ptr pos;
+	  bfd_size_type amt;
+
+	  /* FIXME: If SEC_HAS_CONTENTS is not for the section, then
+	     build_link_order in ldwrite.c will not have created a
+	     link order, which means that we will not have seen this
+	     input section in _bfd_coff_final_link, which means that
+	     we will not have allocated space for the line numbers of
+	     this section.  I don't think line numbers can be
+	     meaningful for a section which does not have
+	     SEC_HAS_CONTENTS set, but, if they do, this must be
+	     changed.  */
+	  if (o->lineno_count == 0
+	      || (o->output_section->flags & SEC_HAS_CONTENTS) == 0)
+	    continue;
+
+	  if (bfd_seek (input_bfd, o->line_filepos, SEEK_SET) != 0
+	      || bfd_bread (finfo->linenos, linesz * o->lineno_count,
+			   input_bfd) != linesz * o->lineno_count)
+	    return FALSE;
+
+	  offset = o->output_section->vma + o->output_offset - o->vma;
+	  eline = finfo->linenos;
+	  oeline = finfo->linenos;
+	  elineend = eline + linesz * o->lineno_count;
+	  skipping = FALSE;
+	  for (; eline < elineend; eline += linesz)
+	    {
+	      struct internal_lineno iline;
+
+	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);
+
+	      if (iline.l_lnno != 0)
+		iline.l_addr.l_paddr += offset;
+	      else if (iline.l_addr.l_symndx >= 0
+		       && ((unsigned long) iline.l_addr.l_symndx
+			   < obj_raw_syment_count (input_bfd)))
+		{
+		  long indx;
+
+		  indx = finfo->sym_indices[iline.l_addr.l_symndx];
+
+		  if (indx < 0)
+		    {
+		      /* These line numbers are attached to a symbol
+			 which we are stripping.  We must discard the
+			 line numbers because reading them back with
+			 no associated symbol (or associating them all
+			 with symbol #0) will fail.  We can't regain
+			 the space in the output file, but at least
+			 they're dense.  */
+		      skipping = TRUE;
+		    }
+		  else
+		    {
+		      struct internal_syment is;
+		      union internal_auxent ia;
+
+		      /* Fix up the lnnoptr field in the aux entry of
+			 the symbol.  It turns out that we can't do
+			 this when we modify the symbol aux entries,
+			 because gas sometimes screws up the lnnoptr
+			 field and makes it an offset from the start
+			 of the line numbers rather than an absolute
+			 file index.  */
+		      bfd_coff_swap_sym_in (output_bfd,
+					    (finfo->outsyms
+					     + ((indx - syment_base)
+						* osymesz)), &is);
+		      if ((ISFCN (is.n_type)
+			   || is.n_sclass == C_BLOCK)
+			  && is.n_numaux >= 1)
+			{
+			  void *auxptr;
+
+			  auxptr = (finfo->outsyms
+				    + ((indx - syment_base + 1)
+				       * osymesz));
+			  bfd_coff_swap_aux_in (output_bfd, auxptr,
+						is.n_type, is.n_sclass,
+						0, is.n_numaux, &ia);
+			  ia.x_sym.x_fcnary.x_fcn.x_lnnoptr =
+			    (o->output_section->line_filepos
+			     + o->output_section->lineno_count * linesz
+			     + eline - finfo->linenos);
+			  bfd_coff_swap_aux_out (output_bfd, &ia,
+						 is.n_type, is.n_sclass, 0,
+						 is.n_numaux, auxptr);
+			}
+
+		      skipping = FALSE;
+		    }
+
+		  iline.l_addr.l_symndx = indx;
+		}
+
+	      if (!skipping)
+	        {
+		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
+		  oeline += linesz;
+		}
+	    }
+
+	  pos = o->output_section->line_filepos;
+	  pos += o->output_section->lineno_count * linesz;
+	  amt = oeline - finfo->linenos;
+	  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
+	      || bfd_bwrite (finfo->linenos, amt, output_bfd) != amt)
+	    return FALSE;
+
+	  o->output_section->lineno_count += amt / linesz;
+	}
+    }
+
+  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
+     symbol will be the first symbol in the next input file.  In the
+     normal case, this will save us from writing out the C_FILE symbol
+     again.  */
+  if (finfo->last_file_index != -1
+      && (bfd_size_type) finfo->last_file_index >= syment_base)
+    {
+      finfo->last_file.n_value = output_index;
+      bfd_coff_swap_sym_out (output_bfd, &finfo->last_file,
+			     (finfo->outsyms
+			      + ((finfo->last_file_index - syment_base)
+				 * osymesz)));
+    }
+
+  /* Write the modified symbols to the output file.  */
+  if (outsym > finfo->outsyms)
+    {
+      file_ptr pos;
+      bfd_size_type amt;
+
+      pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
+      amt = outsym - finfo->outsyms;
+      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
+	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
+	return FALSE;
+
+      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
+		   + (outsym - finfo->outsyms) / osymesz)
+		  == output_index);
+
+      obj_raw_syment_count (output_bfd) = output_index;
+    }
+
+  /* Relocate the contents of each section.  */
+  adjust_symndx = coff_backend_info (input_bfd)->_bfd_coff_adjust_symndx;
+  for (o = input_bfd->sections; o != NULL; o = o->next)
+    {
+      bfd_byte *contents;
+      struct coff_section_tdata *secdata;
+
+      if (! o->linker_mark)
+	/* This section was omitted from the link.  */
+	continue;
+
+#ifdef DYNAMIC_LINKING
+      if ((o->flags & SEC_LINKER_CREATED) != 0)
+        {
+          /* Section was created by coff_link_create_dynamic_sections
+             or somesuch.  */
+          continue;
+        }
+#endif
+
+      if ((o->flags & SEC_HAS_CONTENTS) == 0
+	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
+	{
+	  if ((o->flags & SEC_RELOC) != 0
+	      && o->reloc_count != 0)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: relocs in section `%A', but it has no contents"),
+		 input_bfd, o);
+	      bfd_set_error (bfd_error_no_contents);
+	      return FALSE;
+	    }
+
+	  continue;
+	}
+
+      secdata = coff_section_data (input_bfd, o);
+      if (secdata != NULL && secdata->contents != NULL)
+	contents = secdata->contents;
+      else
+	{
+	  bfd_size_type x = o->rawsize ? o->rawsize : o->size;
+	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents, 0, x))
+	    return FALSE;
+	  contents = finfo->contents;
+	}
+
+      if ((o->flags & SEC_RELOC) != 0)
+	{
+	  int target_index;
+	  struct internal_reloc *internal_relocs;
+	  struct internal_reloc *irel;
+
+	  /* Read in the relocs.  */
+	  target_index = o->output_section->target_index;
+	  internal_relocs = (_bfd_coff_read_internal_relocs
+			     (input_bfd, o, FALSE, finfo->external_relocs,
+			      finfo->info->relocatable,
+			      (finfo->info->relocatable
+			       ? (finfo->section_info[target_index].relocs
+				  + o->output_section->reloc_count)
+			       : finfo->internal_relocs)));
+	  if (internal_relocs == NULL)
+	    return FALSE;
+
+	  /* Call processor specific code to relocate the section
+             contents.  */
+	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
+					   input_bfd, o,
+					   contents,
+					   internal_relocs,
+					   finfo->internal_syms,
+					   finfo->sec_ptrs))
+	    return FALSE;
+
+	  if (finfo->info->relocatable)
+	    {
+	      bfd_vma offset;
+	      struct internal_reloc *irelend;
+	      struct coff_link_hash_entry **rel_hash;
+
+	      offset = o->output_section->vma + o->output_offset - o->vma;
+	      irel = internal_relocs;
+	      irelend = irel + o->reloc_count;
+	      rel_hash = (finfo->section_info[target_index].rel_hashes
+			  + o->output_section->reloc_count);
+	      for (; irel < irelend; irel++, rel_hash++)
+		{
+		  struct coff_link_hash_entry *h;
+		  bfd_boolean adjusted;
+
+		  *rel_hash = NULL;
+
+		  /* Adjust the reloc address and symbol index.  */
+		  irel->r_vaddr += offset;
+
+		  if (irel->r_symndx == -1)
+		    continue;
+
+		  if (adjust_symndx)
+		    {
+		      if (! (*adjust_symndx) (output_bfd, finfo->info,
+					      input_bfd, o, irel,
+					      &adjusted))
+			return FALSE;
+		      if (adjusted)
+			continue;
+		    }
+
+		  h = obj_coff_sym_hashes (input_bfd)[irel->r_symndx];
+		  if (h != NULL)
+		    {
+		      /* This is a global symbol.  */
+		      if (h->indx >= 0)
+			irel->r_symndx = h->indx;
+		      else
+			{
+			  /* This symbol is being written at the end
+			     of the file, and we do not yet know the
+			     symbol index.  We save the pointer to the
+			     hash table entry in the rel_hash list.
+			     We set the indx field to -2 to indicate
+			     that this symbol must not be stripped.  */
+			  *rel_hash = h;
+			  h->indx = -2;
+			}
+		    }
+		  else
+		    {
+		      long indx;
+
+		      indx = finfo->sym_indices[irel->r_symndx];
+		      if (indx != -1)
+			irel->r_symndx = indx;
+		      else
+			{
+			  struct internal_syment *is;
+			  const char *name;
+			  char buf[SYMNMLEN + 1];
+
+			  /* This reloc is against a symbol we are
+                             stripping.  This should have been handled
+			     by the 'dont_skip_symbol' code in the while
+			     loop at the top of this function.  */
+			  is = finfo->internal_syms + irel->r_symndx;
+
+			  name = (_bfd_coff_internal_syment_name
+				  (input_bfd, is, buf));
+			  if (name == NULL)
+			    return FALSE;
+
+			  if (! ((*finfo->info->callbacks->unattached_reloc)
+				 (finfo->info, name, input_bfd, o,
+				  irel->r_vaddr)))
+			    return FALSE;
+			}
+		    }
+		}
+
+	      o->output_section->reloc_count += o->reloc_count;
+	    }
+	}
+
+      /* Write out the modified section contents.  */
+      if (secdata == NULL || secdata->stab_info == NULL)
+	{
+	  file_ptr loc = o->output_offset * bfd_octets_per_byte (output_bfd);
+
+	  if (! bfd_set_section_contents (output_bfd, o->output_section,
+					  contents, loc, o->size))
+	    return FALSE;
+	}
+      else
+	{
+	  if (! (_bfd_write_section_stabs
+		 (output_bfd, &coff_hash_table (finfo->info)->stab_info,
+		  o, &secdata->stab_info, contents)))
+	    return FALSE;
+	}
+    }
+
+  if (! finfo->info->keep_memory
+      && ! _bfd_coff_free_symbols (input_bfd))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Write out a global symbol.  Called via coff_link_hash_traverse.  */
+
+bfd_boolean
+_bfd_coff_write_global_sym (struct coff_link_hash_entry *h, void *data)
+{
+  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
+  bfd *output_bfd;
+  struct internal_syment isym;
+  bfd_size_type symesz;
+  unsigned int i;
+  file_ptr pos;
+
+  bfd_boolean emit_classical = TRUE;
+  bfd_boolean emit_dynamic = TRUE;
+  struct coff_link_hash_entry *h_real = NULL;
+
+  /* This function performs two apparently related, but distinct, functions:
+     it outputs the global symbols for the conventional symbol table
+     (function local symbols and function symbols were handled above).
+
+     It also outputs the dynamic symbols needed for dynamic linking.
+
+     The criteria for determining when a symbol is actually output to each of 
+     the two symbol tables are somewhat different, but much of the preparation
+     is shared.  Note that this code will output symbols for functions in
+     the dynmaic symbol table, but never for the conventional one */
+
+
+  output_bfd = finfo->output_bfd;
+
+  if (h->root.type == bfd_link_hash_warning)
+    {
+      h = (struct coff_link_hash_entry *) h->root.u.i.link;
+      if (h->root.type == bfd_link_hash_new)
+	return TRUE;
+    }
+
+  /* There are situations where we might get called more than once, and
+     if that happens, the hash table (and plt) is, well..., hash. */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_EMITTED) != 0)
+      return TRUE;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_EMITTED;
+
+  if (h->root.type == bfd_link_hash_indirect
+	&& h->root.u.i.info.alias)
+    {
+      /* C_NT_WEAK needs to propigate the change in the AUX
+	 entry.  To do that, the indx value must already be set.
+	 If necessary, recursively call ourself to achieve that.
+	 (That is, be sure the strong symbol is emitted before the
+	 weak one, so we know its index.) */
+      h_real = h;
+      while (h_real->root.type == bfd_link_hash_indirect
+	     && h_real->root.u.i.info.alias)
+	h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+      if (h_real->indx < 0)
+	_bfd_coff_write_global_sym (h_real, data);
+    }
+
+#ifdef DYNAMIC_LINKING
+  /* If we are not creating a shared library, and this symbol is
+     referenced by a shared library but is not defined anywhere, then
+     warn that it is undefined.  If we do not do this, the runtime
+     linker will complain that the symbol is undefined when the
+     program is run.  We don't have to worry about symbols that are
+     referenced by regular files, because we will already have issued
+     warnings for them.  
+
+     Because of COFF order requirements, symbols are output in 2 places
+     (here and in ...link_input_bfd).  However, we didn't output any
+     undefined symbols there, so this is the only place we need the
+     check for undefined.  */
+  if (! finfo->info->relocatable
+      && ! finfo->info->shared
+      && h->root.type == bfd_link_hash_undefined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0)
+    {
+      if (! ((*finfo->info->callbacks->undefined_symbol)
+	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
+	      (asection *) NULL, 0, TRUE)))
+	{
+	  return FALSE;
+	}
+    }
+#endif
+
+  /* If it doesn't have a dynindx, we're surely not going to emit it */
+  emit_dynamic = h->dynindx != -1;
+
+  if (h->indx >= 0)
+     /* If it was emitted previously..., skip it. */
+     emit_classical = FALSE;
+  else if (h->indx == -2)
+    /* used by a reloc... must keep */
+    emit_classical = TRUE;
+#ifdef DYNAMIC_LINKING
+  else if (((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+	    || (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0)
+	   && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0
+	   && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0)
+    {
+       /* Never mentioned by a regular file */
+       /* there's still work to do, so we can't return */
+       emit_classical = FALSE;
+       emit_dynamic = FALSE;
+    }
+#endif
+  else if (finfo->info->strip == strip_some
+	   && bfd_hash_lookup (finfo->info->keep_hash,
+				   h->root.root.string,
+				   FALSE, FALSE) == NULL)
+    /* it's a symbol we don't retain when selectively stripping */
+    emit_classical = FALSE;
+  else if (finfo->info->strip == strip_all)
+    /* or if we just strip everything */
+    emit_classical = FALSE;
+  else
+    /* otherwise, we'll keep it */
+    emit_classical = TRUE;
+ 
+  switch (h->root.type)
+    {
+    default:
+    case bfd_link_hash_new:
+    case bfd_link_hash_warning:
+      abort ();
+      return FALSE;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      isym.n_scnum = N_UNDEF;
+      isym.n_value = 0;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      /* discard internally synthesized names (.idata$[45]^?nn) */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_PE_SECTION_SYMBOL) != 0 
+	  && h->root.root.string[0]=='.' && h->root.root.string[1] == 'i'
+	  && h->root.root.string[8]==0x7f
+	  && (h->root.root.string[7]=='4'||h->root.root.string[7]=='5')
+	  && strncmp(h->root.root.string, ".idata$",7)==0)
+	{
+	  /* phew, that's an ugly test, but it's right and fast.
+	     if performance becomes an issue, it's probably safe to skip
+	     testing name[7]. */
+	  return TRUE;
+	}
+
+      {
+	asection *sec;
+
+	/*
+	 * mayank@10thSept, 2007
+	 * FIXME
+	 * All the defined symbols of a .so are output as undefined in
+	 * a binary. This is not happening with data symbols and hence
+	 * this hack. elf takes care by calling bfd_section_list_clear
+	 * in elf_link_add_object_symbols, so that no sections from
+	 * the dynamic object are included in the output file.
+	 */
+	if ( h->auxbfd!=NULL)
+	{
+		if (h->auxbfd->flags & DYNAMIC)
+		{
+			if ( strncmp(h->root.u.def.section->name,".data",5)==0 || strncmp(h->root.u.def.section->name,".rdata",6)==0 || strncmp(h->root.u.def.section->name,".bss",4)==0)
+			{
+			//this symbol came from .so and is defined there
+		 	h->root.u.def.section->output_section = NULL;
+			}
+		}
+	}
+
+	sec = h->root.u.def.section->output_section;
+#ifdef DYNAMIC_LINKING
+#ifndef USE_COPY_RELOC
+	/* When a symbol has no output section, it means that the symbol
+	   came in from a prior .so, and is completely defined there.  
+	   (That is, it's a data symbol, usually.  Code symbols get an
+	   output section, that of the thunk.) (Shouldn't ever happen 
+	   if COPY relocations are in use.)
+	   We want to output the symbol (so our relocations can see it) 
+	   but as an undefined symbol. */
+	
+	if (sec == NULL)
+	  {
+	     isym.n_scnum = N_UNDEF;
+	     isym.n_value = 0;
+	  }
+        else
+#endif
+#endif
+	  { // NOTE: deferred indentation fix
+
+	if (bfd_is_abs_section (sec))
+	  isym.n_scnum = N_ABS;
+	else
+	  isym.n_scnum = sec->target_index;
+	/* for a section symbol, the value is noise, so we'll take what
+	   we get. */
+
+	isym.n_value = (h->root.u.def.value
+			+ sec->vma
+			+ h->root.u.def.section->output_offset);
+	  } // END
+      }
+      break;
+
+    case bfd_link_hash_common:
+      isym.n_scnum = N_UNDEF;
+      isym.n_value = h->root.u.c.size;
+      break;
+
+#ifdef DYNAMIC_LINKING
+    case bfd_link_hash_indirect:
+      /* These symbols are created in two ways... by symbol versioning
+	 and by C_NT_WEAK symbols.
+
+	 For symbol versioning, they point
+         to the decorated version of the name.  For example, if the
+         symbol foo@@GNU_1.2 is the default, which should be used when
+         foo is used with no version, then we add an indirect symbol
+         foo which points to foo@@GNU_1.2.  We ignore these symbols,
+         since the indirected symbol is already in the hash table.  If
+         the indirect symbol is non-COFF, fall through and output it.
+
+	 If it's a weak symbol, it need to be treated more-or-less
+	 normally.
+
+	 */
+      if (h->root.u.i.info.alias)
+	{
+	  isym.n_scnum = N_UNDEF;
+	  isym.n_value = 0;
+	  break;
+	}
+      if ((h->coff_link_hash_flags & COFF_LINK_NON_COFF) == 0)
+        return TRUE;
+
+      if (h->root.u.i.link->type == bfd_link_hash_new)
+        return TRUE;
+
+      return (_bfd_coff_write_global_sym
+              ((struct coff_link_hash_entry *) h->root.u.i.link, data));
+#else
+    case bfd_link_hash_indirect:
+        /* Just ignore these.  They can't be handled anyhow.  */
+        return TRUE;
+#endif
+    }
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* Give the processor backend a chance to tweak the symbol
+     value, and also to finish up anything that needs to be done
+     for this symbol.  All symbols require a peek, because some
+     symbols are forced local, but need work here anyway. */
+  if (coff_hash_table (finfo->info)->dynamic_sections_created
+      && !bfd_coff_backend_finish_dynamic_symbol
+	 (finfo->output_bfd, finfo->info, h, &isym))
+    {
+	emit_dynamic = FALSE;
+    }
+#endif /* ] */
+
+  if (strlen (h->root.root.string) <= SYMNMLEN)
+    strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
+  else
+    {
+      bfd_boolean hash;
+      bfd_size_type indx;
+
+      hash = TRUE;
+      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
+	hash = FALSE;
+      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
+				 FALSE);
+      if (indx == (bfd_size_type) -1)
+	{
+	  finfo->failed = TRUE;
+	  return FALSE;
+	}
+      isym._n._n_n._n_zeroes = 0;
+      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
+    }
+
+  isym.n_sclass = h->class;
+  isym.n_type = h->type;
+
+#ifdef COFF_WITH_PE  /// This is NOT DL; move elsewhere soon.  Yeah!
+  if (h->root.type == bfd_link_hash_undefweak)
+    isym.n_sclass = C_NT_WEAK;
+#endif
+
+  if (isym.n_sclass == C_NULL)
+    isym.n_sclass = C_EXT;
+
+  /* If doing task linking and this is the pass where we convert
+     defined globals to statics, then do that conversion now.  If the
+     symbol is not being converted, just ignore it and it will be
+     output during a later pass.  */
+  if (finfo->global_to_static)
+    {
+      if (! IS_EXTERNAL (output_bfd, isym))
+	return TRUE;
+
+      isym.n_sclass = C_STAT;
+    }
+
+  /* When a weak symbol is not overridden by a strong one,
+     turn it into an external symbol when not building a
+     shared or relocatable object.  */
+  if (! finfo->info->shared
+      && ! finfo->info->relocatable
+      && IS_WEAK_EXTERNAL (finfo->output_bfd, isym))
+    isym.n_sclass = C_EXT;
+ 
+  if (emit_classical)
+    { // NOTE: Another deferred indentation.
+  	isym.n_numaux = h->numaux;
+
+  bfd_coff_swap_sym_out (output_bfd, &isym, finfo->outsyms);
+
+  symesz = bfd_coff_symesz (output_bfd);
+
+  pos = obj_sym_filepos (output_bfd);
+  pos += obj_raw_syment_count (output_bfd) * symesz;
+  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
+      || bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
+    {
+      finfo->failed = TRUE;
+      return FALSE;
+    }
+
+  h->indx = obj_raw_syment_count (output_bfd);
+
+  ++obj_raw_syment_count (output_bfd);
+
+  /* Write out any associated aux entries.  Most of the aux entries
+     will have been modified in _bfd_coff_link_input_bfd.  We have to
+     handle section aux entries here, now that we have the final
+     relocation and line number counts.  */
+  for (i = 0; i < isym.n_numaux; i++)
+    {
+      union internal_auxent *auxp;
+
+      auxp = h->aux + i;
+
+      /* Look for a section aux entry here using the same tests that
+         coff_swap_aux_out uses.  */
+      if (i == 0
+	  && (isym.n_sclass == C_STAT
+	      || isym.n_sclass == C_HIDDEN)
+	  && isym.n_type == T_NULL
+	  && (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak))
+	{
+	  asection *sec;
+
+	  sec = h->root.u.def.section->output_section;
+	  if (sec != NULL)
+	    {
+	      auxp->x_scn.x_scnlen = sec->size;
+
+	      /* For PE, an overflow on the final link reportedly does
+                 not matter.  FIXME: Why not?  */
+	      if (sec->reloc_count > 0xffff
+		  && (! obj_pe (output_bfd)
+		      || finfo->info->relocatable))
+		(*_bfd_error_handler)
+		  (_("%s: %s: reloc overflow: 0x%lx > 0xffff"),
+		   bfd_get_filename (output_bfd),
+		   bfd_get_section_name (output_bfd, sec),
+		   sec->reloc_count);
+
+	      if (sec->lineno_count > 0xffff
+		  && (! obj_pe (output_bfd)
+		      || finfo->info->relocatable))
+		(*_bfd_error_handler)
+		  (_("%s: warning: %s: line number overflow: 0x%lx > 0xffff"),
+		   bfd_get_filename (output_bfd),
+		   bfd_get_section_name (output_bfd, sec),
+		   sec->lineno_count);
+
+	      auxp->x_scn.x_nreloc = sec->reloc_count;
+	      auxp->x_scn.x_nlinno = sec->lineno_count;
+	      auxp->x_scn.x_checksum = 0;
+	      auxp->x_scn.x_associated = 0;
+	      auxp->x_scn.x_comdat = 0;
+	    }
+	}
+
+      if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias)
+	{
+          BFD_ASSERT(isym.n_sclass == C_NT_WEAK);
+	  /* C_NT_WEAK needs to propigate the change in the AUX
+	     entry.   We already have h_real from above. */
+	  auxp->x_sym.x_tagndx.l = h_real->indx;
+	}
+
+      bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,
+			     isym.n_sclass, (int) i, isym.n_numaux,
+			     finfo->outsyms);
+      if (bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
+	{
+	  finfo->failed = TRUE;
+	  return FALSE;
+	}
+      ++obj_raw_syment_count (output_bfd);
+    }
+  }  // END DEFERRED INDENT
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If this symbol should also be put in the .dynsym section, then put it
+     there now.  We have already know the symbol index.  We also fill
+     in the entry in the .hash section.  */
+  if (emit_dynamic)  
+    {
+      if (h->dynindx != -1
+	  && coff_hash_table (finfo->info)->dynamic_sections_created)
+	{
+	   _bfd_coff_output_dynamic_symbol(&isym, h, finfo);
+	}
+    }
+#endif /* ] */
+
+  return TRUE;
+}
+
+/* Write out task global symbols, converting them to statics.  Called
+   via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do
+   the dirty work, if the symbol we are processing needs conversion.  */
+
+bfd_boolean
+_bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)
+{
+  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
+  bfd_boolean rtnval = TRUE;
+  bfd_boolean save_global_to_static;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+
+  if (h->indx < 0)
+    {
+      switch (h->root.type)
 	{
+	case bfd_link_hash_defined:
+	case bfd_link_hash_defweak:
+	  save_global_to_static = finfo->global_to_static;
+	  finfo->global_to_static = TRUE;
+	  rtnval = _bfd_coff_write_global_sym (h, data);
+	  finfo->global_to_static = save_global_to_static;
+	  break;
 	default:
-	  abort ();
-	case COFF_SYMBOL_GLOBAL:
-	case COFF_SYMBOL_PE_SECTION:
-	case COFF_SYMBOL_LOCAL:
-	  *secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);
 	  break;
-	case COFF_SYMBOL_COMMON:
-	  *secpp = bfd_com_section_ptr;
+	}
+    }
+  return (rtnval);
+}
+
+/* Handle a link order which is supposed to generate a reloc.  */
+
+bfd_boolean
+_bfd_coff_reloc_link_order (bfd *output_bfd,
+			    struct coff_final_link_info *finfo,
+			    asection *output_section,
+			    struct bfd_link_order *link_order)
+{
+  reloc_howto_type *howto;
+  struct internal_reloc *irel;
+  struct coff_link_hash_entry **rel_hash_ptr;
+
+  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
+  if (howto == NULL)
+    {
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  if (link_order->u.reloc.p->addend != 0)
+    {
+      bfd_size_type size;
+      bfd_byte *buf;
+      bfd_reloc_status_type rstat;
+      bfd_boolean ok;
+      file_ptr loc;
+
+      size = bfd_get_reloc_size (howto);
+      buf = bfd_zmalloc (size);
+      if (buf == NULL)
+	return FALSE;
+
+      rstat = _bfd_relocate_contents (howto, output_bfd,
+				      (bfd_vma) link_order->u.reloc.p->addend,\
+				      buf);
+      switch (rstat)
+	{
+	case bfd_reloc_ok:
 	  break;
-	case COFF_SYMBOL_UNDEFINED:
-	  *secpp = bfd_und_section_ptr;
+	default:
+	case bfd_reloc_outofrange:
+	  abort ();
+	case bfd_reloc_overflow:
+	  if (! ((*finfo->info->callbacks->reloc_overflow)
+		 (finfo->info, NULL,
+		  (link_order->type == bfd_section_reloc_link_order
+		   ? bfd_section_name (output_bfd,
+				       link_order->u.reloc.p->u.section)
+		   : link_order->u.reloc.p->u.name),
+		  howto->name, link_order->u.reloc.p->addend,
+		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
+	    {
+	      free (buf);
+	      return FALSE;
+	    }
 	  break;
 	}
+      loc = link_order->offset * bfd_octets_per_byte (output_bfd);
+      ok = bfd_set_section_contents (output_bfd, output_section, buf,
+                                     loc, size);
+      free (buf);
+      if (! ok)
+	return FALSE;
+    }
+
+  /* Store the reloc information in the right place.  It will get
+     swapped and written out at the end of the final_link routine.  */
+  irel = (finfo->section_info[output_section->target_index].relocs
+	  + output_section->reloc_count);
+  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
+		  + output_section->reloc_count);
+
+  memset (irel, 0, sizeof (struct internal_reloc));
+  *rel_hash_ptr = NULL;
+
+  irel->r_vaddr = output_section->vma + link_order->offset;
+
+  if (link_order->type == bfd_section_reloc_link_order)
+    {
+      /* We need to somehow locate a symbol in the right section.  The
+         symbol must either have a value of zero, or we must adjust
+         the addend by the value of the symbol.  FIXME: Write this
+         when we need it.  The old linker couldn't handle this anyhow.  */
+      abort ();
+      *rel_hash_ptr = NULL;
+      irel->r_symndx = 0;
+    }
+  else
+    {
+      struct coff_link_hash_entry *h;
+
+      h = ((struct coff_link_hash_entry *)
+	   bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
+					 link_order->u.reloc.p->u.name,
+					 FALSE, FALSE, TRUE));
+      if (h != NULL)
+	{
+	  if (h->indx >= 0)
+	    irel->r_symndx = h->indx;
+	  else
+	    {
+	      /* Set the index to -2 to force this symbol to get
+		 written out.  */
+	      h->indx = -2;
+	      *rel_hash_ptr = h;
+	      irel->r_symndx = 0;
+	    }
+	}
+      else
+	{
+	  if (! ((*finfo->info->callbacks->unattached_reloc)
+		 (finfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
+		  (asection *) NULL, (bfd_vma) 0)))
+	    return FALSE;
+	  irel->r_symndx = 0;
+	}
+    }
+
+  /* FIXME: Is this always right?  */
+  irel->r_type = howto->type;
+
+  /* r_size is only used on the RS/6000, which needs its own linker
+     routines anyhow.  r_extern is only used for ECOFF.  */
+
+  /* FIXME: What is the right value for r_offset?  Is zero OK?  */
+  ++output_section->reloc_count;
+
+  return TRUE;
+}
+
+/* A basic reloc handling routine which may be used by processors with
+   simple relocs.  */
+
+bfd_boolean
+_bfd_coff_generic_relocate_section (bfd *output_bfd,
+				    struct bfd_link_info *info,
+				    bfd *input_bfd,
+				    asection *input_section,
+				    bfd_byte *contents,
+				    struct internal_reloc *relocs,
+				    struct internal_syment *syms,
+				    asection **sections)
+{
+  struct internal_reloc *rel;
+  struct internal_reloc *relend;
+  bfd_vma imagebase = 0;
+#ifdef DYNAMIC_LINKING
+  asection *sgot;
+  asection *splt = NULL;
+  asection *sreloc = NULL;
+  asection *srelgot = NULL;
+  bfd_boolean dynamic;
+  bfd_vma *local_got_offsets = NULL;
+  bfd_size_type symrsz = bfd_coff_relsz(output_bfd);
+  bfd_boolean is_stab_section = FALSE;
+
+  dynamic = coff_hash_table (info)->dynamic_sections_created;
+  /* In case some PIC code slipped into our world when linking 
+     statically.  */
+  local_got_offsets = coff_local_got_offsets (input_bfd);
+  is_stab_section = 
+      strncmp(bfd_get_section_name(input_bfd,input_section),".stab",5) == 0;
+
+  sreloc = coff_hash_table (info)->sreloc;
+  splt = coff_hash_table(info)->splt;
+  srelgot = coff_hash_table(info)->srelgot;
+  /* BFD_ASSERT (sreloc != NULL); -- it gets made on demand */
+  /* BFD_ASSERT (srelgot != NULL); -- it gets made on demand */
+  sgot = coff_hash_table(info)->sgot;
+  if (dynamic)
+    {
+      BFD_ASSERT (splt != NULL);
+    }
+#endif
 
-      /* Extract the flag indicating if this symbol is used by a
-         relocation.  */
-      if ((finfo->info->strip != strip_none
-	   || finfo->info->discard != discard_none)
-	  && finfo->info->relocatable)
-	dont_skip_symbol = *indexp;
-      else
-	dont_skip_symbol = FALSE;
-
-      *indexp = -1;
+  if (pe_data(output_bfd) != NULL)
+      imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
 
-      skip = FALSE;
-      global = FALSE;
-      add = 1 + isym.n_numaux;
+  rel = relocs;
+  relend = rel + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      long symndx;
+      struct coff_link_hash_entry *h;
+      struct coff_link_hash_entry *h_real;
+      struct internal_syment *sym;
+      bfd_vma addend;
+      bfd_vma val;
+      reloc_howto_type *howto;
+      bfd_reloc_status_type rstat;
+      enum coff_symbol_classification classification;
+      asection *sec;
+      bfd_boolean need_imagebase;  /* Not all relocs get ImageBase */
+      bfd_boolean need_static_reloc, need_dynamic_reloc;  /* whether to omit them */
+      bfd_boolean valIsValid;  /* whether the computed val is to be trusted */
+      struct internal_reloc outrel;
 
-      /* If we are stripping all symbols, we want to skip this one.  */
-      if (finfo->info->strip == strip_all && ! dont_skip_symbol)
-	skip = TRUE;
+      symndx = rel->r_symndx;
 
-      if (! skip)
+      if (symndx == -1)
 	{
-	  switch (classification)
+	  h = NULL;
+	  sym = NULL;
+	}
+      else if (symndx < 0
+	       || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
 	    {
-	    default:
-	      abort ();
-	    case COFF_SYMBOL_GLOBAL:
-	    case COFF_SYMBOL_COMMON:
-	    case COFF_SYMBOL_PE_SECTION:
-	      /* This is a global symbol.  Global symbols come at the
-		 end of the symbol table, so skip them for now.
-		 Locally defined function symbols, however, are an
-		 exception, and are not moved to the end.  */
-	      global = TRUE;
-	      if (! ISFCN (isym.n_type))
-		skip = TRUE;
-	      break;
-
-	    case COFF_SYMBOL_UNDEFINED:
-	      /* Undefined symbols are left for the end.  */
-	      global = TRUE;
-	      skip = TRUE;
-	      break;
+	  (*_bfd_error_handler)
+	    ("%B: illegal symbol index %ld in relocs", input_bfd, symndx);
+	  return FALSE;
+	}
+      else
+	{
+	  classification = bfd_coff_classify_symbol(input_bfd, &syms[symndx]);
+	  if (classification == COFF_SYMBOL_PE_SECTION)
+	    {
+	      /* a reference to a section definition wants to just use the
+		 section information (which is what this does).  We can't
+		 look at h, because the (local) symbol table entry might
+		 be an ordinary reference to a section symbol OR a section
+		 definition, and those are treated differently.  Only
+		 the local symbol table tells us which. */
+	      h = NULL;
+	    }
+	  else
+	    {
+	      /* If this is a relocateable link, and we're dealing with
+		 a relocation against a symbol (rather than a section),
+		 leave it alone */
+	      if (info->relocatable)
+		continue;
 
-	    case COFF_SYMBOL_LOCAL:
-	      /* This is a local symbol.  Skip it if we are discarding
-                 local symbols.  */
-	      if (finfo->info->discard == discard_all && ! dont_skip_symbol)
-		skip = TRUE;
-	      break;
+	  h = obj_coff_sym_hashes (input_bfd)[symndx];
 	    }
+	  sym = syms + symndx;
 	}
 
-#ifndef COFF_WITH_PE
-      /* Skip section symbols for sections which are not going to be
-	 emitted.  */
-      if (!skip
-	  && dont_skip_symbol == 0
-	  && isym.n_sclass == C_STAT
-	  && isym.n_type == T_NULL
-          && isym.n_numaux > 0
-	  && (*secpp)->output_section == bfd_abs_section_ptr)
-	skip = TRUE;
-#endif
+      /* COFF treats common symbols in one of two ways.  Either the
+         size of the symbol is included in the section contents, or it
+         is not.  We assume that the size is not included, and force
+         the rtype_to_howto function to adjust the addend as needed.  */
+      if (sym != NULL && sym->n_scnum != 0)
+	addend = - sym->n_value;
+      else
+	addend = 0;
 
-      /* If we stripping debugging symbols, and this is a debugging
-         symbol, then skip it.  FIXME: gas sets the section to N_ABS
-         for some types of debugging symbols; I don't know if this is
-         a bug or not.  In any case, we handle it here.  */
-      if (! skip
-	  && finfo->info->strip == strip_debugger
-	  && ! dont_skip_symbol
-	  && (isym.n_scnum == N_DEBUG
-	      || (isym.n_scnum == N_ABS
-		  && (isym.n_sclass == C_AUTO
-		      || isym.n_sclass == C_REG
-		      || isym.n_sclass == C_MOS
-		      || isym.n_sclass == C_MOE
-		      || isym.n_sclass == C_MOU
-		      || isym.n_sclass == C_ARG
-		      || isym.n_sclass == C_REGPARM
-		      || isym.n_sclass == C_FIELD
-		      || isym.n_sclass == C_EOS))))
-	skip = TRUE;
+      howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,
+				       sym, &addend);
+      if (howto == NULL)
+	return FALSE;
 
-      /* If some symbols are stripped based on the name, work out the
-	 name and decide whether to skip this symbol.  */
-      if (! skip
-	  && (finfo->info->strip == strip_some
-	      || finfo->info->discard == discard_l))
+      /* If we are doing a relocatable link, then we can just ignore
+         a PC relative reloc that is pcrel_offset.  It will already
+         have the correct value.  If this is not a relocatable link,
+         then we should ignore the symbol value.  */
+      if (howto->pc_relative && howto->pcrel_offset)
 	{
-	  const char *name;
-	  char buf[SYMNMLEN + 1];
+	  if (info->relocatable)
+	    continue;
+	  if (sym != NULL && sym->n_scnum != 0)
+	    addend += sym->n_value;
+	}
 
-	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
-	  if (name == NULL)
-	    return FALSE;
+      val = 0;
 
-	  if (! dont_skip_symbol
-	      && ((finfo->info->strip == strip_some
-		   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
-				    FALSE) == NULL))
-		   || (! global
-		       && finfo->info->discard == discard_l
-		       && bfd_is_local_label_name (input_bfd, name))))
-	    skip = TRUE;
-	}
+      valIsValid = TRUE;
+      need_static_reloc = TRUE;
+      need_dynamic_reloc = FALSE;
 
-      /* If this is an enum, struct, or union tag, see if we have
-         already output an identical type.  */
-      if (! skip
-	  && (finfo->output_bfd->flags & BFD_TRADITIONAL_FORMAT) == 0
-	  && (isym.n_sclass == C_ENTAG
-	      || isym.n_sclass == C_STRTAG
-	      || isym.n_sclass == C_UNTAG)
-	  && isym.n_numaux == 1)
+      h_real = h;
+
+      if (h == NULL)
 	{
-	  const char *name;
-	  char buf[SYMNMLEN + 1];
-	  struct coff_debug_merge_hash_entry *mh;
-	  struct coff_debug_merge_type *mt;
-	  union internal_auxent aux;
-	  struct coff_debug_merge_element **epp;
-	  bfd_byte *esl, *eslend;
-	  struct internal_syment *islp;
-	  bfd_size_type amt;
 
-	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
-	  if (name == NULL)
-	    return FALSE;
+	  if (symndx == -1)
+	    {
+	      sec = bfd_abs_section_ptr;
+	      val = 0;
+	    }
+	  else
+	    {
+	      sec = sections[symndx];
+              val = (sec->output_section->vma
+		     + sec->output_offset
+		     + sym->n_value
+		     - sec->vma);
+	    }
+	}
+      else
+	{
+	  /* Here we chase down both indirects and aliases if we 
+	     find them; in the code below, we may want both
+	     h and h_real (h for names, h_real for values). */
+	  while (h_real->root.type == bfd_link_hash_indirect
+	     || h_real->root.type == bfd_link_hash_warning)
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
 
-	  /* Ignore fake names invented by compiler; treat them all as
-             the same name.  */
-	  if (*name == '~' || *name == '.' || *name == '$'
-	      || (*name == bfd_get_symbol_leading_char (input_bfd)
-		  && (name[1] == '~' || name[1] == '.' || name[1] == '$')))
-	    name = "";
+	  switch (h_real->root.type)
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      sec = h_real->root.u.def.section;
+#ifdef DYNAMIC_LINKING
+	      /* In some cases, we don't need the relocation
+		 value.  We check specially because in some
+		 obscure cases sec->output_section will be NULL.
+		 We'll sort that out in the switch on relocation type
+		 below, and then complain as needed.  */
+	      if (sec == NULL)
+		  valIsValid = FALSE;
+	      else if (sec->output_section == NULL) 
+		{
+	          if ((h_real->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC)==0)
+		      valIsValid = FALSE;
+	        }
+	      else
+#endif
 
-	  mh = coff_debug_merge_hash_lookup (&finfo->debug_merge, name,
-					     TRUE, TRUE);
-	  if (mh == NULL)
-	    return FALSE;
+	      val = (h_real->root.u.def.value
+		     + sec->output_section->vma
+		     + sec->output_offset);
+	      break;
+	    case bfd_link_hash_undefweak:
+	      sec = NULL;
+	      val = 0;
+	      break;
 
-	  /* Allocate memory to hold type information.  If this turns
-             out to be a duplicate, we pass this address to
-             bfd_release.  */
-	  amt = sizeof (struct coff_debug_merge_type);
-	  mt = bfd_alloc (input_bfd, amt);
-	  if (mt == NULL)
-	    return FALSE;
-	  mt->class = isym.n_sclass;
+	    case bfd_link_hash_undefined:
+	    case bfd_link_hash_new:
+	    case bfd_link_hash_common:
 
-	  /* Pick up the aux entry, which points to the end of the tag
-             entries.  */
-	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
-				isym.n_type, isym.n_sclass, 0, isym.n_numaux,
-				&aux);
+	      /* The symbol is undefined (in some way)... some of the above
+		 probably should never be able to happen. */
 
-	  /* Gather the elements.  */
-	  epp = &mt->elements;
-	  mt->elements = NULL;
-	  islp = isymp + 2;
-	  esl = esym + 2 * isymesz;
-	  eslend = ((bfd_byte *) obj_coff_external_syms (input_bfd)
-		    + aux.x_sym.x_fcnary.x_fcn.x_endndx.l * isymesz);
-	  while (esl < eslend)
+#ifdef DYNAMIC_LINKING /* [ */
+	    /* If it has a dynamic index, let it thru (because presumably
+	       it'll get fixed at runtime), except in the special
+	       case of a -Bsymbolic shared lib link. */
+	      if (h->dynindx != -1 && (info->shared? !info->symbolic : TRUE))
 	    {
-	      const char *elename;
-	      char elebuf[SYMNMLEN + 1];
-	      char *name_copy;
+	          val = 0;
+		  valIsValid = TRUE;
+		}
+	      else
+#endif /* ] */
+                {
+  	          valIsValid = FALSE;
+		}
+	      sec = NULL;
+	      break;
 
-	      bfd_coff_swap_sym_in (input_bfd, esl, islp);
+	    /* Should be impossible. */
+  	    case bfd_link_hash_warning:
+  	    case bfd_link_hash_indirect:
+	    default:
+	      abort ();
+	    }
+	}
+
+      /* For non-PE, this may end up either TRUE or FALSE, but it doesn't
+	 matter because imagebase will always be zero. */
+      need_imagebase = !howto->pc_relative
+	&& sec != NULL
+	&& !bfd_is_abs_section(sec->output_section);
+  
+#ifdef DYNAMIC_LINKING /* [ */
+      /* In case some PIC code slipped in here, we have to do this */
+      switch (rel->r_type)
+	{
+	case R_GNU_GOT32:
+	  /* Relocation is to the entry for the original (not the resolved
+	     strong one) symbol in the global offset table.  */
 
-	      amt = sizeof (struct coff_debug_merge_element);
-	      *epp = bfd_alloc (input_bfd, amt);
-	      if (*epp == NULL)
-		return FALSE;
+	  if (h != NULL)
+	    {
+	      bfd_vma off;
 
-	      elename = _bfd_coff_internal_syment_name (input_bfd, islp,
-							elebuf);
-	      if (elename == NULL)
-		return FALSE;
+	      off = h->got_offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
 
-	      amt = strlen (elename) + 1;
-	      name_copy = bfd_alloc (input_bfd, amt);
-	      if (name_copy == NULL)
-		return FALSE;
-	      strcpy (name_copy, elename);
+	      if ( ! dynamic 
+		  || (info->shared
+		      && info->symbolic
+		      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR))
+	          || (h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0)
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally.  We must initialize this entry in the
+		     global offset table.  Since the offset must
+		     always be a multiple of 4, we use the least
+		     significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rel.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+
+      	          BFD_ASSERT (sgot != NULL);
+
+		  if ((off & 1) == 0)
+		    {
+		      /* All "relative" relocs are w.r.t. ImageBase,
+			 for consistency. */
+//fprintf(stderr, "got slot %d initialized for %s\n", off/4, h->root.root.string); //
+		      bfd_put_32 (output_bfd, val + imagebase,
+				  sgot->contents + off);
+		      h->got_offset |= 1;
+		    }
+		  off &= ~1;
+		  /* if !valIsValid, we'll compute trash above, and gripe
+		     later */
+		}
+	      else
+		{
+		  /* If we got into the TRUE branch above, val is
+		     required to be valid.  This (FALSE) case is
+		     that for a TRUE dynamic link, but it's possible
+		     that the symbol doesn't have an output section,
+		     and we don't want to report an error. */
+		  valIsValid = TRUE;
+		}
 
-	      (*epp)->name = name_copy;
-	      (*epp)->type = islp->n_type;
-	      (*epp)->tagndx = 0;
-	      if (islp->n_numaux >= 1
-		  && islp->n_type != T_NULL
-		  && islp->n_sclass != C_EOS)
+	      val = sgot->output_offset + off;
+	    }
+	  else
 		{
-		  union internal_auxent eleaux;
-		  long indx;
+	      /* h == NULL case */
+	      bfd_vma off;
 
-		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
-					islp->n_type, islp->n_sclass, 0,
-					islp->n_numaux, &eleaux);
-		  indx = eleaux.x_sym.x_tagndx.l;
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[symndx] != (bfd_vma) -1);
 
-		  /* FIXME: If this tagndx entry refers to a symbol
-		     defined later in this file, we just ignore it.
-		     Handling this correctly would be tedious, and may
-		     not be required.  */
-		  if (indx > 0
-		      && (indx
-			  < ((esym -
-			      (bfd_byte *) obj_coff_external_syms (input_bfd))
-			     / (long) isymesz)))
+	      off = local_got_offsets[symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+                 the least significant bit to record whether we have
+                 already generated the necessary reloc.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
 		    {
-		      (*epp)->tagndx = finfo->sym_indices[indx];
-		      if ((*epp)->tagndx < 0)
-			(*epp)->tagndx = 0;
+		  /* All "relative" relocs are w.r.t. ImageBase,
+		     for consistency. */
+		  bfd_put_32 (output_bfd, val+imagebase, sgot->contents + off);
+
+		  if (info->shared)
+		    {
+		      outrel.r_vaddr = (sgot->output_section->vma
+					 + sgot->output_offset
+					 + off);
+
+		      /* Note... writing to the GOT relocs, not the rest of the
+			 dynamic relocations */
+		      outrel.r_type = R_GNU_RELATIVE;
+		      outrel.r_symndx = 0;
+		      bfd_coff_swap_reloc_out (output_bfd, &outrel,
+			    (srelgot->contents + srelgot->reloc_count*symrsz));
+#undef DEBUG_COUNTING
+#ifdef DEBUG_COUNTING
+fprintf(stderr, "relgot emits reloc #%d slot %d, anonymous\n", srelgot->reloc_count, off/4); //
+#endif
+		      ++srelgot->reloc_count;
 		    }
+
+		  local_got_offsets[symndx] |= 1;
 		}
-	      epp = &(*epp)->next;
-	      *epp = NULL;
 
-	      esl += (islp->n_numaux + 1) * isymesz;
-	      islp += islp->n_numaux + 1;
+	      /* Since h==NULL, valIsValid is already TRUE */
+	      /* Gas puts the symbol's value in the instruction in this
+		 case, so back it out. */
+	      val = sgot->output_offset + off - sym->n_value;
 	    }
 
-	  /* See if we already have a definition which matches this
-             type.  We always output the type if it has no elements,
-             for simplicity.  */
-	  if (mt->elements == NULL)
-	    bfd_release (input_bfd, mt);
-	  else
-	    {
-	      struct coff_debug_merge_type *mtl;
+	    need_imagebase = FALSE;
 
-	      for (mtl = mh->types; mtl != NULL; mtl = mtl->next)
-		{
-		  struct coff_debug_merge_element *me, *mel;
+	  break;
 
-		  if (mtl->class != mt->class)
-		    continue;
+	case R_GNU_GOTOFF:
+	  /* Relocation is relative to the start of the global offset
+	     table.  */
+
+	  /* Note that sgot->output_offset is not involved in this
+	     calculation.  We always want the start of .got.  If we
+	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
+	     permitted by the ABI, we might have to change this
+	     calculation.  */
+
+	  /* If !valIsValid, the expression below will still operate, but
+	     the error will be detected below. */
+	  val -= sgot->output_section->vma;
+	  need_imagebase = FALSE;
 
-		  for (me = mt->elements, mel = mtl->elements;
-		       me != NULL && mel != NULL;
-		       me = me->next, mel = mel->next)
-		    {
-		      if (strcmp (me->name, mel->name) != 0
-			  || me->type != mel->type
-			  || me->tagndx != mel->tagndx)
+	  break;
+
+	case R_GNU_GOTPC:
+	  /* Use global offset table as symbol value; for synthesizing
+	     the address of the GOT in procedure prologue */
+
+	  need_imagebase = FALSE;
+	  val = sgot->output_section->vma;
+	  valIsValid = TRUE;
+	  break;
+
+	case R_GNU_PLT32:
+	  /* Relocation is to the entry for this symbol in the
+	     procedure linkage table.  */
+
+	  /* Resolve a PLT32 reloc against a local symbol directly,
+             without using the procedure linkage table.  */
+	  if (h == NULL) {
+	      /* Gas puts the symbol's value in the instruction in this
+		 case, so back it out. */
+	      val -= sym->n_value;
 			break;
 		    }
 
-		  if (me == NULL && mel == NULL)
+	  if (h_real->plt_offset == (bfd_vma) -1)
+	    {
+	      /* We didn't make a PLT entry for this (strong) symbol.  This
+                 happens when statically linking PIC code, or when
+                 using -Bsymbolic.  */
 		    break;
 		}
 
-	      if (mtl == NULL || (bfd_size_type) mtl->indx >= syment_base)
+	  val = (splt->output_section->vma
+			+ splt->output_offset
+			+ h_real->plt_offset);
+	  need_imagebase = FALSE;
+	  valIsValid = TRUE;
+
+	  break;
+	
+	case R_SECREL32:
+	  need_imagebase = FALSE;
+	  break;
+	case R_PCRLONG:
+
+	   /* Skip local or localized (by symbolic mode) entries */
+	   if (h == NULL
+	     || (info->symbolic
+		&& (h_real->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0))
+	   break;
+
+	  /* drop thru */
+	case R_DIR32:
+#ifdef USE_COPY_RELOC
+	  /* Don't bother if not a shared lib */
+	  if (info->shared)
+	      break;
+#endif
+	  /* stabs don't need this */
+	  if (is_stab_section)
+	      break;
+
+	  /* When generating a shared object (or when not using
+	     COPY relocations), these relocations
+	     are copied into the output file to be resolved at run
+	     time.  Ditto if a non-shared object and COPY relocations
+	     are not being used. */
+
+#ifndef USE_COPY_RELOC
+	  /* if we don't use copy relocs, certain symbol types will have
+	     leaked thru above that for a main (==not shared) we want to
+	     skip */
+	  if (!info->shared && h != NULL)
 		{
-		  /* This is the first definition of this type.  */
-		  mt->indx = output_index;
-		  mt->next = mh->types;
-		  mh->types = mt;
+	      if (h->dynindx == -1)
+		  break;
+	      /* An ordinary symbol doesn't need a dynamic reloc in main;
+		 we get here when a shared library calls back into main, 
+		 and there are also (ordinary) calls within main. */
+	      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR)!=0
+	          && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC)==0)
+		  break;
+	    }
+#endif
+
+	  outrel.r_vaddr = rel->r_vaddr
+			   + input_section->output_section->vma
+			   + input_section->output_offset;
+
+	  /* The basic idea here is that we may or may not want to
+	     emit either class of relocation; for static relocations,
+	     if this reloc is against an external symbol, we do
+	     not want to fiddle with the addend.  Otherwise, we
+	     need to include the symbol value so that it becomes
+	     an addend for the dynamic reloc.  */
+
+	  if (rel->r_type == R_PCRLONG)
+	    {
+	      if (h != NULL && h_real->dynindx == -1)
+		{
+		  /* The branch is already PC-relative so there's nothing to do
+		     at runtime. */
+		  need_static_reloc = TRUE;
+		}
+	     else if (sec != NULL && bfd_is_abs_section(sec->output_section))
+		{
+		  need_static_reloc = TRUE;
+		  valIsValid = TRUE;
+		  need_dynamic_reloc = FALSE;
 		}
 	      else
 		{
-		  /* This is a redefinition which can be merged.  */
-		  bfd_release (input_bfd, mt);
-		  *indexp = mtl->indx;
-		  add = (eslend - esym) / isymesz;
-		  skip = TRUE;
+		  need_static_reloc = FALSE;
+		  valIsValid = TRUE;
+		  need_dynamic_reloc = TRUE;
+ 		  /* The side effect in this assert (and the similar ones below)
+ 		     is safe... we only count the counters back up for debug 
+		     anyway. */
+		  BFD_ASSERT(!h || ++h->num_relative_relocs_needed <= 0);
+		  outrel.r_type = R_PCRLONG;
+		  outrel.r_symndx = h_real->dynindx;
 		}
 	    }
-	}
-
-      /* We now know whether we are to skip this symbol or not.  */
-      if (! skip)
+	  else
 	{
-	  /* Adjust the symbol in order to output it.  */
+	      /* The only alternative is DIR32 */
 
-	  if (isym._n._n_n._n_zeroes == 0
-	      && isym._n._n_n._n_offset != 0)
+	      if (h == NULL)
 	    {
-	      const char *name;
-	      bfd_size_type indx;
+		  /* symbol is local to the .o */
+		  need_static_reloc = TRUE;
+		  need_dynamic_reloc = info->shared &&
+			!bfd_is_abs_section(sec->output_section);
+		  outrel.r_type = R_GNU_RELATIVE;
+		  outrel.r_symndx = 0;
+		}
+	      else if ((info->symbolic || h->dynindx == -1)
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) != 0)
+		{
+		  /* symbol is local to the module because it's symbolic;
+		     h->dynindx may be -1 if this symbol was marked to
+		     become local. */
+		  need_static_reloc = TRUE;
+#ifdef USE_COPY_RELOC
+		  /* Make this always TRUE if main programs will be 
+		     dynamically relocated (and if .reloc is still
+		     not being generated (for main); currently this only 
+		     happens if ld.so is used as a "run" command, and then
+		     randomly.  It may be necessary to tweak the relocation
+		     counting stuff accordingly. */
+		  need_dynamic_reloc = TRUE;
+#else
+		  need_dynamic_reloc = info->shared;
+#endif
+		  /* no relocs for module local, absolute symbols */
+		  need_dynamic_reloc &= 
+			!bfd_is_abs_section(sec->output_section);
+		  BFD_ASSERT(!need_dynamic_reloc 
+			     || ++h->num_long_relocs_needed <= 0);
+		  outrel.r_type = R_GNU_RELATIVE;
+		  outrel.r_symndx = 0;
+		}
+	      else if (((h->coff_link_hash_flags 
+			  & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	               || ((h->coff_link_hash_flags 
+			  & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+		       || (info->shared && !info->symbolic))
+		{
+		  /* Not defined in this module, or this is a shared 
+		     library (not symbolic), so we need a dynamic reloc;
+		     if it is defined in a main, it always wins even
+		     if there's also a dynamic version. */
+		  BFD_ASSERT (h->dynindx != -1);
+		  need_static_reloc = FALSE;
+		  need_dynamic_reloc = TRUE;
+		  BFD_ASSERT(++h->num_long_relocs_needed <= 0);
+		  valIsValid = TRUE;
+		  outrel.r_type = R_DIR32;
+		  outrel.r_symndx = h->dynindx;
+		}
+	      /* else it gets a static reloc */
+	    }
+	  break;
 
-	      /* This symbol has a long name.  Enter it in the string
-		 table we are building.  Note that we do not check
-		 bfd_coff_symname_in_debug.  That is only true for
-		 XCOFF, and XCOFF requires different linking code
-		 anyhow.  */
-	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
-	      if (name == NULL)
-		return FALSE;
-	      indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
-	      if (indx == (bfd_size_type) -1)
-		return FALSE;
-	      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
+	default:
+	  break;
 	    }
+#endif /* ] */
 
-	  switch (isym.n_sclass)
+      if (!valIsValid)
+	{
+	  if (h_real->root.type == bfd_link_hash_undefined)
 	    {
-	    case C_AUTO:
-	    case C_MOS:
-	    case C_EOS:
-	    case C_MOE:
-	    case C_MOU:
-	    case C_UNTAG:
-	    case C_STRTAG:
-	    case C_ENTAG:
-	    case C_TPDEF:
-	    case C_ARG:
-	    case C_USTATIC:
-	    case C_REG:
-	    case C_REGPARM:
-	    case C_FIELD:
-	      /* The symbol value should not be modified.  */
-	      break;
 
-	    case C_FCN:
-	      if (obj_pe (input_bfd)
-		  && strcmp (isym.n_name, ".bf") != 0
-		  && isym.n_scnum > 0)
+	    if (! info->relocatable)
 		{
-		  /* For PE, .lf and .ef get their value left alone,
-		     while .bf gets relocated.  However, they all have
-		     "real" section numbers, and need to be moved into
-		     the new section.  */
-		  isym.n_scnum = (*secpp)->output_section->target_index;
-		  break;
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, h->root.root.string, input_bfd, input_section,
+		      rel->r_vaddr - input_section->vma, TRUE)))
+		return FALSE;
 		}
-	      /* Fall through.  */
-	    default:
-	    case C_LABEL:  /* Not completely sure about these 2 */
-	    case C_EXTDEF:
-	    case C_BLOCK:
-	    case C_EFCN:
-	    case C_NULL:
-	    case C_EXT:
-	    case C_STAT:
-	    case C_SECTION:
-	    case C_NT_WEAK:
-	      /* Compute new symbol location.  */
-	    if (isym.n_scnum > 0)
+	}
+	  else
 	      {
-		isym.n_scnum = (*secpp)->output_section->target_index;
-		isym.n_value += (*secpp)->output_offset;
-		if (! obj_pe (input_bfd))
-		  isym.n_value -= (*secpp)->vma;
-		if (! obj_pe (finfo->output_bfd))
-		  isym.n_value += (*secpp)->output_section->vma;
+	      (*_bfd_error_handler)
+		(_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
+		 bfd_get_filename (input_bfd), h->root.root.string,
+		 bfd_get_section_name (input_bfd, input_section));
 	      }
-	    break;
 
-	    case C_FILE:
-	      /* The value of a C_FILE symbol is the symbol index of
-		 the next C_FILE symbol.  The value of the last C_FILE
-		 symbol is the symbol index to the first external
-		 symbol (actually, coff_renumber_symbols does not get
-		 this right--it just sets the value of the last C_FILE
-		 symbol to zero--and nobody has ever complained about
-		 it).  We try to get this right, below, just before we
-		 write the symbols out, but in the general case we may
-		 have to write the symbol out twice.  */
-	      if (finfo->last_file_index != -1
-		  && finfo->last_file.n_value != (bfd_vma) output_index)
-		{
-		  /* We must correct the value of the last C_FILE
-                     entry.  */
-		  finfo->last_file.n_value = output_index;
-		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
+	  val = 0;
+	}
+#ifdef DYNAMIC_LINKING
+
+      if (need_dynamic_reloc)
 		    {
-		      /* The last C_FILE symbol is in this input file.  */
-		      bfd_coff_swap_sym_out (output_bfd,
-					     &finfo->last_file,
-					     (finfo->outsyms
-					      + ((finfo->last_file_index
-						  - syment_base)
-						 * osymesz)));
+	  bfd_coff_swap_reloc_out (output_bfd, &outrel,
+				    (struct external_reloc *)
+				      (sreloc->contents
+				     + sreloc->reloc_count * symrsz));
+	  ++sreloc->reloc_count;
+#ifdef DEBUG_COUNTING  // !!
+{
+struct coff_link_hash_entry *hh;
+char buf[SYMNMLEN + 1];
+fprintf(stderr, "added reloc # %d (%d) for %s / %s ", sreloc->reloc_count, outrel.r_type, symndx==-1?"local-symbol":h_real?h->root.root.string:"suppressed-symbol",_bfd_coff_internal_syment_name (input_bfd, sym, buf));
+
+if (symndx!=-1){
+hh = obj_coff_sym_hashes (input_bfd)[symndx];
+if (hh) fprintf(stderr, "%d %d %d\n", (hh->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) != 0, (hh->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0, hh->root.type);
+else fprintf(stderr, "nohash\n");
+}
+}
+#endif
 		    }
-		  else
+
+      if (!need_static_reloc)
+	  continue;
+#endif
+
+    if (need_imagebase)
+	addend += imagebase;
+
+      if (info->base_file)
 		    {
-		      file_ptr pos;
+	  /* Emit a reloc if the backend thinks it needs it.  */
+	  /* Look for other instances of info->base_file in comments
+	     where other relocations may be needed */
 
-		      /* We have already written out the last C_FILE
-			 symbol.  We need to write it out again.  We
-			 borrow *outsym temporarily.  */
-		      bfd_coff_swap_sym_out (output_bfd,
-					     &finfo->last_file, outsym);
-		      pos = obj_sym_filepos (output_bfd);
-		      pos += finfo->last_file_index * osymesz;
-		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
-			  || bfd_bwrite (outsym, osymesz, output_bfd) != osymesz)
+	  if (sym && pe_data (output_bfd)->in_reloc_p (output_bfd, howto))
+	    {
+	      /* Relocation to a symbol in a section which isn't
+		 absolute.  We output the address here to a file.
+		 This file is then read by dlltool when generating the
+		 reloc section.  Note that the base file is not
+		 portable between systems.  We write out a long here,
+		 and dlltool reads in a long.  */
+	      long addr = (rel->r_vaddr
+			   - input_section->vma
+			   + input_section->output_offset
+			   + input_section->output_section->vma);
+	      if (fwrite (&addr, 1, sizeof (long), (FILE *) info->base_file)
+		  != sizeof (long))
+		{
+		  bfd_set_error (bfd_error_system_call);
 			return FALSE;
 		    }
 		}
+	}
 
-	      finfo->last_file_index = output_index;
-	      finfo->last_file = isym;
-	      break;
-	    }
-
-	  /* If doing task linking, convert normal global function symbols to
-	     static functions.  */
-	  if (finfo->info->task_link && IS_EXTERNAL (input_bfd, isym))
-	    isym.n_sclass = C_STAT;
-
-	  /* Output the symbol.  */
-	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);
-
-	  *indexp = output_index;
+      rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					contents,
+					rel->r_vaddr - input_section->vma,
+					val, addend);
 
-	  if (global)
+      switch (rstat)
 	    {
-	      long indx;
-	      struct coff_link_hash_entry *h;
+	default:
+	  abort ();
+	case bfd_reloc_ok:
+	  break;
+	case bfd_reloc_outofrange:
+	  (*_bfd_error_handler)
+	    (_("%B: bad reloc address 0x%lx in section `%A'"),
+	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
+	  return FALSE;
+	case bfd_reloc_overflow:
+	  {
+	    const char *name;
+	    char buf[SYMNMLEN + 1];
 
-	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
-		      / isymesz);
-	      h = obj_coff_sym_hashes (input_bfd)[indx];
-	      if (h == NULL)
+	    if (symndx == -1)
+	      name = "*ABS*";
+	    else if (h != NULL)
+	      name = NULL;
+	    else
 		{
-		  /* This can happen if there were errors earlier in
-                     the link.  */
-		  bfd_set_error (bfd_error_bad_value);
+		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
+		if (name == NULL)
 		  return FALSE;
 		}
-	      h->indx = output_index;
-	    }
 
-	  output_index += add;
-	  outsym += add * osymesz;
+	    if (! ((*info->callbacks->reloc_overflow)
+		   (info, (h ? &h->root : NULL), name, howto->name,
+		    (bfd_vma) 0, input_bfd, input_section,
+		    rel->r_vaddr - input_section->vma)))
+	      return FALSE;
 	}
-
-      esym += add * isymesz;
-      isymp += add;
-      ++secpp;
-      ++indexp;
-      for (--add; add > 0; --add)
-	{
-	  *secpp++ = NULL;
-	  *indexp++ = -1;
 	}
     }
+  return TRUE;
+}
 
-  /* Fix up the aux entries.  This must be done in a separate pass,
-     because we don't know the correct symbol indices until we have
-     already decided which symbols we are going to keep.  */
-  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
-  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
-  isymp = finfo->internal_syms;
-  indexp = finfo->sym_indices;
-  sym_hash = obj_coff_sym_hashes (input_bfd);
-  outsym = finfo->outsyms;
+#ifdef DYNAMIC_LINKING /* [ */
+/* This struct is used to pass information to routines called via
+   coff_link_hash_traverse which must return failure.  */
+struct coff_info_failed
+{
+  bfd_boolean failed;
+  struct bfd_link_info *info;
+};
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
 
-  while (esym < esym_end)
-    {
-      int add;
+static bfd_boolean
+coff_link_create_dynamic_sections (
+     bfd *abfd,
+     struct bfd_link_info *info)
+{
+  flagword flags;
+  register asection *s;
 
-      add = 1 + isymp->n_numaux;
+  if (coff_hash_table (info)->dynamic_sections_created)
+    return TRUE;
 
-      if ((*indexp < 0
-	   || (bfd_size_type) *indexp < syment_base)
-	  && (*sym_hash == NULL
-	      || (*sym_hash)->auxbfd != input_bfd))
-	esym += add * isymesz;
+  /* Make sure that all dynamic sections use the same input BFD.
+     It's likely (almost inevitable) that check_relocs (backend part)
+     captured some file for use as the anchor point for the dynamic sections
+     that wasn't itself a dynamic library.  We'll take what it used. */
+  if (coff_hash_table (info)->dynobj == NULL)
+    coff_hash_table (info)->dynobj = abfd;
       else
-	{
-	  struct coff_link_hash_entry *h;
-	  int i;
+    abfd = coff_hash_table (info)->dynobj;
 
-	  h = NULL;
-	  if (*indexp < 0)
-	    {
-	      h = *sym_hash;
+  /* If this bfd doesn't have the dynamic data add-on, make one for it.
+     (This might be an ordinary .o) */
 
-	      /* The m68k-motorola-sysv assembler will sometimes
-                 generate two symbols with the same name, but only one
-                 will have aux entries.  */
-	      BFD_ASSERT (isymp->n_numaux == 0
-			  || h->numaux == isymp->n_numaux);
+  if (dyn_data(abfd) == NULL)
+      dyn_data(abfd) =
+        (struct dynamic_info *) bfd_zalloc(abfd, sizeof (struct dynamic_info));
+
+  /* Note that we set the SEC_IN_MEMORY flag for all of these
+     sections.  SEC_DEBUGGING was used to avoid unprotecting at runtime,
+     at the cost of breaking the strip command. */
+  flags = ( SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_DATA);
+
+  /* A dynamically linked executable has a .interp section, but a
+     shared library does not.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".interp");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+	return FALSE;
 	    }
 
-	  esym += isymesz;
+  /* Create sections to hold version informations.  These are removed
+     if they are not needed.  */
+  s = bfd_make_section (abfd, ".gnu.version_d");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+  coff_dynverdef(abfd) = s;
 
-	  if (h == NULL)
-	    outsym += osymesz;
+  s = bfd_make_section (abfd, ".gnu.version");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return FALSE;
+  coff_dynversym(abfd) = s;
 
-	  /* Handle the aux entries.  This handling is based on
-	     coff_pointerize_aux.  I don't know if it always correct.  */
-	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
-	    {
-	      union internal_auxent aux;
-	      union internal_auxent *auxp;
+  s = bfd_make_section (abfd, ".gnu.version_r");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
 
-	      if (h != NULL)
-		auxp = h->aux + i;
-	      else
-		{
-		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
-					isymp->n_sclass, i, isymp->n_numaux, &aux);
-		  auxp = &aux;
-		}
+  s = bfd_make_section (abfd, ".dynsym");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+  coff_dynsymtab(abfd) = s;
 
-	      if (isymp->n_sclass == C_FILE)
-		{
-		  /* If this is a long filename, we must put it in the
-		     string table.  */
-		  if (auxp->x_file.x_n.x_zeroes == 0
-		      && auxp->x_file.x_n.x_offset != 0)
-		    {
-		      const char *filename;
-		      bfd_size_type indx;
+  s = bfd_make_section (abfd, ".dynstr");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD))
+    return FALSE;
+  coff_dynstrtab(abfd) = s;
 
-		      BFD_ASSERT (auxp->x_file.x_n.x_offset
-				  >= STRING_SIZE_SIZE);
-		      if (strings == NULL)
+  /* Create a strtab to hold the dynamic symbol names.  */
+  if (coff_hash_table (info)->dynstr == NULL)
 			{
-			  strings = _bfd_coff_read_string_table (input_bfd);
-			  if (strings == NULL)
+      coff_hash_table (info)->dynstr = _bfd_coff_stringtab_init ();
+      if (coff_hash_table (info)->dynstr == NULL)
 			    return FALSE;
 			}
-		      filename = strings + auxp->x_file.x_n.x_offset;
-		      indx = _bfd_stringtab_add (finfo->strtab, filename,
-						 hash, copy);
-		      if (indx == (bfd_size_type) -1)
+
+  s = bfd_make_section (abfd, ".dynamic");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
 			return FALSE;
-		      auxp->x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
-		    }
-		}
-	      else if ((isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
-		       && isymp->n_sclass != C_NT_WEAK)
-		{
-		  unsigned long indx;
+  coff_hash_table (info)->dynamic = s;
 
-		  if (ISFCN (isymp->n_type)
-		      || ISTAG (isymp->n_sclass)
-		      || isymp->n_sclass == C_BLOCK
-		      || isymp->n_sclass == C_FCN)
-		    {
-		      indx = auxp->x_sym.x_fcnary.x_fcn.x_endndx.l;
-		      if (indx > 0
-			  && indx < obj_raw_syment_count (input_bfd))
-			{
-			  /* We look forward through the symbol for
-                             the index of the next symbol we are going
-                             to include.  I don't know if this is
-                             entirely right.  */
-			  while ((finfo->sym_indices[indx] < 0
-				  || ((bfd_size_type) finfo->sym_indices[indx]
-				      < syment_base))
-				 && indx < obj_raw_syment_count (input_bfd))
-			    ++indx;
-			  if (indx >= obj_raw_syment_count (input_bfd))
-			    indx = output_index;
-			  else
-			    indx = finfo->sym_indices[indx];
-			  auxp->x_sym.x_fcnary.x_fcn.x_endndx.l = indx;
-			}
-		    }
+  /* symbol _DYNAMIC is handled in the back end */
 
-		  indx = auxp->x_sym.x_tagndx.l;
-		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
-		    {
-		      long symindx;
+  s = bfd_make_section (abfd, ".hash");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
 
-		      symindx = finfo->sym_indices[indx];
-		      if (symindx < 0)
-			auxp->x_sym.x_tagndx.l = 0;
-		      else
-			auxp->x_sym.x_tagndx.l = symindx;
-		    }
+  /* Let the backend create the rest of the sections.  This lets the
+     backend set the right flags.  The backend will normally create
+     the .got and .plt sections.  */
+  if (! bfd_coff_backend_link_create_dynamic_sections(abfd, info))
+    return FALSE;
 
-		  /* The .bf symbols are supposed to be linked through
-		     the endndx field.  We need to carry this list
-		     across object files.  */
-		  if (i == 0
-		      && h == NULL
-		      && isymp->n_sclass == C_FCN
-		      && (isymp->_n._n_n._n_zeroes != 0
-			  || isymp->_n._n_n._n_offset == 0)
-		      && isymp->_n._n_name[0] == '.'
-		      && isymp->_n._n_name[1] == 'b'
-		      && isymp->_n._n_name[2] == 'f'
-		      && isymp->_n._n_name[3] == '\0')
-		    {
-		      if (finfo->last_bf_index != -1)
-			{
-			  finfo->last_bf.x_sym.x_fcnary.x_fcn.x_endndx.l =
-			    *indexp;
+  coff_hash_table (info)->dynamic_sections_created = TRUE;
 
-			  if ((bfd_size_type) finfo->last_bf_index
-			      >= syment_base)
-			    {
-			      void *auxout;
+  return TRUE;
+}
 
-			      /* The last .bf symbol is in this input
-				 file.  This will only happen if the
-				 assembler did not set up the .bf
-				 endndx symbols correctly.  */
-			      auxout = (finfo->outsyms
-					+ ((finfo->last_bf_index
-					    - syment_base)
-					   * osymesz));
+/* This structure is used to pass information to
+   coff_link_assign_sym_version.  */
 
-			      bfd_coff_swap_aux_out (output_bfd,
-						     &finfo->last_bf,
-						     isymp->n_type,
-						     isymp->n_sclass,
-						     0, isymp->n_numaux,
-						     auxout);
-			    }
-			  else
-			    {
-			      file_ptr pos;
+struct coff_assign_sym_version_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Version tree.  */
+  struct bfd_elf_version_tree *verdefs;
+  /* Whether we are exporting all dynamic symbols.  */
+  bfd_boolean export_dynamic;
+  /* Whether we removed any symbols from the dynamic symbol table.  */
+  bfd_boolean removed_dynamic;
+  /* Whether we had a failure.  */
+  bfd_boolean failed;
+};
 
-			      /* We have already written out the last
-                                 .bf aux entry.  We need to write it
-                                 out again.  We borrow *outsym
-                                 temporarily.  FIXME: This case should
-                                 be made faster.  */
-			      bfd_coff_swap_aux_out (output_bfd,
-						     &finfo->last_bf,
-						     isymp->n_type,
-						     isymp->n_sclass,
-						     0, isymp->n_numaux,
-						     outsym);
-			      pos = obj_sym_filepos (output_bfd);
-			      pos += finfo->last_bf_index * osymesz;
-			      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
-				  || (bfd_bwrite (outsym, osymesz, output_bfd)
-				      != osymesz))
-				return FALSE;
-			    }
+/* This structure is used to pass information to
+   coff_link_find_version_dependencies.  */
+
+struct coff_find_verdep_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* The number of dependencies.  */
+  unsigned int vers;
+  /* Whether we had a failure.  */
+  bfd_boolean failed;
+};
+
+/* Figure out appropriate versions for all the symbols.  We may not
+   have the version number script until we have read all of the input
+   files, so until that point we don't know which symbols should be
+   local.  This function is called via coff_link_hash_traverse.  */
+
+static bfd_boolean coff_link_assign_sym_version 
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static bfd_boolean
+coff_link_assign_sym_version (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_assign_sym_version_info *sinfo =
+    (struct coff_assign_sym_version_info *) data;
+  struct bfd_link_info *info = sinfo->info;
+  char *p;
+
+#if 1
+  /*
+   * FIXME
+   * mayank@14th June, 2007
+   * Need to remove this #ifdef Mayank and make it work(check if this doesnt break anything)
+   */
+#ifdef USE_DLLS
+  /* If this showed up in a DLL after we added it to the dynamic link
+     table... drop it.  However, __imp_* symbols were already treated. */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) != 0 
+       && h->dynindx != -1)
+     {
+	sinfo->removed_dynamic = TRUE;
+	h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	h->dynindx = -1;
+	/* FIXME: The name of the symbol (if long enough) has
+	   already been recorded in the dynamic
+	   string table section.  */
+	return TRUE;
 			}
+#endif
 
-		      if (auxp->x_sym.x_fcnary.x_fcn.x_endndx.l != 0)
-			finfo->last_bf_index = -1;
+  /* If asked to strip specific definitions by name (actually, keep), we 
+     will honor that, we just can't do that for references, however.
+     This allows creation of shared libs with controlled export lists.
+     ...MAYBE_FORCED_LOCAL got set in ...record_dynamic_symbol
+     and found that it was one we might strip.  However, we
+     can only strip locally defined symbols, and since we didn't
+     know at the time, we check again now.   ...MAYBE_FORCED_LOCAL
+     isn't strictly necessary (the hash lookup could be done here) but it
+     helps a little in keeping trash out of the dynamic symbol table;
+     if that's ever fixed, it might be done away with. */
+  if ((h->coff_link_hash_flags & COFF_LINK_MAYBE_FORCED_LOCAL) != 0)
+    {
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0 )
+	{
+	   sinfo->removed_dynamic = TRUE;
+	   h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	   h->dynindx = -1;
+	   /* FIXME: The name of the symbol (if long enough) has
+	      already been recorded in the dynamic
+	      string table section.  */
+	   return TRUE;
+	}
 		      else
 			{
-			  /* The endndx field of this aux entry must
-                             be updated with the symbol number of the
-                             next .bf symbol.  */
-			  finfo->last_bf = *auxp;
-			  finfo->last_bf_index = (((outsym - finfo->outsyms)
-						   / osymesz)
-						  + syment_base);
+	   /* The user asked us to strip an undef or dynamic;
+	      we can't do that. */
+	   h->coff_link_hash_flags &= ~COFF_LINK_MAYBE_FORCED_LOCAL;
+	   (*_bfd_error_handler)
+	     (_("Warning: --retain-symbols would strip %s but it is not "
+	      "locally defined and must be retained."),
+	      h->root.root.string);
+	   h->indx = -2;
 			}
 		    }
+
+  /* We only need version numbers for symbols defined in regular
+     objects.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+    return TRUE;
+
+  p = strchr (h->root.root.string, COFF_VER_CHR);
+  if (h->root.root.string[0] != '?' && p != NULL && h->verinfo.vertree == NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      bfd_boolean hidden;
+
+      hidden = TRUE;
+
+      /* There are two consecutive COFF_VER_CHR characters if this is
+         not a hidden symbol.  */
+      ++p;
+      if (*p == COFF_VER_CHR)
+	{
+	  hidden = FALSE;
+	  ++p;
 		}
 
-	      if (h == NULL)
+      /* If there is no version string, we can just return out.  */
+      if (*p == '\0')
 		{
-		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
-					 isymp->n_sclass, i, isymp->n_numaux,
-					 outsym);
-		  outsym += osymesz;
+	  if (hidden)
+	    h->coff_link_hash_flags |= COFF_LINK_HIDDEN;
+	  return TRUE;
 		}
 
-	      esym += isymesz;
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      int len;
+	      char *alc;
+	      struct bfd_elf_version_expr *d;
+
+	      len = p - h->root.root.string;
+	      alc = bfd_alloc (sinfo->output_bfd, len);
+	      if (alc == NULL)
+	        return FALSE;
+	      strncpy (alc, h->root.root.string, len - 1);
+	      alc[len - 1] = '\0';
+	      if (alc[len - 2] == COFF_VER_CHR)
+	        alc[len - 2] = '\0';
+
+	      h->verinfo.vertree = t;
+	      t->used = TRUE;
+	      d = NULL;
+	      if (t->globals.list != NULL)
+		{
+#if 0
+			/*
+			 * mayank@14th June, 2007
+			 * Match has changed in 2.17
+			 */
+		  for (d = t->globals.list; d != NULL; d = d->next)
+		    if ((*d->match) (d, alc))
+		      break;
+#endif
+			/*
+			 * mayank@14th June, 2007
+			 * Match has changed in 2.17
+			 */
+		  d = (*t->match) (&t->globals, NULL,alc);
+		}
+
+	      /* See if there is anything to force this symbol to
+                 local scope.  */
+	      if (d == NULL && t->locals.list != NULL)
+		{	
+			/*
+			 * mayank@14th June, 2007
+			 * Match has changed in 2.17
+			 */
+			 d = (*t->match) (&t->locals, NULL,alc);
+			 if (d != NULL 
+				&& h->dynindx != -1
+				&& !sinfo->export_dynamic)
+			 {
+ 	 		      sinfo->removed_dynamic = TRUE;
+			      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			      h->coff_link_hash_flags &=~
+				COFF_LINK_HASH_NEEDS_PLT;
+			      h->dynindx = -1;
+			      // h->plt.offset = (bfd_vma) -1;
+			      /* FIXME: The name of the symbol has
+				 already been recorded in the dynamic
+				 string table section.  */
+			    }
+		 }
+#if 0
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((*d->match) (d, alc))
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! sinfo->export_dynamic)
+			    {
+			      sinfo->removed_dynamic = TRUE;
+			      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			      h->coff_link_hash_flags &=~
+				COFF_LINK_HASH_NEEDS_PLT;
+			      h->dynindx = -1;
+			      // h->plt.offset = (bfd_vma) -1;
+			      /* FIXME: The name of the symbol has
+				 already been recorded in the dynamic
+				 string table section.  */
+			    }
+
+			  break;
 	    }
 	}
+#endif
 
-      indexp += add;
-      isymp += add;
-      sym_hash += add;
+	      bfd_release (sinfo->output_bfd, alc);
+	      break;
+	    }
+	}
+#if 0 // discard
+------------
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      h->verinfo.vertree = t;
+	      t->used = TRUE;
+
+	      /* See if there is anything to force this symbol to
+                 local scope.  */
+	      if (t->locals != NULL)
+		{
+		  int len;
+		  char *alc;
+		  struct bfd_elf_version_expr *d;
+
+		  len = p - h->root.root.string;
+		  alc = bfd_alloc (sinfo->output_bfd, len);
+		  if (alc == NULL)
+		    return FALSE;
+		  strncpy (alc, h->root.root.string, len - 1);
+		  alc[len - 1] = '\0';
+		  if (alc[len - 2] == COFF_VER_CHR)
+		    alc[len - 2] = '\0';
+
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((d->match[0] == '*' && d->match[1] == '\0')
+			  || fnmatch (d->match, alc, 0) == 0)
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! sinfo->export_dynamic
+			      && (h->coff_link_hash_flags
+				  & COFF_LINK_HASH_NEEDS_PLT) == 0)
+			    {
+			      sinfo->removed_dynamic = TRUE;
+			      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			      h->dynindx = -1;
+			      /* FIXME: The name of the symbol has
+				 already been recorded in the dynamic
+				 string table section.  */
     }
 
-  /* Relocate the line numbers, unless we are stripping them.  */
-  if (finfo->info->strip == strip_none
-      || finfo->info->strip == strip_some)
-    {
-      for (o = input_bfd->sections; o != NULL; o = o->next)
-	{
-	  bfd_vma offset;
-	  bfd_byte *eline;
-	  bfd_byte *elineend;
-	  bfd_byte *oeline;
-	  bfd_boolean skipping;
-	  file_ptr pos;
-	  bfd_size_type amt;
+			  break;
+			}
+		    }
 
-	  /* FIXME: If SEC_HAS_CONTENTS is not for the section, then
-	     build_link_order in ldwrite.c will not have created a
-	     link order, which means that we will not have seen this
-	     input section in _bfd_coff_final_link, which means that
-	     we will not have allocated space for the line numbers of
-	     this section.  I don't think line numbers can be
-	     meaningful for a section which does not have
-	     SEC_HAS_CONTENTS set, but, if they do, this must be
-	     changed.  */
-	  if (o->lineno_count == 0
-	      || (o->output_section->flags & SEC_HAS_CONTENTS) == 0)
-	    continue;
+		  bfd_release (sinfo->output_bfd, alc);
+		}
 
-	  if (bfd_seek (input_bfd, o->line_filepos, SEEK_SET) != 0
-	      || bfd_bread (finfo->linenos, linesz * o->lineno_count,
-			   input_bfd) != linesz * o->lineno_count)
-	    return FALSE;
+	      break;
+	    }
+	}
+#endif // end discard
 
-	  offset = o->output_section->vma + o->output_offset - o->vma;
-	  eline = finfo->linenos;
-	  oeline = finfo->linenos;
-	  elineend = eline + linesz * o->lineno_count;
-	  skipping = FALSE;
-	  for (; eline < elineend; eline += linesz)
+      /* If we are building an application, we need to create a
+         version node for this version.  */
+      if (t == NULL && ! info->shared)
+	{
+	  struct bfd_elf_version_tree **pp;
+	  int version_index;
+
+	  /* If we aren't going to export this symbol, we don't need
+             to worry about it. */
+	  if (h->dynindx == -1)
+	    return TRUE;
+
+	  t = ((struct bfd_elf_version_tree *)
+	       bfd_alloc (sinfo->output_bfd, sizeof *t));
+	  if (t == NULL)
 	    {
-	      struct internal_lineno iline;
+	      sinfo->failed = TRUE;
+	      return FALSE;
+	    }
 
-	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);
+	  t->next = NULL;
+	  t->name = p;
+	  t->globals.list = NULL;
+	  t->locals.list = NULL;
+	  t->deps = NULL;
+	  t->name_indx = (unsigned int) -1;
+	  t->used = TRUE;
 
-	      if (iline.l_lnno != 0)
-		iline.l_addr.l_paddr += offset;
-	      else if (iline.l_addr.l_symndx >= 0
-		       && ((unsigned long) iline.l_addr.l_symndx
-			   < obj_raw_syment_count (input_bfd)))
-		{
-		  long indx;
+	  version_index = 1;
+	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
+	    ++version_index;
+	  t->vernum = version_index;
 
-		  indx = finfo->sym_indices[iline.l_addr.l_symndx];
+	  *pp = t;
 
-		  if (indx < 0)
-		    {
-		      /* These line numbers are attached to a symbol
-			 which we are stripping.  We must discard the
-			 line numbers because reading them back with
-			 no associated symbol (or associating them all
-			 with symbol #0) will fail.  We can't regain
-			 the space in the output file, but at least
-			 they're dense.  */
-		      skipping = TRUE;
+	  h->verinfo.vertree = t;
 		    }
-		  else
+      else if (t == NULL)
 		    {
-		      struct internal_syment is;
-		      union internal_auxent ia;
+	  /* We could not find the version for a symbol when
+             generating a shared archive.  Return an error.  */
+	  (*_bfd_error_handler)
+	    (_("%s: undefined version name %s"),
+	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
+	  bfd_set_error (bfd_error_bad_value);
+	  sinfo->failed = TRUE;
+	  return FALSE;
+	}
 
-		      /* Fix up the lnnoptr field in the aux entry of
-			 the symbol.  It turns out that we can't do
-			 this when we modify the symbol aux entries,
-			 because gas sometimes screws up the lnnoptr
-			 field and makes it an offset from the start
-			 of the line numbers rather than an absolute
-			 file index.  */
-		      bfd_coff_swap_sym_in (output_bfd,
-					    (finfo->outsyms
-					     + ((indx - syment_base)
-						* osymesz)), &is);
-		      if ((ISFCN (is.n_type)
-			   || is.n_sclass == C_BLOCK)
-			  && is.n_numaux >= 1)
+      if (hidden)
+	h->coff_link_hash_flags |= COFF_LINK_HIDDEN;
+    }
+
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
 			{
-			  void *auxptr;
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *deflt;
+      struct bfd_elf_version_expr *d;
 
-			  auxptr = (finfo->outsyms
-				    + ((indx - syment_base + 1)
-				       * osymesz));
-			  bfd_coff_swap_aux_in (output_bfd, auxptr,
-						is.n_type, is.n_sclass,
-						0, is.n_numaux, &ia);
-			  ia.x_sym.x_fcnary.x_fcn.x_lnnoptr =
-			    (o->output_section->line_filepos
-			     + o->output_section->lineno_count * linesz
-			     + eline - finfo->linenos);
-			  bfd_coff_swap_aux_out (output_bfd, &ia,
-						 is.n_type, is.n_sclass, 0,
-						 is.n_numaux, auxptr);
+      /* See if can find what version this symbol is in.  If the
+         symbol is supposed to be local, then don't actually register
+         it.  */
+      deflt = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals.list != NULL)
+	    {
+			/*
+			 * mayank@14th June, 2007
+			 * Match has changed in 2.17
+			 */
+		    d = (*t->match) ( &t->globals, NULL,h->root.root.string);
+		    if (d != NULL)
+		    {
+		      	h->verinfo.vertree = t;
+			    break;
+		    }
+#if 0
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    {
+		      h->verinfo.vertree = t;
+		      break;
 			}
-
-		      skipping = FALSE;
 		    }
 
-		  iline.l_addr.l_symndx = indx;
+	      if (d != NULL)
+		break;
+#endif
 		}
 
-	      if (!skipping)
+	  if (t->locals.list != NULL)
 	        {
-		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
-		  oeline += linesz;
+			/*
+			 * mayank@14th June, 2007
+			 * Match has changed in 2.17
+			 */
+		    d = (*t->match) ( &t->locals, NULL, h->root.root.string);
+		    if ( d !=NULL)
+		    {	
+			if (d->pattern[0] == '*' && d->pattern[1] == '\0')
+				deflt = t;
+			else {
+			      h->verinfo.vertree = t;
+		      		if (h->dynindx != -1
+			  	&& info->shared
+			  	&& ! sinfo->export_dynamic)
+				{
+			  	sinfo->removed_dynamic = TRUE;
+			  	h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			  	h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+			  	h->dynindx = -1;
+			  // h->plt.offset = (bfd_vma) -1;
+			  /* FIXME: The name of the symbol has already
+			     been recorded in the dynamic string table
+			     section.  */
 		}
 	    }
-
-	  pos = o->output_section->line_filepos;
-	  pos += o->output_section->lineno_count * linesz;
-	  amt = oeline - finfo->linenos;
-	  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
-	      || bfd_bwrite (finfo->linenos, amt, output_bfd) != amt)
-	    return FALSE;
-
-	  o->output_section->lineno_count += amt / linesz;
+			break;
+		    }
+#if 0
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
+		    deflt = t;
+		  else if ((*d->match) (d, h->root.root.string))
+		    {
+		      h->verinfo.vertree = t;
+		      if (h->dynindx != -1
+			  && info->shared
+			  && ! sinfo->export_dynamic)
+			{
+			  sinfo->removed_dynamic = TRUE;
+			  h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			  h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+			  h->dynindx = -1;
+			  // h->plt.offset = (bfd_vma) -1;
+			  /* FIXME: The name of the symbol has already
+			     been recorded in the dynamic string table
+			     section.  */
+			}
+		      break;
+		    }
+		}
+#endif
 	}
     }
 
-  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
-     symbol will be the first symbol in the next input file.  In the
-     normal case, this will save us from writing out the C_FILE symbol
-     again.  */
-  if (finfo->last_file_index != -1
-      && (bfd_size_type) finfo->last_file_index >= syment_base)
+      if (deflt != NULL && h->verinfo.vertree == NULL)
     {
-      finfo->last_file.n_value = output_index;
-      bfd_coff_swap_sym_out (output_bfd, &finfo->last_file,
-			     (finfo->outsyms
-			      + ((finfo->last_file_index - syment_base)
-				 * osymesz)));
+	  h->verinfo.vertree = deflt;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! sinfo->export_dynamic)
+	    {
+	      sinfo->removed_dynamic = TRUE;
+	      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	      h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+	      h->dynindx = -1;
+	      //h->plt.offset = (bfd_vma) -1;
+	      /* FIXME: The name of the symbol has already been
+		 recorded in the dynamic string table section.  */
     }
+	}
+    }
+#if 0 // discard
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *deflt;
+      struct bfd_elf_version_expr *d;
 
-  /* Write the modified symbols to the output file.  */
-  if (outsym > finfo->outsyms)
+      /* See if can find what version this symbol is in.  If the
+         symbol is supposed to eb local, then don't actually register
+         it.  */
+      deflt = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
     {
-      file_ptr pos;
-      bfd_size_type amt;
-
-      pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
-      amt = outsym - finfo->outsyms;
-      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
-	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
-	return FALSE;
-
-      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
-		   + (outsym - finfo->outsyms) / osymesz)
-		  == output_index);
+	  if (t->globals != NULL)
+	    {
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if (fnmatch (d->match, h->root.root.string, 0) == 0)
+		    {
+		      h->verinfo.vertree = t;
+		      break;
+		    }
+		}
 
-      obj_raw_syment_count (output_bfd) = output_index;
+	      if (d != NULL)
+		break;
     }
 
-  /* Relocate the contents of each section.  */
-  adjust_symndx = coff_backend_info (input_bfd)->_bfd_coff_adjust_symndx;
-  for (o = input_bfd->sections; o != NULL; o = o->next)
+	  if (t->locals != NULL)
     {
-      bfd_byte *contents;
-      struct coff_section_tdata *secdata;
-
-      if (! o->linker_mark)
-	/* This section was omitted from the link.  */
-	continue;
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  if (d->match[0] == '*' && d->match[1] == '\0')
+		    deflt = t;
+		  else if (fnmatch (d->match, h->root.root.string, 0) == 0)
+		    {
+		      h->verinfo.vertree = t;
+		      if (h->dynindx != -1
+			  && info->shared
+			  && ! sinfo->export_dynamic
+			  && (h->coff_link_hash_flags
+			      & COFF_LINK_HASH_NEEDS_PLT) == 0)
+			{
+			  sinfo->removed_dynamic = TRUE;
+			  h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			  h->dynindx = -1;
+			  /* FIXME: The name of the symbol has already
+			     been recorded in the dynamic string table
+			     section.  */
+			}
+		      break;
+		    }
+		}
 
-      if ((o->flags & SEC_LINKER_CREATED) != 0)
-	continue;
+	      if (d != NULL)
+		break;
+	    }
+	}
 
-      if ((o->flags & SEC_HAS_CONTENTS) == 0
-	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
+      if (deflt != NULL && h->verinfo.vertree == NULL)
 	{
-	  if ((o->flags & SEC_RELOC) != 0
-	      && o->reloc_count != 0)
+	  h->verinfo.vertree = deflt;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! sinfo->export_dynamic
+	      && (h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) == 0)
 	    {
-	      (*_bfd_error_handler)
-		(_("%B: relocs in section `%A', but it has no contents"),
-		 input_bfd, o);
-	      bfd_set_error (bfd_error_no_contents);
-	      return FALSE;
+	      sinfo->removed_dynamic = TRUE;
+	      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	      h->dynindx = -1;
+	      /* FIXME: The name of the symbol has already been
+		 recorded in the dynamic string table section.  */
+	    }
 	    }
+    }
+#endif // discard
+#endif //Mayank
+
+  return TRUE;
+}
+
+/* This routine is used to export all defined symbols into the dynamic
+   symbol table.  It is called via coff_link_hash_traverse.  */
+
+static bfd_boolean coff_export_symbol 
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static bfd_boolean
+coff_export_symbol (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_info_failed *eif = (struct coff_info_failed *) data;
 
-	  continue;
-	}
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect
+      && !h->root.u.i.info.alias)
+    return TRUE;
 
-      secdata = coff_section_data (input_bfd, o);
-      if (secdata != NULL && secdata->contents != NULL)
-	contents = secdata->contents;
-      else
+  if (h->dynindx == -1
+      && (h->coff_link_hash_flags
+          & (COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_REF_REGULAR)) != 0)
 	{
-	  bfd_size_type x = o->rawsize ? o->rawsize : o->size;
-	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents, 0, x))
+      if (! _bfd_coff_link_record_dynamic_symbol (eif->info, h))
+        {
+          eif->failed = TRUE;
 	    return FALSE;
-	  contents = finfo->contents;
+        }    
 	}
 
-      if ((o->flags & SEC_RELOC) != 0)
-	{
-	  int target_index;
-	  struct internal_reloc *internal_relocs;
-	  struct internal_reloc *irel;
-
-	  /* Read in the relocs.  */
-	  target_index = o->output_section->target_index;
-	  internal_relocs = (_bfd_coff_read_internal_relocs
-			     (input_bfd, o, FALSE, finfo->external_relocs,
-			      finfo->info->relocatable,
-			      (finfo->info->relocatable
-			       ? (finfo->section_info[target_index].relocs
-				  + o->output_section->reloc_count)
-			       : finfo->internal_relocs)));
-	  if (internal_relocs == NULL)
-	    return FALSE;
+  return TRUE;
+}
 
-	  /* Call processor specific code to relocate the section
-             contents.  */
-	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
-					   input_bfd, o,
-					   contents,
-					   internal_relocs,
-					   finfo->internal_syms,
-					   finfo->sec_ptrs))
-	    return FALSE;
+/* This function is used to renumber the dynamic symbols, if some of
+   them are removed because they are marked as local.  This is called
+   via coff_link_hash_traverse.   Since we also want alias symbols
+   to follow the "real" definition, we look for them and emit them
+   in the proper order. */
 
-	  if (finfo->info->relocatable)
-	    {
-	      bfd_vma offset;
-	      struct internal_reloc *irelend;
-	      struct coff_link_hash_entry **rel_hash;
+static bfd_boolean coff_link_renumber_dynsyms
+  PARAMS((struct coff_link_hash_entry *, PTR));
 
-	      offset = o->output_section->vma + o->output_offset - o->vma;
-	      irel = internal_relocs;
-	      irelend = irel + o->reloc_count;
-	      rel_hash = (finfo->section_info[target_index].rel_hashes
-			  + o->output_section->reloc_count);
-	      for (; irel < irelend; irel++, rel_hash++)
-		{
+static bfd_boolean
+coff_link_renumber_dynsyms (h, data)
 		  struct coff_link_hash_entry *h;
-		  bfd_boolean adjusted;
+     PTR data;
+{
+  struct bfd_link_info *info = (struct bfd_link_info *) data;
 
-		  *rel_hash = NULL;
+  if (h->dynindx != -1
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_RENUMBERED) == 0)
+    {
+      if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias) 
+	{
+	  struct coff_link_hash_entry *h_real = h;
 
-		  /* Adjust the reloc address and symbol index.  */
-		  irel->r_vaddr += offset;
+	  if ((h->coff_link_hash_flags 
+		   & (COFF_LINK_HASH_DEF_DYNAMIC | COFF_LINK_HASH_REF_DYNAMIC)) == 0
+	       && !info->shared)
+	    {
+	       /* Under certain circumstances a weak symbol that starts
+		  out as dynmamic can completely disappear into a static symbol.
+		  (When it is a weak for a static strong, e.g. environ.) */
+	       h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	       h->dynindx = -1;
+	       return TRUE;
+	    }
 
-		  if (irel->r_symndx == -1)
-		    continue;
+	  while (h_real->root.type == bfd_link_hash_indirect
+		  && h_real->root.u.i.info.alias)
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+	  if (h_real->dynindx == -1)
+	    {
+              BFD_ASSERT(FALSE); // leave for a while, then delete. (9/00)
+              /* Someone tossed the strong symbol ... the weak one goes too,
+                 or the symbol table structure is bad.
+                 However the weak may have prevented the strong one from
+                 being deleted earlier. */
+	       h->dynindx = -1;
+	       h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	       return TRUE;
+	    }
 
-		  if (adjust_symndx)
+          if ((h_real->coff_link_hash_flags & COFF_LINK_HASH_RENUMBERED) == 0)
 		    {
-		      if (! (*adjust_symndx) (output_bfd, finfo->info,
-					      input_bfd, o, irel,
-					      &adjusted))
-			return FALSE;
-		      if (adjusted)
-			continue;
+              h_real->coff_link_hash_flags |= COFF_LINK_HASH_RENUMBERED;
+	      h_real->dynindx = coff_hash_table (info)->dynsymcount;
+	      ++coff_hash_table (info)->dynsymcount;
 		    }
 
-		  h = obj_coff_sym_hashes (input_bfd)[irel->r_symndx];
-		  if (h != NULL)
-		    {
-		      /* This is a global symbol.  */
-		      if (h->indx >= 0)
-			irel->r_symndx = h->indx;
+	  h->dynindx = coff_hash_table (info)->dynsymcount;
+	  /* The alias itself takes another slot */
+	  coff_hash_table (info)->dynsymcount += 2;
+	}
 		      else
 			{
-			  /* This symbol is being written at the end
-			     of the file, and we do not yet know the
-			     symbol index.  We save the pointer to the
-			     hash table entry in the rel_hash list.
-			     We set the indx field to -2 to indicate
-			     that this symbol must not be stripped.  */
-			  *rel_hash = h;
-			  h->indx = -2;
+	  h->dynindx = coff_hash_table (info)->dynsymcount;
+	  ++coff_hash_table (info)->dynsymcount;
 			}
+      h->coff_link_hash_flags |= COFF_LINK_HASH_RENUMBERED;
 		    }
-		  else
-		    {
-		      long indx;
 
-		      indx = finfo->sym_indices[irel->r_symndx];
-		      if (indx != -1)
-			irel->r_symndx = indx;
-		      else
-			{
-			  struct internal_syment *is;
-			  const char *name;
-			  char buf[SYMNMLEN + 1];
+  return TRUE;
+}
 
-			  /* This reloc is against a symbol we are
-                             stripping.  This should have been handled
-			     by the 'dont_skip_symbol' code in the while
-			     loop at the top of this function.  */
-			  is = finfo->internal_syms + irel->r_symndx;
 
-			  name = (_bfd_coff_internal_syment_name
-				  (input_bfd, is, buf));
-			  if (name == NULL)
-			    return FALSE;
+/* Look through the symbols which are defined in other shared
+   libraries and referenced here.  Update the list of version
+   dependencies.  This will be put into the .gnu.version_r section.
+   This function is called via coff_link_hash_traverse.  */
 
-			  if (! ((*finfo->info->callbacks->unattached_reloc)
-				 (finfo->info, name, input_bfd, o,
-				  irel->r_vaddr)))
-			    return FALSE;
-			}
-		    }
-		}
+static bfd_boolean coff_link_find_version_dependencies
+  PARAMS((struct coff_link_hash_entry *, PTR));
 
-	      o->output_section->reloc_count += o->reloc_count;
-	    }
-	}
+static bfd_boolean
+coff_link_find_version_dependencies (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_find_verdep_info *rinfo = (struct coff_find_verdep_info *) data;
+  coff_internal_verneed *t;
+  coff_internal_vernaux *a;
+
+  /* We only care about symbols defined in shared objects with version
+     information.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+      || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0
+      || h->dynindx == -1
+      || h->verinfo.verdef == NULL)
+    return TRUE;
 
-      /* Write out the modified section contents.  */
-      if (secdata == NULL || secdata->stab_info == NULL)
+  /* See if we already know about this version.  */
+  for (t = dyn_data (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
 	{
-	  file_ptr loc = o->output_offset * bfd_octets_per_byte (output_bfd);
-	  if (! bfd_set_section_contents (output_bfd, o->output_section,
-					  contents, loc, o->size))
-	    return FALSE;
+      if (t->vn_bfd == h->verinfo.verdef->vd_bfd)
+	continue;
+
+      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
+	  return TRUE;
+
+      break;
 	}
-      else
+
+  /* This is a new version.  Add it to tree we are building.  */
+
+  if (t == NULL)
 	{
-	  if (! (_bfd_write_section_stabs
-		 (output_bfd, &coff_hash_table (finfo->info)->stab_info,
-		  o, &secdata->stab_info, contents)))
+      t = (coff_internal_verneed *) bfd_zalloc (rinfo->output_bfd, sizeof *t);
+      if (t == NULL)
+	{
+	  rinfo->failed = TRUE;
 	    return FALSE;
 	}
+
+      t->vn_bfd = h->verinfo.verdef->vd_bfd;
+      t->vn_nextref = dyn_data (rinfo->output_bfd)->verref;
+      dyn_data (rinfo->output_bfd)->verref = t;
     }
 
-  if (! finfo->info->keep_memory
-      && ! _bfd_coff_free_symbols (input_bfd))
-    return FALSE;
+  a = (coff_internal_vernaux *) bfd_zalloc (rinfo->output_bfd, sizeof *a);
+
+  /* Note that we are copying a string pointer here, and testing it
+     above.  If bfd_coff_string_from_coff_section is ever changed to
+     discard the string data when low in memory, this will have to be
+     fixed.  */
+  a->vna_nodename = h->verinfo.verdef->vd_nodename;
+
+  a->vna_flags = h->verinfo.verdef->vd_flags;
+  a->vna_nextptr = t->vn_auxptr;
+
+  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
+  ++rinfo->vers;
+
+  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;
+
+  t->vn_auxptr = a;
 
   return TRUE;
 }
 
-/* Write out a global symbol.  Called via coff_link_hash_traverse.  */
+static bfd_boolean coff_adjust_dynamic_symbol
+  PARAMS ((struct coff_link_hash_entry *, PTR));
 
-bfd_boolean
-_bfd_coff_write_global_sym (struct coff_link_hash_entry *h, void *data)
+/* Make the backend pick a good value for a dynamic symbol.  This is
+   called via coff_link_hash_traverse, and also calls itself
+   recursively.  */
+static bfd_boolean
+coff_adjust_dynamic_symbol (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
 {
-  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
-  bfd *output_bfd;
-  struct internal_syment isym;
-  bfd_size_type symesz;
-  unsigned int i;
-  file_ptr pos;
-
-  output_bfd = finfo->output_bfd;
+  struct coff_info_failed *eif = (struct coff_info_failed *) data;
+  bfd *dynobj = coff_hash_table (eif->info)->dynobj;
+  bfd_boolean skip = FALSE;
+
+  /* If it's a weak symbol, we may need to touch up the corresponding
+     strong symbol, or the weak itself. */
+  if (h->root.type == bfd_link_hash_indirect
+      && h->root.u.i.info.alias)
+    {
+      struct coff_link_hash_entry *h_real = h;
+
+      while (h_real->root.type == bfd_link_hash_indirect
+             && h_real->root.u.i.info.alias)
+       h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+#ifdef USE_DLLS
+      /* If it's a weak symbol that's not a DLL symbol then clear out the DLL 
+	 flag on the strong one... the user really did want it. */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) == 0)
+          h_real->coff_link_hash_flags &= ~COFF_LINK_HASH_DLL_DEFINED;
+#endif
 
-  if (h->root.type == bfd_link_hash_warning)
-    {
-      h = (struct coff_link_hash_entry *) h->root.u.i.link;
-      if (h->root.type == bfd_link_hash_new)
-	return TRUE;
+      /* The strong symbol needs to be referenced from anywhere the weak
+	 one was. */
+      h_real->coff_link_hash_flags 
+	  |= h->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_REF_REGULAR | COFF_LINK_HASH_REF_DYNAMIC);
+
+      /* The weak symbol needs to appear to come from the same source
+	 as the strong one. */
+      h->coff_link_hash_flags 
+	  &= ~(COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_DEF_DYNAMIC);
+      h->coff_link_hash_flags 
+	  |= h_real->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_DEF_DYNAMIC);
+
+      if (!(eif->info)->shared
+         && (h->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_REF_DYNAMIC | COFF_LINK_HASH_DEF_DYNAMIC)) == 0)
+	{
+	   /* Both the strong and weak symbol must be properly present,
+	      or the symbol table structure is bad.
+	      However the weak may have prevented the strong one from
+	      being deleted earlier. */
+	   h->dynindx = -1;
+	   h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	   skip = TRUE;
+	   goto done;
     }
 
-  if (h->indx >= 0)
-    return TRUE;
+      if ((!(eif->info)->shared || (eif->info)->symbolic)
+	  && (h->coff_link_hash_flags 
+	      & (COFF_LINK_HASH_DEF_DYNAMIC | COFF_LINK_HASH_REF_DYNAMIC)) != 0)
+	{
+	   /* We're building an executable; at this point weak refs
+	      to dynamic symbols need to be converted to ordinary
+	      references, so clone the critical info.   Only
+	      weak symbols for which the strong one is also dynamic
+	      get this treatment.  If the strong one is not dynamic,
+	      we just use the weak one.
 
-  if (h->indx != -2
-      && (finfo->info->strip == strip_all
-	  || (finfo->info->strip == strip_some
-	      && (bfd_hash_lookup (finfo->info->keep_hash,
-				   h->root.root.string, FALSE, FALSE)
-		  == NULL))))
-    return TRUE;
+	      Gdb needs type, but so does subsequent code here. */
 
-  switch (h->root.type)
+	    if (h_real->plt_offset != (bfd_vma)-1) 
     {
-    default:
-    case bfd_link_hash_new:
-    case bfd_link_hash_warning:
-      abort ();
-      return FALSE;
-
-    case bfd_link_hash_undefined:
-    case bfd_link_hash_undefweak:
-      isym.n_scnum = N_UNDEF;
-      isym.n_value = 0;
-      break;
+	        h->root.type = h_real->root.type;
+	        h->root.u = h_real->root.u;
+	        h->type = h_real->type;
+	        h->class = h_real->class;
+	        h->numaux = 0;
+	        h->plt_offset = h_real->plt_offset;
 
-    case bfd_link_hash_defined:
-    case bfd_link_hash_defweak:
+	        /* But we don't want a separate .plt entry. */
+	        h->coff_link_hash_flags |= COFF_LINK_WEAK_PLT;
+	        skip = TRUE;
+	        goto done;
+	      }
+	}
+    }
+  /* Ignore (remaining) indirect symbols (both).  
+     Weak indirects don't need further processing.
+     Real indirects are added by the versioning code. */
+  if (h->root.type == bfd_link_hash_indirect)
       {
-	asection *sec;
+       skip=TRUE;
+       goto done;
+    }
 
-	sec = h->root.u.def.section->output_section;
-	if (bfd_is_abs_section (sec))
-	  isym.n_scnum = N_ABS;
+  /* If this symbol was mentioned in a non-COFF file, try to set
+     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
+     permit a non-COFF file to correctly refer to a symbol defined in
+     an COFF dynamic object.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_NON_COFF) != 0)
+    {
+      if (h->root.type != bfd_link_hash_defined
+	  && h->root.type != bfd_link_hash_defweak)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
 	else
-	  isym.n_scnum = sec->target_index;
-	isym.n_value = (h->root.u.def.value
-			+ h->root.u.def.section->output_offset);
-	if (! obj_pe (finfo->output_bfd))
-	  isym.n_value += sec->vma;
+	{
+	  if (h->root.u.def.section->owner != NULL
+	      && (bfd_get_flavour (h->root.u.def.section->owner)
+		  == bfd_target_coff_flavour)
+		  )
+	    h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+	  else
+	    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
       }
-      break;
 
-    case bfd_link_hash_common:
-      isym.n_scnum = N_UNDEF;
-      isym.n_value = h->root.u.c.size;
-      break;
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0)
+	{
+	  if (! _bfd_coff_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = TRUE;
+	      return FALSE;
+	    }
+	}
+    }
 
-    case bfd_link_hash_indirect:
-      /* Just ignore these.  They can't be handled anyhow.  */
-      return TRUE;
+  /* If this is a final link, and the symbol was defined as a common
+     symbol in a regular object file, and there was no definition in
+     any dynamic object, then the linker will have allocated space for
+     the symbol in a common section but the COFF_LINK_HASH_DEF_REGULAR
+     flag will not have been set.  */
+  if (h->root.type == bfd_link_hash_defined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) != 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
+    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+
+  /* If -Bsymbolic was used (which means to bind references to global
+     symbols to the definition within the shared object), and this
+     symbol was defined in a regular object, then it actually doesn't
+     need a PLT entry.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0
+      && eif->info->shared
+      && eif->info->symbolic
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+
+  /* If this symbol does not require a PLT entry, and it is not
+     defined by a dynamic object, or is not referenced by a regular
+     object, ignore it.  We do have to handle a weak defined symbol,
+     even if no regular object refers to it, if we decided to add it
+     to the dynamic symbol table.  FIXME: Do we normally need to worry
+     about symbols which are defined by one dynamic object and
+     referenced by another one?  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) == 0
+      && ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+	  || ((h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0
+#ifdef USE_WEAK
+	       && (h->weakdef == NULL || h->weakdef->dynindx == -1)
+#endif
+	      )))
+    {
+       skip=TRUE;
+       goto done;
     }
 
-  if (strlen (h->root.root.string) <= SYMNMLEN)
-    strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
+  /* if the symbol is defined in a dll, it doesn't need a PLT entry;
+     it's ignorable */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) != 0)
+    {
+       h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+       skip=TRUE;
+       goto done;
+    }
+
+  /* If we've already adjusted this symbol, don't do it again.  This
+     can happen via a recursive call.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
+    {
+       skip=TRUE;
+       goto done;
+    }
+
+  /* Don't look at this symbol again.  Note that we must set this
+     after checking the above conditions, because we may look at a
+     symbol once, decide not to do anything, and then get called
+     recursively later after REF_REGULAR is set below.  */
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DYNAMIC_ADJUSTED;
+
+#ifdef USE_WEAK /* [ */
+  /* If this is a weak definition, and we know a real definition, and
+     the real symbol is not itself defined by a regular object file,
+     then get a good value for the real definition.  We handle the
+     real symbol first, for the convenience of the backend routine.
+
+     Note that there is a confusing case here.  If the real definition
+     is defined by a regular object file, we don't get the real symbol
+     from the dynamic object, but we do get the weak symbol.  If the
+     processor backend uses a COPY reloc, then if some routine in the
+     dynamic object changes the real symbol, we will not see that
+     change in the corresponding weak symbol.  This is the way other
+     ELF linkers work as well, and seems to be a result of the shared
+     library model.
+
+     I will clarify this issue.  Most SVR4 shared libraries define the
+     variable _timezone and define timezone as a weak synonym.  The
+     tzset call changes _timezone.  If you write
+       extern int timezone;
+       int _timezone = 5;
+       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
+     you might expect that, since timezone is a synonym for _timezone,
+     the same number will print both times.  However, if the processor
+     backend uses a COPY reloc, then actually timezone will be copied
+     into your process image, and, since you define _timezone
+     yourself, _timezone will not.  Thus timezone and _timezone will
+     wind up at different memory locations.  The tzset call will set
+     _timezone, leaving timezone unchanged.  */
+
+  if (h->weakdef != NULL)
+    {
+      struct elf_link_hash_entry *weakdef;
+
+      BFD_ASSERT (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak);
+      weakdef = h->weakdef;
+      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
+		  || weakdef->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->elf_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC);
+      if ((weakdef->elf_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	{
+	  /* This symbol is defined by a regular object file, so we
+	     will not do anything special.  Clear weakdef for the
+	     convenience of the processor backend.  */
+	  h->weakdef = NULL;
+	}
   else
     {
-      bfd_boolean hash;
-      bfd_size_type indx;
+	  /* There is an implicit reference by a regular object file
+	     via the weak symbol.  */
+	  weakdef->elf_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+	  if (! elf_adjust_dynamic_symbol (weakdef, (PTR) eif))
+	    return FALSE;
+	}
+    }
+#endif /* ] */
 
-      hash = TRUE;
-      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
-	hash = FALSE;
-      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
-				 FALSE);
-      if (indx == (bfd_size_type) -1)
+done:
+  if (! bfd_coff_backend_adjust_dynamic_symbol (dynobj, eif->info, h, skip))
 	{
-	  finfo->failed = TRUE;
+      eif->failed = TRUE;
 	  return FALSE;
 	}
-      isym._n._n_n._n_zeroes = 0;
-      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
-    }
 
-  isym.n_sclass = h->class;
-  isym.n_type = h->type;
+  return TRUE;
+}
+
+/* Array used to determine the number of hash table buckets to use
+   based on the number of symbols there are.  If there are fewer than
+   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
+   fewer than 37 we use 17 buckets, and so forth.  We never use more
+   than 32771 buckets.  */
+
+static const size_t coff_buckets[] =
+{
+  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
+  16411, 32771, 0
+};
+
+
+/* Set up the sizes and contents of the COFF dynamic sections.  This is
+   called by the COFF linker emulation before_allocation routine.  We
+   must set the sizes of the sections before the linker sets the
+   addresses of the various sections.  */
+
+bfd_boolean
+bfd_coff_size_dynamic_sections (
+     bfd *output_bfd,
+     const char *soname,
+     const char *rpath,
+     const char *filter_shlib,
+     const char * const *auxiliary_filters,
+     struct bfd_link_info *info,
+     asection **sinterpptr,
+     struct bfd_elf_version_tree *verdefs)
+{
+  bfd_size_type soname_indx;
+  bfd *dynobj;
+  bfd_size_type old_dynsymcount;
+
+  struct coff_info_failed eif;
+  struct coff_link_hash_entry *h;
+  bfd_size_type strsize;
+
+  size_t dynsymcount;
+  asection *verdef_section;
+  asection *verref_section;
+  asection *version_section;
+  asection *dynsym_section;
+  asection *hash_section;
+  size_t i;
+  size_t bucketcount = 0;
+  struct internal_syment isym;
+  struct coff_assign_sym_version_info sinfo;
+
+  *sinterpptr = NULL;
 
-  if (isym.n_sclass == C_NULL)
-    isym.n_sclass = C_EXT;
+  soname_indx = (bfd_size_type)-1;
 
-  /* If doing task linking and this is the pass where we convert
-     defined globals to statics, then do that conversion now.  If the
-     symbol is not being converted, just ignore it and it will be
-     output during a later pass.  */
-  if (finfo->global_to_static)
-    {
-      if (! IS_EXTERNAL (output_bfd, isym))
+  if (info->hash->creator->flavour != bfd_target_coff_flavour)
 	return TRUE;
 
-      isym.n_sclass = C_STAT;
+  /* If there were no dynamic objects in the link, there is little to
+     do here.  However, in case we got some PIC in the program, we
+     need to create a GOT, etc. as needed.  We'll wait until
+     we're ready, otherwise. */
+  if (!coff_hash_table(info)->dynamic_sections_created)
+    {
+      if (!bfd_coff_backend_size_dynamic_sections (output_bfd, info))
+	return FALSE;
+      return TRUE;
     }
 
-  /* When a weak symbol is not overridden by a strong one,
-     turn it into an external symbol when not building a
-     shared or relocatable object.  */
-  if (! finfo->info->shared
-      && ! finfo->info->relocatable
-      && IS_WEAK_EXTERNAL (finfo->output_bfd, isym))
-    isym.n_sclass = C_EXT;
-
-  isym.n_numaux = h->numaux;
-
-  bfd_coff_swap_sym_out (output_bfd, &isym, finfo->outsyms);
+  if (dyn_data(output_bfd) == NULL)
+      dyn_data(output_bfd) =
+        (struct dynamic_info *) bfd_zalloc(output_bfd, sizeof (struct dynamic_info));
 
-  symesz = bfd_coff_symesz (output_bfd);
+  output_bfd->flags |= DYNAMIC;
+  dynobj = coff_hash_table (info)->dynobj;
 
-  pos = obj_sym_filepos (output_bfd);
-  pos += obj_raw_syment_count (output_bfd) * symesz;
-  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
-      || bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
+  /* If we are supposed to export all symbols into the dynamic symbol
+     table (this is not the normal case), then do so.  */
+  if (info->export_dynamic)
     {
-      finfo->failed = TRUE;
+      struct coff_info_failed eif;
+
+      eif.failed = FALSE;
+      eif.info = info;
+      coff_link_hash_traverse (coff_hash_table (info), coff_export_symbol,
+			      (PTR) &eif);
+      if (eif.failed)
       return FALSE;
     }
 
-  h->indx = obj_raw_syment_count (output_bfd);
 
-  ++obj_raw_syment_count (output_bfd);
+  *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
+  BFD_ASSERT (*sinterpptr != NULL || info->shared);
 
-  /* Write out any associated aux entries.  Most of the aux entries
-     will have been modified in _bfd_coff_link_input_bfd.  We have to
-     handle section aux entries here, now that we have the final
-     relocation and line number counts.  */
-  for (i = 0; i < isym.n_numaux; i++)
+  if (soname != NULL)
     {
-      union internal_auxent *auxp;
-
-      auxp = h->aux + i;
+      soname_indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					soname, TRUE, TRUE);
+      if (soname_indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_SONAME, soname_indx))
+	return FALSE;
+    }
 
-      /* Look for a section aux entry here using the same tests that
-         coff_swap_aux_out uses.  */
-      if (i == 0
-	  && (isym.n_sclass == C_STAT
-	      || isym.n_sclass == C_HIDDEN)
-	  && isym.n_type == T_NULL
-	  && (h->root.type == bfd_link_hash_defined
-	      || h->root.type == bfd_link_hash_defweak))
+  if (info->symbolic)
 	{
-	  asection *sec;
+      if (! coff_add_dynamic_entry (info, DT_SYMBOLIC, 0))
+	return FALSE;
+    }
 
-	  sec = h->root.u.def.section->output_section;
-	  if (sec != NULL)
+  if (rpath != NULL)
 	    {
-	      auxp->x_scn.x_scnlen = sec->size;
+      bfd_size_type indx;
 
-	      /* For PE, an overflow on the final link reportedly does
-                 not matter.  FIXME: Why not?  */
-	      if (sec->reloc_count > 0xffff
-		  && (! obj_pe (output_bfd)
-		      || finfo->info->relocatable))
-		(*_bfd_error_handler)
-		  (_("%s: %s: reloc overflow: 0x%lx > 0xffff"),
-		   bfd_get_filename (output_bfd),
-		   bfd_get_section_name (output_bfd, sec),
-		   sec->reloc_count);
+      indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr, rpath,
+				 TRUE, TRUE);
+      if (indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_RPATH, indx))
+	return FALSE;
+    }
 
-	      if (sec->lineno_count > 0xffff
-		  && (! obj_pe (output_bfd)
-		      || finfo->info->relocatable))
-		(*_bfd_error_handler)
-		  (_("%s: warning: %s: line number overflow: 0x%lx > 0xffff"),
-		   bfd_get_filename (output_bfd),
-		   bfd_get_section_name (output_bfd, sec),
-		   sec->lineno_count);
+  if (filter_shlib != NULL)
+    {
+      bfd_size_type indx;
 
-	      auxp->x_scn.x_nreloc = sec->reloc_count;
-	      auxp->x_scn.x_nlinno = sec->lineno_count;
-	      auxp->x_scn.x_checksum = 0;
-	      auxp->x_scn.x_associated = 0;
-	      auxp->x_scn.x_comdat = 0;
-	    }
+      indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				 filter_shlib, TRUE, TRUE);
+      if (indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_FILTER, indx))
+	return FALSE;
 	}
 
-      bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,
-			     isym.n_sclass, (int) i, isym.n_numaux,
-			     finfo->outsyms);
-      if (bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
+  if (auxiliary_filters != NULL)
 	{
-	  finfo->failed = TRUE;
+      const char * const *p;
+
+      for (p = auxiliary_filters; *p != NULL; p++)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				     *p, TRUE, TRUE);
+	  if (indx == (bfd_size_type) -1
+	      || ! coff_add_dynamic_entry (info, DT_AUXILIARY, indx))
 	  return FALSE;
 	}
-      ++obj_raw_syment_count (output_bfd);
     }
 
-  return TRUE;
-}
+  /* Find all symbols which were defined in a dynamic object and make
+     the backend pick a reasonable value for them.  */
+  eif.failed = FALSE;
+  eif.info = info;
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_adjust_dynamic_symbol,
+			  (PTR) &eif);
+  if (eif.failed)
+    return FALSE;
+
+  /* Add some entries to the .dynamic section.  We fill in some of the
+     values later, in coff_bfd_final_link, but we must add the entries
+     now so that we know the final size of the .dynamic section.  */
+  h =  coff_link_hash_lookup (coff_hash_table (info), 
+	      &"__init"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+	      FALSE, FALSE, FALSE);
+  if (h != NULL
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      if (! coff_add_dynamic_entry (info, DT_INIT, 0))
+	return FALSE;
+    }
+  h =  coff_link_hash_lookup (coff_hash_table (info), 
+	      &"__fini"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+	      FALSE, FALSE, FALSE);
+  if (h != NULL
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      if (! coff_add_dynamic_entry (info, DT_FINI, 0))
+	return FALSE;
+    }
+  strsize = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+  if (! coff_add_dynamic_entry (info, DT_HASH, 0)
+      || ! coff_add_dynamic_entry (info, DT_STRTAB, 0)
+      || ! coff_add_dynamic_entry (info, DT_SYMTAB, 0)
+      || ! coff_add_dynamic_entry (info, DT_STRSZ, strsize)
+      || ! coff_add_dynamic_entry (info, DT_SYMENT,
+				  bfd_coff_symesz (output_bfd)))
+    return FALSE;
+
+  /* The backend must work out the sizes of all the other dynamic
+     sections.  */
+  old_dynsymcount = coff_hash_table (info)->dynsymcount;
+  if (!bfd_coff_backend_size_dynamic_sections (output_bfd, info))
+    return FALSE;
+
+  /* Set up the version definition section.  */
+  verdef_section = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+  BFD_ASSERT (verdef_section != NULL);
+
+  /* Attach all the symbols to their version information.  This
+     may cause some symbols to be unexported.  */
+  sinfo.output_bfd = output_bfd;
+  sinfo.info = info;
+  sinfo.verdefs = verdefs;
+  sinfo.export_dynamic = info->export_dynamic;
+  sinfo.removed_dynamic = FALSE;
+  sinfo.failed = FALSE;
 
-/* Write out task global symbols, converting them to statics.  Called
-   via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do
-   the dirty work, if the symbol we are processing needs conversion.  */
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_link_assign_sym_version,
+			  (PTR) &sinfo);
+  if (sinfo.failed)
+    return FALSE;
+
+  /* Some dynamic symbols were changed to be local
+     symbols.  In this case, we renumber all of the
+     dynamic symbols, so that we don't have a hole.  If
+     the backend changed dynsymcount, then assume that the
+     new symbols are at the start.  This is the case on
+     the MIPS.  FIXME: The names of the removed symbols
+     will still be in the dynamic string table, wasting
+     space.   Althoug sinfo.removed_dynamic tells us that
+     it's needed for symbol deletions, we do it unconditionally
+     to reorder alias symbols at the same time. */
+  coff_hash_table (info)->dynsymcount =
+    1 + (coff_hash_table (info)->dynsymcount - old_dynsymcount);
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_link_renumber_dynsyms,
+			  (PTR) info);
 
-bfd_boolean
-_bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)
-{
-  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
-  bfd_boolean rtnval = TRUE;
-  bfd_boolean save_global_to_static;
+  /* We may have created additional version definitions if we are
+     just linking a regular application.  */
+  verdefs = sinfo.verdefs;
 
-  if (h->root.type == bfd_link_hash_warning)
-    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+  if (verdefs == NULL)
+    {
+      asection **spp;
 
-  if (h->indx < 0)
+      /* Don't include this section in the output file.  */
+      for (spp = &output_bfd->sections;
+	   *spp != NULL;
+	   spp = &(*spp)->next)
     {
-      switch (h->root.type)
+	  if (*spp == verdef_section->output_section)
 	{
-	case bfd_link_hash_defined:
-	case bfd_link_hash_defweak:
-	  save_global_to_static = finfo->global_to_static;
-	  finfo->global_to_static = TRUE;
-	  rtnval = _bfd_coff_write_global_sym (h, data);
-	  finfo->global_to_static = save_global_to_static;
-	  break;
-	default:
+	      *spp = verdef_section->output_section->next;
+	      --output_bfd->section_count;
 	  break;
 	}
     }
-  return (rtnval);
-}
+    }
+  else
+    {
+      unsigned int cdefs;
+      bfd_size_type size;
+      struct bfd_elf_version_tree *t;
+      bfd_byte *p;
+      coff_internal_verdef def;
+      coff_internal_verdaux defaux;
 
-/* Handle a link order which is supposed to generate a reloc.  */
 
-bfd_boolean
-_bfd_coff_reloc_link_order (bfd *output_bfd,
-			    struct coff_final_link_info *finfo,
-			    asection *output_section,
-			    struct bfd_link_order *link_order)
-{
-  reloc_howto_type *howto;
-  struct internal_reloc *irel;
-  struct coff_link_hash_entry **rel_hash_ptr;
+      cdefs = 0;
+      size = 0;
 
-  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
-  if (howto == NULL)
-    {
-      bfd_set_error (bfd_error_bad_value);
-      return FALSE;
-    }
+      /* Make space for the base version.  */
+      size += sizeof (coff_external_verdef);
+      size += sizeof (coff_external_verdaux);
+      ++cdefs;
 
-  if (link_order->u.reloc.p->addend != 0)
+      for (t = verdefs; t != NULL; t = t->next)
     {
-      bfd_size_type size;
-      bfd_byte *buf;
-      bfd_reloc_status_type rstat;
-      bfd_boolean ok;
-      file_ptr loc;
+	  struct bfd_elf_version_deps *n;
 
-      size = bfd_get_reloc_size (howto);
-      buf = bfd_zmalloc (size);
-      if (buf == NULL)
+	  size += sizeof (coff_external_verdef);
+	  size += sizeof (coff_external_verdaux);
+	  ++cdefs;
+
+	  for (n = t->deps; n != NULL; n = n->next)
+	    size += sizeof (coff_external_verdaux);
+	}
+
+      verdef_section->size = size;
+      verdef_section->contents = (bfd_byte *) bfd_alloc (output_bfd, verdef_section->size);
+      if (verdef_section->contents == NULL && verdef_section->size != 0)
 	return FALSE;
 
-      rstat = _bfd_relocate_contents (howto, output_bfd,
-				      (bfd_vma) link_order->u.reloc.p->addend,\
-				      buf);
-      switch (rstat)
+      /* Fill in the version definition section.  */
+
+      p = verdef_section->contents;
+
+      def.vd_version = VER_DEF_CURRENT;
+      def.vd_flags = VER_FLG_BASE;
+      def.vd_ndx = 1;
+      def.vd_cnt = 1;
+      def.vd_aux = sizeof (coff_external_verdef);
+      def.vd_next = (sizeof (coff_external_verdef)
+		     + sizeof (coff_external_verdaux));
+
+      if (soname_indx != (bfd_size_type)-1)
 	{
-	case bfd_reloc_ok:
-	  break;
-	default:
-	case bfd_reloc_outofrange:
-	  abort ();
-	case bfd_reloc_overflow:
-	  if (! ((*finfo->info->callbacks->reloc_overflow)
-		 (finfo->info, NULL,
-		  (link_order->type == bfd_section_reloc_link_order
-		   ? bfd_section_name (output_bfd,
-				       link_order->u.reloc.p->u.section)
-		   : link_order->u.reloc.p->u.name),
-		  howto->name, link_order->u.reloc.p->addend,
-		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) soname);
+	  defaux.vda_name = soname_indx;
+	}
+      else
 	    {
-	      free (buf);
+	  const char *name;
+	  bfd_size_type indx;
+
+	  name = output_bfd->filename;
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) name);
+	  indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					name, TRUE, FALSE);
+	  if (indx == (bfd_size_type) -1)
 	      return FALSE;
+	  defaux.vda_name = indx;
 	    }
-	  break;
+      defaux.vda_next = 0;
+
+      bfd_coff_swap_verdef_out (output_bfd, &def,
+				(coff_external_verdef *)p);
+      p += sizeof (coff_external_verdef);
+      bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+				 (coff_external_verdaux *) p);
+      p += sizeof (coff_external_verdaux);
+
+      for (t = verdefs; t != NULL; t = t->next)
+	{
+	  unsigned int cdeps;
+	  struct bfd_elf_version_deps *n;
+	  struct coff_link_hash_entry *h;
+
+	  cdeps = 0;
+	  for (n = t->deps; n != NULL; n = n->next)
+	    ++cdeps;
+
+	  /* Add a symbol representing this version.  */
+	  h = NULL;
+	  if (! (bfd_coff_link_add_one_symbol
+		 (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
+		  (bfd_vma) 0, (const char *) NULL, 
+		  FALSE, FALSE,
+		  ((struct bfd_link_hash_entry **)((void *) &h)))))
+	    return FALSE;
+	  h->coff_link_hash_flags &= ~ COFF_LINK_NON_COFF;
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+	  h->type = 0;
+
+	  h->verinfo.vertree = t;
+
+	  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+
+	  def.vd_version = VER_DEF_CURRENT;
+	  def.vd_flags = 0;
+	  if (t->globals.list == NULL && t->locals.list == NULL && ! t->used)
+	    def.vd_flags |= VER_FLG_WEAK;
+	  def.vd_ndx = t->vernum + 1;
+	  def.vd_cnt = cdeps + 1;
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) t->name);
+	  def.vd_aux = sizeof (coff_external_verdef);
+	  if (t->next != NULL)
+	    def.vd_next = (sizeof (coff_external_verdef)
+			   + (cdeps + 1) * sizeof (coff_external_verdaux));
+	  else
+	    def.vd_next = 0;
+
+	  bfd_coff_swap_verdef_out (output_bfd, &def,
+				    (coff_external_verdef *) p);
+	  p += sizeof (coff_external_verdef);
+
+	  defaux.vda_name = h->dynstr_index;
+	  if (t->deps == NULL)
+	    defaux.vda_next = 0;
+	  else
+	    defaux.vda_next = sizeof (coff_external_verdaux);
+	  t->name_indx = defaux.vda_name;
+
+	  bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+				     (coff_external_verdaux *) p);
+	  p += sizeof (coff_external_verdaux);
+
+	  for (n = t->deps; n != NULL; n = n->next)
+	    {
+	      defaux.vda_name = n->version_needed->name_indx;
+	      if (n->next == NULL)
+		defaux.vda_next = 0;
+	      else
+		defaux.vda_next = sizeof (coff_external_verdaux);
+
+	      bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+					 (coff_external_verdaux *) p);
+	      p += sizeof (coff_external_verdaux);
 	}
-      loc = link_order->offset * bfd_octets_per_byte (output_bfd);
-      ok = bfd_set_section_contents (output_bfd, output_section, buf,
-                                     loc, size);
-      free (buf);
-      if (! ok)
+	}
+
+      if (! coff_add_dynamic_entry (info, DT_VERDEF, 0)
+	  || ! coff_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
 	return FALSE;
+
+      dyn_data (output_bfd)->cverdefs = cdefs;
     }
 
-  /* Store the reloc information in the right place.  It will get
-     swapped and written out at the end of the final_link routine.  */
-  irel = (finfo->section_info[output_section->target_index].relocs
-	  + output_section->reloc_count);
-  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
-		  + output_section->reloc_count);
+  /* Work out the size of the version reference section.  */
 
-  memset (irel, 0, sizeof (struct internal_reloc));
-  *rel_hash_ptr = NULL;
+  verref_section = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+  BFD_ASSERT (verref_section != NULL);
+  {
+    struct coff_find_verdep_info sinfo;
 
-  irel->r_vaddr = output_section->vma + link_order->offset;
+    sinfo.output_bfd = output_bfd;
+    sinfo.info = info;
+    sinfo.vers = dyn_data (output_bfd)->cverdefs;
+    if (sinfo.vers == 0)
+      sinfo.vers = 1;
+    sinfo.failed = FALSE;
 
-  if (link_order->type == bfd_section_reloc_link_order)
+    coff_link_hash_traverse (coff_hash_table (info),
+			    coff_link_find_version_dependencies,
+			    (PTR) &sinfo);
+
+    if (dyn_data (output_bfd)->verref == NULL)
     {
-      /* We need to somehow locate a symbol in the right section.  The
-         symbol must either have a value of zero, or we must adjust
-         the addend by the value of the symbol.  FIXME: Write this
-         when we need it.  The old linker couldn't handle this anyhow.  */
-      abort ();
-      *rel_hash_ptr = NULL;
-      irel->r_symndx = 0;
+	asection **spp;
+
+	/* We don't have any version definitions, so we can just
+	   remove the section.  */
+
+	for (spp = &output_bfd->sections;
+	     *spp != NULL;
+	     spp = &(*spp)->next)
+	  {
+	     if (*spp == verref_section->output_section)
+	       {
+		 *spp = verref_section->output_section->next;
+		 --output_bfd->section_count;
+		 break;
+	       }
+	  }
+      }
+    else
+      {
+	coff_internal_verneed *t;
+	unsigned int size;
+	unsigned int crefs;
+	bfd_byte *p;
+
+	/* Build the version definition section.  */
+	size = 0;
+	crefs = 0;
+	for (t = dyn_data (output_bfd)->verref;
+	     t != NULL;
+	     t = t->vn_nextref)
+	  {
+	    coff_internal_vernaux *a;
+
+	    size += sizeof (coff_external_verneed);
+	    ++crefs;
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      size += sizeof (coff_external_vernaux);
+	  }
+
+	verref_section->size = size;
+	verref_section->contents = (bfd_byte *) bfd_alloc (output_bfd, size);
+	if (verref_section->contents == NULL)
+	  return FALSE;
+
+	p = verref_section->contents;
+	for (t = dyn_data (output_bfd)->verref;
+	     t != NULL;
+	     t = t->vn_nextref)
+	  {
+	    unsigned int caux;
+	    coff_internal_vernaux *a;
+	    bfd_size_type indx;
+
+	    caux = 0;
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      ++caux;
+
+	    t->vn_version = VER_NEED_CURRENT;
+	    t->vn_cnt = caux;
+	    indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				       t->vn_bfd->filename, TRUE, FALSE);
+	    if (indx == (bfd_size_type) -1)
+	      return FALSE;
+	    t->vn_file = indx;
+	    t->vn_aux = sizeof (coff_external_verneed);
+	    if (t->vn_nextref == NULL)
+	      t->vn_next = 0;
+	    else
+	      t->vn_next = (sizeof (coff_external_verneed)
+			    + caux * sizeof (coff_external_vernaux));
+
+	    bfd_coff_swap_verneed_out (output_bfd, t,
+				       (coff_external_verneed *) p);
+	    p += sizeof (coff_external_verneed);
+
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      {
+		a->vna_hash = bfd_coff_hash ((const unsigned char *)
+					    a->vna_nodename);
+		indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					   a->vna_nodename, TRUE, FALSE);
+		if (indx == (bfd_size_type) -1)
+		  return FALSE;
+		a->vna_name = indx;
+		if (a->vna_nextptr == NULL)
+		  a->vna_next = 0;
+		else
+		  a->vna_next = sizeof (coff_external_vernaux);
+
+		bfd_coff_swap_vernaux_out (output_bfd, a,
+					   (coff_external_vernaux *) p);
+		p += sizeof (coff_external_vernaux);
+	      }
+	  }
+
+	if (! coff_add_dynamic_entry (info, DT_VERNEED, 0)
+	    || ! coff_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
+	  return FALSE;
+
+	dyn_data (output_bfd)->cverrefs = crefs;
     }
-  else
+  }
+
+  dynsymcount = coff_hash_table (info)->dynsymcount;
+  /* Work out the size of the symbol version section.  */
+  version_section = bfd_get_section_by_name (dynobj, ".gnu.version");
+  BFD_ASSERT (version_section != NULL);
+  if (dynsymcount == 0
+      || (verdefs == NULL && dyn_data (output_bfd)->verref == NULL))
     {
-      struct coff_link_hash_entry *h;
+      asection **spp;
 
-      h = ((struct coff_link_hash_entry *)
-	   bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
-					 link_order->u.reloc.p->u.name,
-					 FALSE, FALSE, TRUE));
-      if (h != NULL)
+      /* We don't need any symbol versions; just discard the
+	 section.  */
+      for (spp = &output_bfd->sections;
+	   *spp != NULL;
+	   spp = &(*spp)->next)
 	{
-	  if (h->indx >= 0)
-	    irel->r_symndx = h->indx;
-	  else
+	   if (*spp == version_section->output_section)
 	    {
-	      /* Set the index to -2 to force this symbol to get
-		 written out.  */
-	      h->indx = -2;
-	      *rel_hash_ptr = h;
-	      irel->r_symndx = 0;
+      		*spp = version_section->output_section->next;
+      		--output_bfd->section_count;
+		break;
+	     }
 	    }
 	}
       else
 	{
-	  if (! ((*finfo->info->callbacks->unattached_reloc)
-		 (finfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
-		  (asection *) NULL, (bfd_vma) 0)))
+      version_section->size = dynsymcount * sizeof (coff_external_versym);
+      version_section->contents = (bfd_byte *) bfd_zalloc (output_bfd, version_section->size);
+      if (version_section->contents == NULL)
+	return FALSE;
+
+      if (! coff_add_dynamic_entry (info, DT_VERSYM, 0))
 	    return FALSE;
-	  irel->r_symndx = 0;
 	}
+  /* Set the size of the .dynsym and .hash sections.  We counted
+     the number of dynamic symbols in coff_link_add_object_symbols.
+     We will build the contents of .dynsym and .hash when we build
+     the final symbol table, because until then we do not know the
+     correct value to give the symbols.  We built the .dynstr
+     section as we went along in coff_link_add_object_symbols.  */
+  dynsym_section = bfd_get_section_by_name (dynobj, ".dynsym");
+  BFD_ASSERT (dynsym_section != NULL);
+  dynsym_section->size = dynsymcount * bfd_coff_symesz (output_bfd);
+  dynsym_section->contents = (bfd_byte *) bfd_alloc (output_bfd, dynsym_section->size);
+  if (dynsym_section->contents == NULL && dynsym_section->size != 0)
+    return FALSE;
+
+  memset(&isym, 0, sizeof(isym));
+
+  bfd_coff_swap_sym_out (output_bfd, &isym,
+		       (PTR) (struct external_syment *) dynsym_section->contents);
+
+  for (i = 0; coff_buckets[i] != 0; i++)
+    {
+      bucketcount = coff_buckets[i];
+      if (dynsymcount < coff_buckets[i + 1])
+	break;
     }
 
-  /* FIXME: Is this always right?  */
-  irel->r_type = howto->type;
+  hash_section = bfd_get_section_by_name (dynobj, ".hash");
+  BFD_ASSERT (hash_section != NULL);
+  hash_section->size = (2 + bucketcount + dynsymcount) * (ARCH_SIZE / 8);
+  hash_section->contents = (bfd_byte *) bfd_alloc (output_bfd, hash_section->size);
+  if (hash_section->contents == NULL)
+    return FALSE;
 
-  /* r_size is only used on the RS/6000, which needs its own linker
-     routines anyhow.  r_extern is only used for ECOFF.  */
+  memset (hash_section->contents, 0, (size_t) hash_section->size);
 
-  /* FIXME: What is the right value for r_offset?  Is zero OK?  */
-  ++output_section->reloc_count;
+  bfd_h_put_32 (output_bfd, bucketcount, hash_section->contents);
+  bfd_h_put_32 (output_bfd, dynsymcount, hash_section->contents + (ARCH_SIZE / 8));
+
+  coff_hash_table (info)->bucketcount = bucketcount;
+
+  hash_section = bfd_get_section_by_name (dynobj, ".dynstr");
+  BFD_ASSERT (hash_section != NULL);
+  hash_section->size = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+
+  if (! coff_add_dynamic_entry (info, DT_NULL, 0))
+    return FALSE;
 
   return TRUE;
 }
 
-/* A basic reloc handling routine which may be used by processors with
-   simple relocs.  */
-
 bfd_boolean
-_bfd_coff_generic_relocate_section (bfd *output_bfd,
+_bfd_coff_create_got_section (
+     bfd *abfd,
 				    struct bfd_link_info *info,
-				    bfd *input_bfd,
-				    asection *input_section,
-				    bfd_byte *contents,
-				    struct internal_reloc *relocs,
-				    struct internal_syment *syms,
-				    asection **sections)
+     char *gotname,
+     bfd_boolean want_got_plt)
 {
-  struct internal_reloc *rel;
-  struct internal_reloc *relend;
-
-  rel = relocs;
-  relend = rel + input_section->reloc_count;
-  for (; rel < relend; rel++)
-    {
-      long symndx;
+  flagword flags;
+  register asection *s;
       struct coff_link_hash_entry *h;
-      struct internal_syment *sym;
-      bfd_vma addend;
-      bfd_vma val;
-      reloc_howto_type *howto;
-      bfd_reloc_status_type rstat;
 
-      symndx = rel->r_symndx;
+  /* This function may be called more than once.  */
+  if (coff_hash_table (info)->sgot != NULL)
+    return TRUE;
 
-      if (symndx == -1)
-	{
-	  h = NULL;
-	  sym = NULL;
-	}
-      else if (symndx < 0
-	       || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
-	{
-	  (*_bfd_error_handler)
-	    ("%B: illegal symbol index %ld in relocs", input_bfd, symndx);
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_DATA );
+
+  s = bfd_make_section (abfd, ".got");
+  coff_hash_table (info)->sgot = s;
+  if (s == NULL
+      || !bfd_set_section_flags (abfd, s, flags)
+      || !bfd_set_section_alignment (abfd, s, 2))
 	  return FALSE;
-	}
-      else
+
+  if (want_got_plt)
 	{
-	  h = obj_coff_sym_hashes (input_bfd)[symndx];
-	  sym = syms + symndx;
+    s = bfd_make_section (abfd, ".got.plt");
+    coff_hash_table (info)->sgotplt = s;
+    if (s == NULL
+	|| !bfd_set_section_flags (abfd, s, flags)
+	|| !bfd_set_section_alignment (abfd, s, 2))
+      return FALSE;
+
+      /* The first three global offset table entries are reserved (which 
+	 actually fall in .got.plt).  */
+      s->size += 3 * 4;
+
 	}
 
-      /* COFF treats common symbols in one of two ways.  Either the
-         size of the symbol is included in the section contents, or it
-         is not.  We assume that the size is not included, and force
-         the rtype_to_howto function to adjust the addend as needed.  */
-      if (sym != NULL && sym->n_scnum != 0)
-	addend = - sym->n_value;
-      else
-	addend = 0;
+  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
+     (or .got.plt) section.  We don't do this in the linker script
+     because we don't want to define the symbol if we are not creating
+     a global offset table.   Since the spelling varies per architecture,
+     it's an argument. */
+  h = NULL;
+  if (!(bfd_coff_link_add_one_symbol
+	(info, abfd, gotname, BSF_GLOBAL, s, (bfd_vma) 0,
+	 (const char *) NULL, 
+	 FALSE, FALSE,
+	 ((struct bfd_link_hash_entry **)((void *) &h)))))
+    return FALSE;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+  h->type = 0;
 
-      howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,
-				       sym, &addend);
-      if (howto == NULL)
+  if (info->shared
+      && ! _bfd_coff_link_record_dynamic_symbol (info, h))
 	return FALSE;
 
-      /* If we are doing a relocatable link, then we can just ignore
-         a PC relative reloc that is pcrel_offset.  It will already
-         have the correct value.  If this is not a relocatable link,
-         then we should ignore the symbol value.  */
-      if (howto->pc_relative && howto->pcrel_offset)
-	{
-	  if (info->relocatable)
-	    continue;
-	  if (sym != NULL && sym->n_scnum != 0)
-	    addend += sym->n_value;
-	}
+  coff_hash_table (info)->hgot = h;
 
-      val = 0;
+  return TRUE;
+}
 
-      if (h == NULL)
-	{
-	  asection *sec;
 
-	  if (symndx == -1)
-	    {
-	      sec = bfd_abs_section_ptr;
-	      val = 0;
-	    }
-	  else
-	    {
-	      sec = sections[symndx];
-              val = (sec->output_section->vma
-		     + sec->output_offset
-		     + sym->n_value);
-	      if (! obj_pe (input_bfd))
-		val -= sec->vma;
-	    }
-	}
-      else
-	{
-	  if (h->root.type == bfd_link_hash_defined
-	      || h->root.type == bfd_link_hash_defweak)
-	    {
-	      /* Defined weak symbols are a GNU extension. */
-	      asection *sec;
 
-	      sec = h->root.u.def.section;
-	      val = (h->root.u.def.value
-		     + sec->output_section->vma
-		     + sec->output_offset);
-	    }
 
-	  else if (h->root.type == bfd_link_hash_undefweak)
-	    {
-              if (h->class == C_NT_WEAK && h->numaux == 1)
-		{
-		  /* See _Microsoft Portable Executable and Common Object
-                     File Format Specification_, section 5.5.3.
-		     Note that weak symbols without aux records are a GNU
-		     extension.
-		     FIXME: All weak externals are treated as having
-		     characteristic IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY (1).
-		     These behave as per SVR4 ABI:  A library member
-		     will resolve a weak external only if a normal
-		     external causes the library member to be linked.
-		     See also linker.c: generic_link_check_archive_element. */
-		  asection *sec;
-		  struct coff_link_hash_entry *h2 =
-		    input_bfd->tdata.coff_obj_data->sym_hashes[
-		    h->aux->x_sym.x_tagndx.l];
+/* Record a new dynamic symbol.  We record the dynamic symbols as we
+   read the input files, since we need to have a list of all of them
+   before we can determine the final sizes of the output sections.
+   Note that we may actually call this function even though we are not
+   going to output any dynamic symbols; in some cases we know that a
+   symbol should be in the dynamic symbol table, but only if there is
+   one.  */
+
+bfd_boolean
+_bfd_coff_link_record_dynamic_symbol (
+     struct bfd_link_info *info,
+     struct coff_link_hash_entry *h)
+{
+  struct bfd_strtab_hash *dynstr;
+  char *p, *alc;
+  const char *name;
+  bfd_boolean copy;
+  bfd_size_type indx;
+
+  /* Nothing to do, don't bother */
+  if (h->dynindx != -1)
+      return TRUE;
 
-		  if (!h2 || h2->root.type == bfd_link_hash_undefined)
+  /* We're skipping this one for some outside reason; skip it again */
+  if ((h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0)
+      return TRUE;
+
+  if (info->strip == strip_some
+	&& bfd_hash_lookup (info->keep_hash,
+				h->root.root.string,
+				FALSE, FALSE) == NULL)
+  {
+     /* We've been asked to strip this symbol; if we can (and sometimes
+	we can't) we'll treat it as a local symbol.
+        If it's already defined locally, we'll simply not record it;
+	if it isn't defined, flag it for later analysis */
+     if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0 )
 		    {
-		      sec = bfd_abs_section_ptr;
-		      val = 0;
+          h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+          return TRUE;
 		    }
 		  else
 		    {
-		      sec = h2->root.u.def.section;
-		      val = h2->root.u.def.value
-			+ sec->output_section->vma + sec->output_offset;
+          h->coff_link_hash_flags |= COFF_LINK_MAYBE_FORCED_LOCAL;
 		    }
 		}
-	      else
-                /* This is a GNU extension.  */
-		val = 0;
+  
+  h->dynindx = coff_hash_table (info)->dynsymcount;
+  ++coff_hash_table (info)->dynsymcount;
+
+  /* If this is a PE weak symbol, we'll have to emit a weak alias AUX
+     entry, so leave space for it here. */
+  if (h->root.type == bfd_link_hash_indirect
+      && h->root.u.i.info.alias)
+    {
+      ++coff_hash_table (info)->dynsymcount;
 	    }
 
-	  else if (! info->relocatable)
+  dynstr = coff_hash_table (info)->dynstr;
+  if (dynstr == NULL)
 	    {
-	      if (! ((*info->callbacks->undefined_symbol)
-		     (info, h->root.root.string, input_bfd, input_section,
-		      rel->r_vaddr - input_section->vma, TRUE)))
+      /* Create a strtab to hold the dynamic symbol names.  */
+      coff_hash_table (info)->dynstr = dynstr = _bfd_coff_stringtab_init ();
+      if (dynstr == NULL)
 		return FALSE;
 	    }
-	}
 
-      if (info->base_file)
-	{
-	  /* Emit a reloc if the backend thinks it needs it.  */
-	  if (sym && pe_data (output_bfd)->in_reloc_p (output_bfd, howto))
+  /* We don't put any version information in the dynamic string
+     table.  */
+  name = h->root.root.string;
+  p = strchr (name, COFF_VER_CHR);
+  if (p == NULL)
 	    {
-	      /* Relocation to a symbol in a section which isn't
-		 absolute.  We output the address here to a file.
-		 This file is then read by dlltool when generating the
-		 reloc section.  Note that the base file is not
-		 portable between systems.  We write out a long here,
-		 and dlltool reads in a long.  */
-	      long addr = (rel->r_vaddr
-			   - input_section->vma
-			   + input_section->output_offset
-			   + input_section->output_section->vma);
-	      if (coff_data (output_bfd)->pe)
-		addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
-	      if (fwrite (&addr, 1, sizeof (long), (FILE *) info->base_file)
-		  != sizeof (long))
+      alc = NULL;
+      copy = FALSE;
+    }
+  else
 		{
-		  bfd_set_error (bfd_error_system_call);
+      alc = bfd_malloc (p - name + 1);
+      if (alc == NULL)
 		  return FALSE;
-		}
-	    }
+      strncpy (alc, name, p - name);
+      alc[p - name] = '\0';
+      name = alc;
+      copy = TRUE;
 	}
 
-      rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
-					contents,
-					rel->r_vaddr - input_section->vma,
-					val, addend);
+  indx = _bfd_stringtab_add (dynstr, name, TRUE, copy);
 
-      switch (rstat)
-	{
-	default:
-	  abort ();
-	case bfd_reloc_ok:
-	  break;
-	case bfd_reloc_outofrange:
-	  (*_bfd_error_handler)
-	    (_("%B: bad reloc address 0x%lx in section `%A'"),
-	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
-	  return FALSE;
-	case bfd_reloc_overflow:
-	  {
-	    const char *name;
-	    char buf[SYMNMLEN + 1];
+  if (alc != NULL)
+    free (alc);
 
-	    if (symndx == -1)
-	      name = "*ABS*";
-	    else if (h != NULL)
-	      name = NULL;
-	    else
-	      {
-		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
-		if (name == NULL)
+  if (indx == (bfd_size_type) -1)
 		  return FALSE;
-	      }
+  h->dynstr_index = indx;
 
-	    if (! ((*info->callbacks->reloc_overflow)
-		   (info, (h ? &h->root : NULL), name, howto->name,
-		    (bfd_vma) 0, input_bfd, input_section,
-		    rel->r_vaddr - input_section->vma)))
+  return TRUE;
+}
+
+/* Add an entry to the .dynamic table.  */
+
+bfd_boolean
+coff_add_dynamic_entry (
+     struct bfd_link_info *info,
+     bfd_vma tag,
+     bfd_vma val)
+{
+  coff_internal_dyn dyn;
+  bfd *dynobj;
+  asection *s;
+  size_t newsize;
+  bfd_byte *newcontents;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  s = coff_hash_table (info)->dynamic;
+
+  BFD_ASSERT (s != NULL);
+
+  newsize = s->size + sizeof (coff_external_dyn);
+  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
+  if (newcontents == NULL)
 	      return FALSE;
-	  }
-	}
-    }
+
+  dyn.d_tag = tag;
+  dyn.d_un.d_val = val;
+  bfd_coff_swap_dyn_out (dynobj, &dyn,
+		    (coff_external_dyn *) (newcontents + s->size));
+
+  s->size = newsize;
+  s->contents = newcontents;
+
   return TRUE;
 }
+
+/* This is a hook for the emulation code in the generic linker to
+   tell the backend linker what file name to use for the DT_NEEDED
+   entry for a dynamic object.  The generic linker passes name as an
+   empty string to indicate that no DT_NEEDED entry should be made.  */
+
+void
+bfd_coff_set_dt_needed_name (
+     bfd *abfd,
+     const char *name)
+{
+  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour
+      && bfd_get_format (abfd) == bfd_object)
+    coff_dt_name (abfd) = name;
+}
+
+/* Get the list of DT_NEEDED entries for a link.  This is a hook for
+   the emulation code.  */
+
+struct bfd_link_needed_list *
+bfd_coff_get_needed_list (
+     bfd *abfd ATTRIBUTE_UNUSED,
+     struct bfd_link_info *info)
+{
+  if (info->hash->creator->flavour != bfd_target_coff_flavour)
+    return NULL;
+  return coff_hash_table (info)->needed;
+}
+
+/* Get the name actually used for a dynamic object for a link.  This
+   is the SONAME entry if there is one.  Otherwise, it is the string
+   passed to bfd_coff_set_dt_needed_name, or it is the filename.  */
+
+const char *
+bfd_coff_get_dt_soname (
+     bfd *abfd)
+{
+  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour
+      && bfd_get_format (abfd) == bfd_object
+      && dyn_data(abfd) != NULL)
+    return coff_dt_name (abfd);
+  return NULL;
+}
+#endif /* ] */
diff -ruNbB binutils-2.17/bfd/configure binutils-2.17.sua/bfd/configure
--- binutils-2.17/bfd/configure	2006-06-23 20:17:03 +0200
+++ binutils-2.17.sua/bfd/configure	2008-04-01 09:03:07 +0200
@@ -14605,7 +14605,7 @@
 }'
 fi
 
-DEFS=-DHAVE_CONFIG_H
+DEFS="-DHAVE_CONFIG_H -D_ALL_SOURCE"
 
 ac_libobjs=
 ac_ltlibobjs=
diff -ruNbB binutils-2.17/bfd/doc/bfd.info binutils-2.17.sua/bfd/doc/bfd.info
--- binutils-2.17/bfd/doc/bfd.info	2006-06-12 15:37:32 +0200
+++ binutils-2.17.sua/bfd/doc/bfd.info	2008-04-01 09:03:08 +0200
@@ -1,5 +1,6 @@
-This is ../.././bfd/doc/bfd.info, produced by makeinfo version 4.8 from
-../.././bfd/doc/bfd.texinfo.
+This is ../../../../gcc_depot/binutils-2.17/bfd/doc/bfd.info, produced
+by makeinfo version 4.8 from
+../../../../gcc_depot/binutils-2.17/bfd/doc/bfd.texinfo.
 
 START-INFO-DIR-ENTRY
 * Bfd: (bfd).                   The Binary File Descriptor library.
@@ -417,6 +418,13 @@
           be used only for archive elements.  */
        int archive_pass;
 
+     /* #ifdef DYNAMIC_LINKING */
+         /* Used by some backends for dynamic link private data; independent
+            of per-format private data. */
+         struct dynamic_info *dynamic_info;  /* used by shared libs only */
+         bfd_vma *local_got_offsets; /* used if dynamic linking on all bfds */
+     /* #endif */
+
        /* Used by the back end to hold private data.  */
        union
          {
@@ -586,6 +594,16 @@
    *Description*
 Return the BFD error handler function.
 
+2.2.2.4 `bfd_archive_filename'
+..............................
+
+*Synopsis*
+     const char *bfd_archive_filename (bfd *);
+   *Description*
+For a BFD that is a component of an archive, returns a string with both
+the archive name and file name.  For other BFDs, just returns the file
+name.
+
 2.3 Miscellaneous
 =================
 
@@ -883,6 +901,9 @@
        (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
         bfd_boolean, asymbol **);
 
+     /* In case we're exec()-ing, we need to clean up JUST the fd */
+     #define bfd_fileno(abfd) fileno((FILE *)((abfd)->iostream))
+
 2.3.1.16 `bfd_alt_mach_code'
 ............................
 
@@ -1192,6 +1213,44 @@
 Here is the section structure:
 
 
+
+     /* This enum exists so that transition to an abstraction can start;
+        use with bfd_{get_,set_,}section_value_flag. */
+     enum section_sec_flags {
+            sec_flag_ALLOC,
+            sec_flag_LOAD,
+            sec_flag_RELOC,
+            sec_flag_ARCH_BIT_0,
+            sec_flag_READONLY,
+            sec_flag_CODE,
+            sec_flag_DATA,
+            sec_flag_ROM,
+            sec_flag_CONSTRUCTOR,
+            sec_flag_HAS_CONTENTS,
+            sec_flag_NEVER_LOAD,
+            sec_flag_COFF_SHARED_LIBRARY,
+            sec_flag_reserved1, sec_flag_reserved2, /* for constructor types */
+            sec_flag_HAS_GOT_REF,
+            sec_flag_IS_COMMON,
+            sec_flag_DEBUGGING,
+            sec_flag_IN_MEMORY,
+            sec_flag_EXCLUDE,
+            sec_flag_SORT_ENTRIES,
+            sec_flag_LINK_ONCE,
+            sec_flag_reserved3,sec_flag_reserved4, /* for comdat types */
+            sec_flag_LINKER_CREATED,
+            sec_flag_KEEP,
+            sec_flag_SMALL_DATA,
+            sec_flag_SHARED,
+            sec_flag_BLOCK,
+            sec_flag_CLINK,
+            sec_flag_MERGE,
+            sec_flag_STRINGS,
+            sec_flag_GROUP,
+            sec_flag_NOREAD,
+           sec_flag_last  /* The traditional "last" value */
+     };
+
      typedef struct bfd_section
      {
        /* The name of the section; the name isn't a copy, the pointer is
@@ -1214,6 +1273,8 @@
           flags are read in from the object file, and some are
           synthesized from other information.  */
        flagword flags;
+       flagword more_flags[1];
+
 
      #define SEC_NO_FLAGS   0x000
 
@@ -1501,6 +1562,23 @@
        /* File position of line data.  */
        file_ptr line_filepos;
 
+     /* #ifdef DYNAMIC_LINKING */
+       /* Certain sections need counts, which we overload into the
+          coff number of relocs and/or number of line numbers fields,
+          but carrying those in the same fields here is asking for
+          trouble, so the overloaded ones live here. */
+
+       unsigned int info_r;
+       unsigned int info_l;
+
+       /* There are multiple string tables possible when dynamically
+          linking; this is the section number for the string table
+          for this section */
+
+       int link_index;
+
+     /* #endif */
+
        /* Pointer to data for applications.  */
        void *userdata;
 
@@ -1992,7 +2070,21 @@
           BFD_SEND (obfd, _bfd_copy_private_section_data, \
                     (ibfd, isection, obfd, osection))
 
-2.6.5.18 `bfd_generic_is_group_section'
+2.6.5.18 `_bfd_strip_section_from_output'
+.........................................
+
+*Synopsis*
+     void _bfd_strip_section_from_output
+        (struct bfd_link_info *info, asection *section);
+   *Description*
+Remove SECTION from the output.  If the output section becomes empty,
+remove it from the output bfd.
+
+   This function won't actually do anything except twiddle flags if
+called too late in the linking process, when it's not safe to remove
+sections.
+
+2.6.5.19 `bfd_generic_is_group_section'
 .......................................
 
 *Synopsis*
@@ -2000,7 +2092,7 @@
    *Description*
 Returns TRUE if SEC is a member of a group.
 
-2.6.5.19 `bfd_generic_discard_group'
+2.6.5.20 `bfd_generic_discard_group'
 ....................................
 
 *Synopsis*
@@ -5247,6 +5339,12 @@
          the contents of a file.  */
        enum bfd_flavour flavour;
 
+      /* Input format: if the file format for input to the linker is not the same
+         as the output format, then a pointer to the input format type goes here
+         in the output format's record.  (This happens for PE/PEI, at least.) */
+
+       const struct bfd_target *input_format;
+
        /* The order of bytes within the data area of a file.  */
        enum bfd_endian byteorder;
 
@@ -5430,7 +5528,7 @@
        struct bfd_symbol *
                    (*_bfd_make_empty_symbol) (bfd *);
        void        (*_bfd_print_symbol)
-         (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+         (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type, struct bfd_symbol *);
      #define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
        void        (*_bfd_get_symbol_info)
          (bfd *, struct bfd_symbol *, symbol_info *);
@@ -7972,6 +8070,85 @@
        bfd_boolean (*_bfd_coff_final_link_postscript)
          (bfd *, struct coff_final_link_info *);
 
+      void (*_bfd_coff_canonicalize_one_symbol) PARAMS((
+            bfd *,
+            combined_entry_type *,
+            coff_symbol_type *));
+     #ifdef DYNAMIC_LINKING
+      void (*_bfd_coff_swap_dyn_in) PARAMS ((
+            bfd *,
+            const PTR,
+            coff_internal_dyn *));
+      void (*_bfd_coff_swap_dyn_out) PARAMS ((
+            bfd *,
+            const coff_internal_dyn *,
+            coff_external_dyn *));
+      void (*_bfd_coff_swap_verdef_in) PARAMS ((
+            bfd *abfd,
+            const coff_external_verdef *src,
+            coff_internal_verdef *dst));
+      void (*_bfd_coff_swap_verdef_out) PARAMS ((
+            bfd *abfd,
+            const coff_internal_verdef *src,
+            coff_external_verdef *dst));
+      void (*_bfd_coff_swap_verdaux_in) PARAMS ((
+            bfd *abfd,
+            const coff_external_verdaux *src,
+            coff_internal_verdaux *dst));
+      void (*_bfd_coff_swap_verdaux_out) PARAMS ((
+            bfd *abfd,
+            const coff_internal_verdaux *src,
+            coff_external_verdaux *dst));
+      void (*_bfd_coff_swap_verneed_in) PARAMS ((
+            bfd *abfd,
+            const coff_external_verneed *src,
+            coff_internal_verneed *dst));
+      void (*_bfd_coff_swap_verneed_out) PARAMS ((
+            bfd *abfd,
+            const coff_internal_verneed *src,
+            coff_external_verneed *dst));
+      void (*_bfd_coff_swap_vernaux_in) PARAMS ((
+            bfd *abfd,
+            const coff_external_vernaux *src,
+            coff_internal_vernaux *dst));
+      void (*_bfd_coff_swap_vernaux_out) PARAMS ((
+            bfd *abfd,
+            const coff_internal_vernaux *src,
+            coff_external_vernaux *dst));
+      void (*_bfd_coff_swap_versym_in) PARAMS ((
+            bfd *abfd,
+            const coff_external_versym *src,
+            coff_internal_versym *dst));
+      void (*_bfd_coff_swap_versym_out) PARAMS ((
+            bfd *abfd,
+            const coff_internal_versym *src,
+            coff_external_versym *dst));
+      bfd_boolean (*_bfd_coff_backend_link_create_dynamic_sections) PARAMS ((
+            bfd *,
+            struct bfd_link_info *));
+      bfd_boolean (*_bfd_coff_backend_check_relocs) PARAMS ((
+            bfd *,
+            struct bfd_link_info *,
+            asection *,
+            const struct internal_reloc *relocs));
+      bfd_boolean (*_bfd_coff_backend_adjust_dynamic_symbol) PARAMS ((
+            bfd *,
+            struct bfd_link_info *,
+            struct coff_link_hash_entry *,
+            bfd_boolean));
+      bfd_boolean (*_bfd_coff_backend_size_dynamic_sections) PARAMS ((
+            bfd *,
+            struct bfd_link_info *));
+      bfd_boolean (*_bfd_coff_backend_finish_dynamic_symbol) PARAMS ((
+            bfd *,
+            struct bfd_link_info *,
+            struct coff_link_hash_entry *,
+            struct internal_syment *));
+      bfd_boolean (*_bfd_coff_backend_finish_dynamic_sections) PARAMS ((
+            bfd *,
+            struct bfd_link_info *));
+     #endif
+
      } bfd_coff_backend_data;
 
      #define coff_backend_info(abfd) \
@@ -8007,6 +8184,50 @@
      #define bfd_coff_swap_aouthdr_out(abfd, i,o) \
        ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
 
+     #ifdef DYNAMIC_LINKING
+     #define bfd_coff_swap_dyn_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_in) (abfd, i, o))
+     #define bfd_coff_swap_dyn_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_out) (abfd, i, o))
+     #define bfd_coff_swap_verdef_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_in) (abfd, i, o))
+     #define bfd_coff_swap_verdef_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_out) (abfd, i, o))
+     #define bfd_coff_swap_verdaux_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_in) (abfd, i, o))
+     #define bfd_coff_swap_verdaux_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_out) (abfd, i, o))
+     #define bfd_coff_swap_verneed_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_in) (abfd, i, o))
+     #define bfd_coff_swap_verneed_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_out) (abfd, i, o))
+     #define bfd_coff_swap_vernaux_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_in) (abfd, i, o))
+     #define bfd_coff_swap_vernaux_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_out) (abfd, i, o))
+     #define bfd_coff_swap_versym_in(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_versym_in) (abfd, i, o))
+     #define bfd_coff_swap_versym_out(abfd, i,o) \
+             ((coff_backend_info (abfd)->_bfd_coff_swap_versym_out) (abfd, i, o))
+     #define bfd_coff_backend_link_create_dynamic_sections(abfd, i) \
+             ((coff_backend_info (abfd)-> \
+                _bfd_coff_backend_link_create_dynamic_sections) (abfd, i))
+     #define bfd_coff_backend_check_relocs(abfd, i, s, r) \
+             ((coff_backend_info (abfd)->_bfd_coff_backend_check_relocs) \
+                (abfd, i, s, r))
+     #define bfd_coff_backend_adjust_dynamic_symbol(abfd, i, h, s) \
+             ((coff_backend_info (abfd)->_bfd_coff_backend_adjust_dynamic_symbol) \
+                (abfd, i, h, s))
+     #define bfd_coff_backend_size_dynamic_sections(abfd, i) \
+             ((coff_backend_info (abfd)->_bfd_coff_backend_size_dynamic_sections) \
+                (abfd, i))
+     #define bfd_coff_backend_finish_dynamic_symbol(abfd, i, h, s) \
+             ((coff_backend_info (abfd)->_bfd_coff_backend_finish_dynamic_symbol) \
+                (abfd, i, h, s))
+     #define bfd_coff_backend_finish_dynamic_sections(abfd, i) \
+             ((coff_backend_info(abfd)->_bfd_coff_backend_finish_dynamic_sections) \
+                (abfd, i))
+     #endif
      #define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
      #define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
      #define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
@@ -8099,6 +8320,10 @@
        ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
         (info, abfd, name, flags, section, value, string, cp, coll, hashp))
 
+     #define bfd_coff_canonicalize_one_symbol(abfd, src, dest) \
+             ((coff_backend_info (abfd)->_bfd_coff_canonicalize_one_symbol)\
+              (abfd, src, dest))
+
      #define bfd_coff_link_output_has_begun(a,p) \
        ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
      #define bfd_coff_final_link_postscript(a,p) \
@@ -8933,6 +9158,7 @@
                                                              (line    6)
 * _bfd_relocate_contents:                Relocating the section contents.
                                                              (line   22)
+* _bfd_strip_section_from_output:        section prototypes. (line  273)
 * aout_SIZE_machine_type:                aout.               (line  147)
 * aout_SIZE_mkobject:                    aout.               (line  139)
 * aout_SIZE_new_section_hook:            aout.               (line  177)
@@ -8947,12 +9173,13 @@
                                                              (line  203)
 * bfd_alloc2:                            Opening and Closing.
                                                              (line  212)
-* bfd_alt_mach_code:                     BFD front end.      (line  599)
+* bfd_alt_mach_code:                     BFD front end.      (line  619)
 * bfd_arch_bits_per_address:             Architectures.      (line  476)
 * bfd_arch_bits_per_byte:                Architectures.      (line  468)
 * bfd_arch_get_compatible:               Architectures.      (line  411)
 * bfd_arch_list:                         Architectures.      (line  402)
 * bfd_arch_mach_octets_per_byte:         Architectures.      (line  545)
+* bfd_archive_filename:                  BFD front end.      (line  309)
 * BFD_ARELOC_BFIN_ADD:                   howto manager.      (line  887)
 * BFD_ARELOC_BFIN_ADDR:                  howto manager.      (line  938)
 * BFD_ARELOC_BFIN_AND:                   howto manager.      (line  908)
@@ -8978,7 +9205,7 @@
 * bfd_cache_init:                        File Caching.       (line   18)
 * bfd_calc_gnu_debuglink_crc32:          Opening and Closing.
                                                              (line  239)
-* bfd_canonicalize_reloc:                BFD front end.      (line  318)
+* bfd_canonicalize_reloc:                BFD front end.      (line  335)
 * bfd_canonicalize_symtab:               symbol handling functions.
                                                              (line   50)
 * bfd_check_format:                      Formats.            (line   21)
@@ -8989,8 +9216,8 @@
 * bfd_close_all_done:                    Opening and Closing.
                                                              (line  146)
 * bfd_coff_backend_data:                 coff.               (line  246)
-* bfd_copy_private_bfd_data:             BFD front end.      (line  457)
-* bfd_copy_private_header_data:          BFD front end.      (line  439)
+* bfd_copy_private_bfd_data:             BFD front end.      (line  474)
+* bfd_copy_private_header_data:          BFD front end.      (line  456)
 * bfd_copy_private_section_data:         section prototypes. (line  255)
 * bfd_copy_private_symbol_data:          symbol handling functions.
                                                              (line  140)
@@ -9008,41 +9235,41 @@
 * bfd_default_scan:                      Architectures.      (line  494)
 * bfd_default_set_arch_mach:             Architectures.      (line  441)
 * bfd_elf_find_section:                  elf.                (line   13)
-* bfd_errmsg:                            BFD front end.      (line  243)
+* bfd_errmsg:                            BFD front end.      (line  250)
 * bfd_fdopenr:                           Opening and Closing.
                                                              (line   46)
 * bfd_fill_in_gnu_debuglink_section:     Opening and Closing.
                                                              (line  319)
-* bfd_find_target:                       bfd_target.         (line  434)
+* bfd_find_target:                       bfd_target.         (line  440)
 * bfd_follow_gnu_debuglink:              Opening and Closing.
                                                              (line  284)
 * bfd_fopen:                             Opening and Closing.
                                                              (line    9)
 * bfd_format_string:                     Formats.            (line   79)
-* bfd_generic_discard_group:             section prototypes. (line  281)
+* bfd_generic_discard_group:             section prototypes. (line  295)
 * bfd_generic_gc_sections:               howto manager.      (line 1962)
 * bfd_generic_get_relocated_section_contents: howto manager. (line 1982)
-* bfd_generic_is_group_section:          section prototypes. (line  273)
+* bfd_generic_is_group_section:          section prototypes. (line  287)
 * bfd_generic_merge_sections:            howto manager.      (line 1972)
 * bfd_generic_relax_section:             howto manager.      (line 1949)
 * bfd_get_arch:                          Architectures.      (line  452)
 * bfd_get_arch_info:                     Architectures.      (line  504)
-* bfd_get_arch_size:                     BFD front end.      (line  362)
-* bfd_get_error:                         BFD front end.      (line  226)
-* bfd_get_error_handler:                 BFD front end.      (line  294)
-* bfd_get_gp_size:                       BFD front end.      (line  403)
+* bfd_get_arch_size:                     BFD front end.      (line  379)
+* bfd_get_error:                         BFD front end.      (line  233)
+* bfd_get_error_handler:                 BFD front end.      (line  301)
+* bfd_get_gp_size:                       BFD front end.      (line  420)
 * bfd_get_mach:                          Architectures.      (line  460)
-* bfd_get_mtime:                         BFD front end.      (line  687)
+* bfd_get_mtime:                         BFD front end.      (line  707)
 * bfd_get_next_mapent:                   Archives.           (line   52)
 * bfd_get_reloc_code_name:               howto manager.      (line 1940)
 * bfd_get_reloc_size:                    typedef arelent.    (line  330)
-* bfd_get_reloc_upper_bound:             BFD front end.      (line  308)
+* bfd_get_reloc_upper_bound:             BFD front end.      (line  325)
 * bfd_get_section_by_name:               section prototypes. (line   17)
 * bfd_get_section_by_name_if:            section prototypes. (line   31)
 * bfd_get_section_contents:              section prototypes. (line  228)
-* bfd_get_sign_extend_vma:               BFD front end.      (line  375)
+* bfd_get_sign_extend_vma:               BFD front end.      (line  392)
 * bfd_get_size <1>:                      Internal.           (line   25)
-* bfd_get_size:                          BFD front end.      (line  696)
+* bfd_get_size:                          BFD front end.      (line  716)
 * bfd_get_symtab_upper_bound:            symbol handling functions.
                                                              (line    6)
 * bfd_get_unique_section_name:           section prototypes. (line   50)
@@ -9092,7 +9319,7 @@
                                                              (line  175)
 * bfd_malloc_and_get_section:            section prototypes. (line  245)
 * bfd_map_over_sections:                 section prototypes. (line  155)
-* bfd_merge_private_bfd_data:            BFD front end.      (line  473)
+* bfd_merge_private_bfd_data:            BFD front end.      (line  490)
 * bfd_octets_per_byte:                   Architectures.      (line  535)
 * bfd_open_file:                         File Caching.       (line   52)
 * bfd_openr:                             Opening and Closing.
@@ -9105,10 +9332,10 @@
 * bfd_openw:                             Opening and Closing.
                                                              (line  116)
 * bfd_perform_relocation:                typedef arelent.    (line  367)
-* bfd_perror:                            BFD front end.      (line  252)
-* bfd_preserve_finish:                   BFD front end.      (line  647)
-* bfd_preserve_restore:                  BFD front end.      (line  637)
-* bfd_preserve_save:                     BFD front end.      (line  621)
+* bfd_perror:                            BFD front end.      (line  259)
+* bfd_preserve_finish:                   BFD front end.      (line  667)
+* bfd_preserve_restore:                  BFD front end.      (line  657)
+* bfd_preserve_save:                     BFD front end.      (line  641)
 * bfd_print_symbol_vandf:                symbol handling functions.
                                                              (line   70)
 * bfd_printable_arch_mach:               Architectures.      (line  523)
@@ -10182,32 +10409,32 @@
 * BFD_RELOC_Z8K_DISP7:                   howto manager.      (line 1910)
 * BFD_RELOC_Z8K_IMM4L:                   howto manager.      (line 1916)
 * bfd_scan_arch:                         Architectures.      (line  392)
-* bfd_scan_vma:                          BFD front end.      (line  423)
-* bfd_seach_for_target:                  bfd_target.         (line  459)
+* bfd_scan_vma:                          BFD front end.      (line  440)
+* bfd_seach_for_target:                  bfd_target.         (line  465)
 * bfd_section_already_linked:            Writing the symbol table.
                                                              (line   55)
 * bfd_section_list_clear:                section prototypes. (line    8)
 * bfd_sections_find_if:                  section prototypes. (line  176)
 * bfd_set_arch_info:                     Architectures.      (line  433)
 * bfd_set_archive_head:                  Archives.           (line   69)
-* bfd_set_default_target:                bfd_target.         (line  424)
-* bfd_set_error:                         BFD front end.      (line  235)
-* bfd_set_error_handler:                 BFD front end.      (line  275)
-* bfd_set_error_program_name:            BFD front end.      (line  284)
-* bfd_set_file_flags:                    BFD front end.      (line  343)
+* bfd_set_default_target:                bfd_target.         (line  430)
+* bfd_set_error:                         BFD front end.      (line  242)
+* bfd_set_error_handler:                 BFD front end.      (line  282)
+* bfd_set_error_program_name:            BFD front end.      (line  291)
+* bfd_set_file_flags:                    BFD front end.      (line  360)
 * bfd_set_format:                        Formats.            (line   68)
-* bfd_set_gp_size:                       BFD front end.      (line  413)
-* bfd_set_private_flags:                 BFD front end.      (line  490)
-* bfd_set_reloc:                         BFD front end.      (line  333)
+* bfd_set_gp_size:                       BFD front end.      (line  430)
+* bfd_set_private_flags:                 BFD front end.      (line  507)
+* bfd_set_reloc:                         BFD front end.      (line  350)
 * bfd_set_section_contents:              section prototypes. (line  207)
 * bfd_set_section_flags:                 section prototypes. (line  140)
 * bfd_set_section_size:                  section prototypes. (line  193)
-* bfd_set_start_address:                 BFD front end.      (line  392)
+* bfd_set_start_address:                 BFD front end.      (line  409)
 * bfd_set_symtab:                        symbol handling functions.
                                                              (line   60)
 * bfd_symbol_info:                       symbol handling functions.
                                                              (line  130)
-* bfd_target_list:                       bfd_target.         (line  450)
+* bfd_target_list:                       bfd_target.         (line  456)
 * bfd_write_bigendian_4byte_int:         Internal.           (line   13)
 * bfd_zalloc:                            Opening and Closing.
                                                              (line  221)
@@ -10223,10 +10450,10 @@
 * Hash tables:                           Hash Tables.        (line    6)
 * internal object-file format:           Canonical format.   (line   11)
 * Linker:                                Linker Functions.   (line    6)
-* Other functions:                       BFD front end.      (line  505)
+* Other functions:                       BFD front end.      (line  522)
 * separate_debug_file_exists:            Opening and Closing.
                                                              (line  263)
-* struct bfd_iovec:                      BFD front end.      (line  657)
+* struct bfd_iovec:                      BFD front end.      (line  677)
 * target vector (_bfd_final_link):       Performing the Final Link.
                                                              (line    6)
 * target vector (_bfd_link_add_symbols): Adding Symbols to the Hash Table.
@@ -10239,67 +10466,67 @@
 
 
 Tag Table:
-Node: Top724
-Node: Overview1056
-Node: History2107
-Node: How It Works3053
-Node: What BFD Version 2 Can Do4595
-Node: BFD information loss5910
-Node: Canonical format8442
-Node: BFD front end12814
-Node: Memory Usage38428
-Node: Initialization39656
-Node: Sections40115
-Node: Section Input40598
-Node: Section Output41963
-Node: typedef asection44449
-Node: section prototypes69406
-Node: Symbols79086
-Node: Reading Symbols80681
-Node: Writing Symbols81788
-Node: Mini Symbols83497
-Node: typedef asymbol84471
-Node: symbol handling functions89389
-Node: Archives94731
-Node: Formats98457
-Node: Relocations101405
-Node: typedef arelent102132
-Node: howto manager117943
-Node: Core Files180223
-Node: Targets182040
-Node: bfd_target184010
-Node: Architectures204090
-Node: Opening and Closing225522
-Node: Internal236524
-Node: File Caching242857
-Node: Linker Functions244771
-Node: Creating a Linker Hash Table246444
-Node: Adding Symbols to the Hash Table248182
-Node: Differing file formats249082
-Node: Adding symbols from an object file250830
-Node: Adding symbols from an archive252981
-Node: Performing the Final Link255395
-Node: Information provided by the linker256637
-Node: Relocating the section contents257791
-Node: Writing the symbol table259542
-Node: Hash Tables262535
-Node: Creating and Freeing a Hash Table263733
-Node: Looking Up or Entering a String264983
-Node: Traversing a Hash Table266236
-Node: Deriving a New Hash Table Type267025
-Node: Define the Derived Structures268091
-Node: Write the Derived Creation Routine269172
-Node: Write Other Derived Routines271796
-Node: BFD back ends273111
-Node: What to Put Where273381
-Node: aout273519
-Node: coff279837
-Node: elf304314
-Node: mmo305177
-Node: File layout306105
-Node: Symbol-table311752
-Node: mmo section mapping315521
-Node: GNU Free Documentation License319173
-Node: Index338898
+Node: Top780
+Node: Overview1112
+Node: History2163
+Node: How It Works3109
+Node: What BFD Version 2 Can Do4651
+Node: BFD information loss5966
+Node: Canonical format8498
+Node: BFD front end12870
+Node: Memory Usage39235
+Node: Initialization40463
+Node: Sections40922
+Node: Section Input41405
+Node: Section Output42770
+Node: typedef asection45256
+Node: section prototypes72086
+Node: Symbols82227
+Node: Reading Symbols83822
+Node: Writing Symbols84929
+Node: Mini Symbols86638
+Node: typedef asymbol87612
+Node: symbol handling functions92530
+Node: Archives97872
+Node: Formats101598
+Node: Relocations104546
+Node: typedef arelent105273
+Node: howto manager121084
+Node: Core Files183364
+Node: Targets185181
+Node: bfd_target187151
+Node: Architectures207544
+Node: Opening and Closing228976
+Node: Internal239978
+Node: File Caching246311
+Node: Linker Functions248225
+Node: Creating a Linker Hash Table249898
+Node: Adding Symbols to the Hash Table251636
+Node: Differing file formats252536
+Node: Adding symbols from an object file254284
+Node: Adding symbols from an archive256435
+Node: Performing the Final Link258849
+Node: Information provided by the linker260091
+Node: Relocating the section contents261245
+Node: Writing the symbol table262996
+Node: Hash Tables265989
+Node: Creating and Freeing a Hash Table267187
+Node: Looking Up or Entering a String268437
+Node: Traversing a Hash Table269690
+Node: Deriving a New Hash Table Type270479
+Node: Define the Derived Structures271545
+Node: Write the Derived Creation Routine272626
+Node: Write Other Derived Routines275250
+Node: BFD back ends276565
+Node: What to Put Where276835
+Node: aout276973
+Node: coff283291
+Node: elf313690
+Node: mmo314553
+Node: File layout315481
+Node: Symbol-table321128
+Node: mmo section mapping324897
+Node: GNU Free Documentation License328549
+Node: Index348274
 
 End Tag Table
diff -ruNbB binutils-2.17/bfd/doc/bfdt.texi binutils-2.17.sua/bfd/doc/bfdt.texi
--- binutils-2.17/bfd/doc/bfdt.texi	2006-04-16 20:36:40 +0200
+++ binutils-2.17.sua/bfd/doc/bfdt.texi	2008-04-01 09:03:08 +0200
@@ -126,6 +126,13 @@
      be used only for archive elements.  */
   int archive_pass;
 
+/* #ifdef DYNAMIC_LINKING */
+    /* Used by some backends for dynamic link private data; independent
+       of per-format private data. */
+    struct dynamic_info *dynamic_info;  /* used by shared libs only */
+    bfd_vma *local_got_offsets; /* used if dynamic linking on all bfds */
+/* #endif */
+
   /* Used by the back end to hold private data.  */
   union
     @{
@@ -306,6 +313,17 @@
 @strong{Description}@*
 Return the BFD error handler function.
 
+@findex bfd_archive_filename
+@subsubsection @code{bfd_archive_filename}
+@strong{Synopsis}
+@example
+const char *bfd_archive_filename (bfd *);
+@end example
+@strong{Description}@*
+For a BFD that is a component of an archive, returns a string
+with both the archive name and file name.  For other BFDs, just
+returns the file name.
+
 @section Miscellaneous
 
 
@@ -650,6 +668,9 @@
   (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
    bfd_boolean, asymbol **);
 
+/* In case we're exec()-ing, we need to clean up JUST the fd */
+#define bfd_fileno(abfd) fileno((FILE *)((abfd)->iostream))
+
 @end example
 
 @findex bfd_alt_mach_code
diff -ruNbB binutils-2.17/bfd/doc/coffcode.texi binutils-2.17.sua/bfd/doc/coffcode.texi
--- binutils-2.17/bfd/doc/coffcode.texi	2006-04-16 20:36:40 +0200
+++ binutils-2.17.sua/bfd/doc/coffcode.texi	2008-04-01 09:03:08 +0200
@@ -413,6 +413,85 @@
   bfd_boolean (*_bfd_coff_final_link_postscript)
     (bfd *, struct coff_final_link_info *);
 
+ void (*_bfd_coff_canonicalize_one_symbol) PARAMS((
+       bfd *,
+       combined_entry_type *,
+       coff_symbol_type *));
+#ifdef DYNAMIC_LINKING
+ void (*_bfd_coff_swap_dyn_in) PARAMS ((
+       bfd *, 
+       const PTR, 
+       coff_internal_dyn *));
+ void (*_bfd_coff_swap_dyn_out) PARAMS ((
+       bfd *, 
+       const coff_internal_dyn *, 
+       coff_external_dyn *));
+ void (*_bfd_coff_swap_verdef_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verdef *src,
+       coff_internal_verdef *dst));
+ void (*_bfd_coff_swap_verdef_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verdef *src,
+       coff_external_verdef *dst));
+ void (*_bfd_coff_swap_verdaux_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verdaux *src,
+       coff_internal_verdaux *dst));
+ void (*_bfd_coff_swap_verdaux_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verdaux *src,
+       coff_external_verdaux *dst));
+ void (*_bfd_coff_swap_verneed_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verneed *src,
+       coff_internal_verneed *dst));
+ void (*_bfd_coff_swap_verneed_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verneed *src,
+       coff_external_verneed *dst));
+ void (*_bfd_coff_swap_vernaux_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_vernaux *src,
+       coff_internal_vernaux *dst));
+ void (*_bfd_coff_swap_vernaux_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_vernaux *src,
+       coff_external_vernaux *dst));
+ void (*_bfd_coff_swap_versym_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_versym *src,
+       coff_internal_versym *dst));
+ void (*_bfd_coff_swap_versym_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_versym *src,
+       coff_external_versym *dst));
+ bfd_boolean (*_bfd_coff_backend_link_create_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+ bfd_boolean (*_bfd_coff_backend_check_relocs) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       asection *,
+       const struct internal_reloc *relocs));
+ bfd_boolean (*_bfd_coff_backend_adjust_dynamic_symbol) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       struct coff_link_hash_entry *,
+       bfd_boolean));
+ bfd_boolean (*_bfd_coff_backend_size_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+ bfd_boolean (*_bfd_coff_backend_finish_dynamic_symbol) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       struct coff_link_hash_entry *,
+       struct internal_syment *));
+ bfd_boolean (*_bfd_coff_backend_finish_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+#endif
+
 @} bfd_coff_backend_data;
 
 #define coff_backend_info(abfd) \
@@ -448,6 +527,50 @@
 #define bfd_coff_swap_aouthdr_out(abfd, i,o) \
   ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
 
+#ifdef DYNAMIC_LINKING
+#define bfd_coff_swap_dyn_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_in) (abfd, i, o))
+#define bfd_coff_swap_dyn_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_out) (abfd, i, o))
+#define bfd_coff_swap_verdef_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_in) (abfd, i, o))
+#define bfd_coff_swap_verdef_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_out) (abfd, i, o))
+#define bfd_coff_swap_verdaux_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_in) (abfd, i, o))
+#define bfd_coff_swap_verdaux_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_out) (abfd, i, o))
+#define bfd_coff_swap_verneed_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_in) (abfd, i, o))
+#define bfd_coff_swap_verneed_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_out) (abfd, i, o))
+#define bfd_coff_swap_vernaux_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_in) (abfd, i, o))
+#define bfd_coff_swap_vernaux_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_out) (abfd, i, o))
+#define bfd_coff_swap_versym_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_in) (abfd, i, o))
+#define bfd_coff_swap_versym_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_out) (abfd, i, o))
+#define bfd_coff_backend_link_create_dynamic_sections(abfd, i) \
+        ((coff_backend_info (abfd)-> \
+           _bfd_coff_backend_link_create_dynamic_sections) (abfd, i))
+#define bfd_coff_backend_check_relocs(abfd, i, s, r) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_check_relocs) \
+           (abfd, i, s, r))
+#define bfd_coff_backend_adjust_dynamic_symbol(abfd, i, h, s) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_adjust_dynamic_symbol) \
+           (abfd, i, h, s))
+#define bfd_coff_backend_size_dynamic_sections(abfd, i) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_size_dynamic_sections) \
+           (abfd, i))
+#define bfd_coff_backend_finish_dynamic_symbol(abfd, i, h, s) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_finish_dynamic_symbol) \
+           (abfd, i, h, s))
+#define bfd_coff_backend_finish_dynamic_sections(abfd, i) \
+        ((coff_backend_info(abfd)->_bfd_coff_backend_finish_dynamic_sections) \
+           (abfd, i))
+#endif
 #define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
 #define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
 #define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
@@ -540,6 +663,10 @@
   ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
    (info, abfd, name, flags, section, value, string, cp, coll, hashp))
 
+#define bfd_coff_canonicalize_one_symbol(abfd, src, dest) \
+        ((coff_backend_info (abfd)->_bfd_coff_canonicalize_one_symbol)\
+         (abfd, src, dest))
+
 #define bfd_coff_link_output_has_begun(a,p) \
   ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
 #define bfd_coff_final_link_postscript(a,p) \
diff -ruNbB binutils-2.17/bfd/doc/section.texi binutils-2.17.sua/bfd/doc/section.texi
--- binutils-2.17/bfd/doc/section.texi	2006-04-16 20:36:40 +0200
+++ binutils-2.17.sua/bfd/doc/section.texi	2008-04-01 09:03:08 +0200
@@ -107,6 +107,44 @@
 
 @example
 
+
+/* This enum exists so that transition to an abstraction can start;
+   use with bfd_@{get_,set_,@}section_value_flag. */
+enum section_sec_flags @{
+       sec_flag_ALLOC,
+       sec_flag_LOAD,
+       sec_flag_RELOC,
+       sec_flag_ARCH_BIT_0,
+       sec_flag_READONLY,
+       sec_flag_CODE,
+       sec_flag_DATA,
+       sec_flag_ROM,
+       sec_flag_CONSTRUCTOR,
+       sec_flag_HAS_CONTENTS,
+       sec_flag_NEVER_LOAD,
+       sec_flag_COFF_SHARED_LIBRARY,
+       sec_flag_reserved1, sec_flag_reserved2, /* for constructor types */
+       sec_flag_HAS_GOT_REF,
+       sec_flag_IS_COMMON,
+       sec_flag_DEBUGGING,
+       sec_flag_IN_MEMORY,
+       sec_flag_EXCLUDE,
+       sec_flag_SORT_ENTRIES,
+       sec_flag_LINK_ONCE,
+       sec_flag_reserved3,sec_flag_reserved4, /* for comdat types */
+       sec_flag_LINKER_CREATED,
+       sec_flag_KEEP,
+       sec_flag_SMALL_DATA,
+       sec_flag_SHARED,
+       sec_flag_BLOCK,
+       sec_flag_CLINK,
+       sec_flag_MERGE,
+       sec_flag_STRINGS,
+       sec_flag_GROUP,
+       sec_flag_NOREAD,
+      sec_flag_last  /* The traditional "last" value */
+@};
+
 typedef struct bfd_section
 @{
   /* The name of the section; the name isn't a copy, the pointer is
@@ -129,6 +167,8 @@
      flags are read in from the object file, and some are
      synthesized from other information.  */
   flagword flags;
+  flagword more_flags[1];
+
 
 #define SEC_NO_FLAGS   0x000
 
@@ -416,6 +456,23 @@
   /* File position of line data.  */
   file_ptr line_filepos;
 
+/* #ifdef DYNAMIC_LINKING */
+  /* Certain sections need counts, which we overload into the
+     coff number of relocs and/or number of line numbers fields,
+     but carrying those in the same fields here is asking for 
+     trouble, so the overloaded ones live here. */
+
+  unsigned int info_r;
+  unsigned int info_l;
+
+  /* There are multiple string tables possible when dynamically
+     linking; this is the section number for the string table
+     for this section */
+
+  int link_index;
+
+/* #endif */
+
   /* Pointer to data for applications.  */
   void *userdata;
 
@@ -969,6 +1026,21 @@
                (ibfd, isection, obfd, osection))
 @end example
 
+@findex _bfd_strip_section_from_output
+@subsubsection @code{_bfd_strip_section_from_output}
+@strong{Synopsis}
+@example
+void _bfd_strip_section_from_output
+   (struct bfd_link_info *info, asection *section);
+@end example
+@strong{Description}@*
+Remove @var{section} from the output.  If the output section
+becomes empty, remove it from the output bfd.
+
+This function won't actually do anything except twiddle flags
+if called too late in the linking process, when it's not safe
+to remove sections.
+
 @findex bfd_generic_is_group_section
 @subsubsection @code{bfd_generic_is_group_section}
 @strong{Synopsis}
diff -ruNbB binutils-2.17/bfd/doc/targets.texi binutils-2.17.sua/bfd/doc/targets.texi
--- binutils-2.17/bfd/doc/targets.texi	2006-04-16 20:36:40 +0200
+++ binutils-2.17.sua/bfd/doc/targets.texi	2008-04-01 09:03:08 +0200
@@ -153,6 +153,12 @@
     the contents of a file.  */
   enum bfd_flavour flavour;
 
+ /* Input format: if the file format for input to the linker is not the same
+    as the output format, then a pointer to the input format type goes here
+    in the output format's record.  (This happens for PE/PEI, at least.) */
+
+  const struct bfd_target *input_format;
+
   /* The order of bytes within the data area of a file.  */
   enum bfd_endian byteorder;
 
@@ -339,7 +345,7 @@
   struct bfd_symbol *
               (*_bfd_make_empty_symbol) (bfd *);
   void        (*_bfd_print_symbol)
-    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type, struct bfd_symbol *);
 #define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
   void        (*_bfd_get_symbol_info)
     (bfd *, struct bfd_symbol *, symbol_info *);
diff -ruNbB binutils-2.17/bfd/dwarf2.c binutils-2.17.sua/bfd/dwarf2.c
--- binutils-2.17/bfd/dwarf2.c	2006-03-11 16:01:18 +0100
+++ binutils-2.17.sua/bfd/dwarf2.c	2008-04-01 09:03:08 +0200
@@ -372,7 +372,7 @@
 	case 2:
 	  return bfd_get_signed_16 (unit->abfd, buf);
 	default:
-	  abort ();
+	  abort (); return 0;
 	}
     }
   else
@@ -386,7 +386,7 @@
 	case 2:
 	  return bfd_get_16 (unit->abfd, buf);
 	default:
-	  abort ();
+	  abort (); return 0;
 	}
     }
 }
@@ -783,6 +783,12 @@
   bfd_size_type amt = sizeof (struct line_info);
   struct line_info* info = bfd_alloc (table->abfd, amt);
 
+#if 0
+  /*
+   * REMOVE
+   * mayank@15th June, 2007
+   */
+
   /* Set member data of 'info'.  */
   info->address = address;
   info->line = line;
@@ -797,6 +803,7 @@
     }
   else
     info->filename = NULL;
+#endif
 
   /* Find the correct location for 'info'.  Normally we will receive
      new line_info data 1) in order and 2) with increasing VMAs.
@@ -813,8 +820,9 @@
 
      Note: we may receive duplicate entries from 'decode_line_info'.  */
 
+  while (1)
   if (!table->last_line
-      || new_line_sorts_after (info, table->last_line))
+	|| address >= table->last_line->address)
     {
       /* Normal case: add 'info' to the beginning of the list */
       info->prev_line = table->last_line;
@@ -823,35 +831,60 @@
       /* lcl_head: initialize to head a *possible* sequence at the end.  */
       if (!table->lcl_head)
 	table->lcl_head = info;
+	break;
+      }
+    else if (!table->lcl_head->prev_line
+	     && table->lcl_head->address > address)
+      {
+	/* Abnormal but easy: lcl_head is 1) at the *end* of the line
+	   list and 2) the head of 'info'.  */
+	info->prev_line = NULL;
+	table->lcl_head->prev_line = info;
+	break;
     }
-  else if (!new_line_sorts_after (info, table->lcl_head)
-	   && (!table->lcl_head->prev_line
-	       || new_line_sorts_after (info, table->lcl_head->prev_line)))
+    else if (table->lcl_head->prev_line
+	     && table->lcl_head->address > address
+	     && address >= table->lcl_head->prev_line->address)
     {
-      /* Abnormal but easy: lcl_head is the head of 'info'.  */
+	/* Abnormal but easy: lcl_head is 1) in the *middle* of the line
+	   list and 2) the head of 'info'.  */
       info->prev_line = table->lcl_head->prev_line;
       table->lcl_head->prev_line = info;
+	break;
     }
   else
     {
       /* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid
-	 heads for 'info'.  Reset 'lcl_head'.  */
+	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
       struct line_info* li2 = table->last_line; /* always non-NULL */
       struct line_info* li1 = li2->prev_line;
 
       while (li1)
 	{
-	  if (!new_line_sorts_after (info, li2)
-	      && new_line_sorts_after (info, li1))
+	    if (li2->address > address && address >= li1->address)
 	    break;
 
 	  li2 = li1; /* always non-NULL */
 	  li1 = li1->prev_line;
 	}
       table->lcl_head = li2;
-      info->prev_line = table->lcl_head->prev_line;
-      table->lcl_head->prev_line = info;
     }
+
+  /* Set member data of 'info'.  */
+  info->address = address;
+  info->line = line;
+  info->column = column;
+  info->end_sequence = end_sequence;
+
+  if (filename && filename[0])
+    {
+      info->filename = bfd_alloc (table->abfd, strlen (filename) + 1);
+      if (info->filename)
+	strcpy (info->filename, filename);
+    }
+  else
+    info->filename = NULL;
+
 }
 
 /* Extract a fully qualified filename from a line info table.
@@ -1124,7 +1158,7 @@
 	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
 	 for ia64-Linux).  Thus, to determine the low and high
 	 address, we must compare on every DW_LNS_copy, etc.  */
-      bfd_vma low_pc  = (bfd_vma) -1;
+      bfd_vma low_pc  = 0;
       bfd_vma high_pc = 0;
 
       /* Decode the table.  */
@@ -1143,7 +1177,7 @@
 	      /* Append row to matrix using current values.  */
 	      add_line_info (table, address, filename, line, column, 0);
 	      basic_block = 1;
-	      if (address < low_pc)
+	      if (low_pc == 0 || address < low_pc)
 		low_pc = address;
 	      if (address > high_pc)
 		high_pc = address;
@@ -1162,7 +1196,7 @@
 		  end_sequence = 1;
 		  add_line_info (table, address, filename, line, column,
 				 end_sequence);
-		  if (address < low_pc)
+		  if (low_pc == 0 || address < low_pc)
 		    low_pc = address;
 		  if (address > high_pc)
 		    high_pc = address;
diff -ruNbB binutils-2.17/bfd/ecoff.c binutils-2.17.sua/bfd/ecoff.c
--- binutils-2.17/bfd/ecoff.c	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/ecoff.c	2008-04-01 09:03:08 +0200
@@ -1362,7 +1362,8 @@
 _bfd_ecoff_print_symbol (bfd *abfd,
 			 void * filep,
 			 asymbol *symbol,
-			 bfd_print_symbol_type how)
+			 bfd_print_symbol_type how,
+			 asymbol *ignored ATTRIBUTE_UNUSED)
 {
   const struct ecoff_debug_swap * const debug_swap
     = &ecoff_backend (abfd)->debug_swap;
@@ -1989,7 +1990,12 @@
 	 really in the section.  Each entry is 8 bytes.  We store this
 	 away in line_filepos before increasing the section size.  */
       if (streq (current->name, _PDATA))
-	current->line_filepos = current->size / 8;
+	      /*
+	       * FIXME
+	       * mayank@15th June, 2007
+	       * This should be size rather than rawsize
+	       */
+	current->line_filepos = current->rawsize / 8;
 
       alignment_power = current->alignment_power;
 
@@ -2049,17 +2055,26 @@
 
       if ((current->flags & (SEC_HAS_CONTENTS | SEC_LOAD)) != 0)
 	current->filepos = file_sofar;
-
-      sofar += current->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      sofar += current->rawsize;
       if ((current->flags & SEC_HAS_CONTENTS) != 0)
-	file_sofar += current->size;
+	file_sofar += current->rawsize;
 
       /* Make sure that this section is of the right size too.  */
       old_sofar = sofar;
       sofar = BFD_ALIGN (sofar, 1 << alignment_power);
       if ((current->flags & SEC_HAS_CONTENTS) != 0)
 	file_sofar = BFD_ALIGN (file_sofar, 1 << alignment_power);
-      current->size += sofar - old_sofar;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      current->rawsize += sofar - old_sofar;
     }
 
   free (sorted_hdrs);
diff -ruNbB binutils-2.17/bfd/elf-bfd.h binutils-2.17.sua/bfd/elf-bfd.h
--- binutils-2.17/bfd/elf-bfd.h	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/elf-bfd.h	2008-04-01 09:03:08 +0200
@@ -1436,7 +1436,7 @@
 extern bfd_boolean _bfd_elf_print_private_bfd_data
   (bfd *, void *);
 extern void bfd_elf_print_symbol
-  (bfd *, void *, asymbol *, bfd_print_symbol_type);
+  (bfd *, void *, asymbol *, bfd_print_symbol_type,asymbol *);
 
 extern void _bfd_elf_sprintf_vma
   (bfd *, char *, bfd_vma);
diff -ruNbB binutils-2.17/bfd/elf.c binutils-2.17.sua/bfd/elf.c
--- binutils-2.17/bfd/elf.c	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/elf.c	2008-04-01 09:03:08 +0200
@@ -1161,7 +1161,12 @@
       swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;
 
       extdyn = dynbuf;
-      extdynend = extdyn + s->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      extdynend = extdyn + s->rawsize;
       for (; extdyn < extdynend; extdyn += extdynsize)
 	{
 	  Elf_Internal_Dyn dyn;
@@ -1325,7 +1330,8 @@
 bfd_elf_print_symbol (bfd *abfd,
 		      void *filep,
 		      asymbol *symbol,
-		      bfd_print_symbol_type how)
+		      bfd_print_symbol_type how,
+		      asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = filep;
   switch (how)
@@ -1708,7 +1714,12 @@
     return TRUE;
 
   s = bfd_get_section_by_name (abfd, ".dynamic");
-  if (s == NULL || s->size == 0)
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  if (s == NULL || s->rawsize == 0)
     return TRUE;
 
   if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
@@ -1724,7 +1735,12 @@
   swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;
 
   extdyn = dynbuf;
-  extdynend = extdyn + s->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  extdynend = extdyn + s->rawsize;
   for (; extdyn < extdynend; extdyn += extdynsize)
     {
       Elf_Internal_Dyn dyn;
@@ -2516,8 +2532,13 @@
   if (newsect == NULL)
     return FALSE;
   newsect->vma = hdr->p_vaddr;
-  newsect->lma = hdr->p_paddr;
-  newsect->size = hdr->p_filesz;
+  newsect->lma = hdr->p_padd;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  newsect->rawsize = hdr->p_filesz;
   newsect->filepos = hdr->p_offset;
   newsect->flags |= SEC_HAS_CONTENTS;
   newsect->alignment_power = bfd_log2 (hdr->p_align);
@@ -2550,7 +2571,12 @@
 	return FALSE;
       newsect->vma = hdr->p_vaddr + hdr->p_filesz;
       newsect->lma = hdr->p_paddr + hdr->p_filesz;
-      newsect->size = hdr->p_memsz - hdr->p_filesz;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      newsect->rawsize = hdr->p_memsz - hdr->p_filesz;
       if (hdr->p_type == PT_LOAD)
 	{
 	  newsect->flags |= SEC_ALLOC;
@@ -2684,7 +2710,12 @@
     this_hdr->sh_addr = 0;
 
   this_hdr->sh_offset = 0;
-  this_hdr->sh_size = asect->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  this_hdr->sh_size = asect->rawsize;
   this_hdr->sh_link = 0;
   this_hdr->sh_addralign = 1 << asect->alignment_power;
   /* The sh_entsize and sh_info fields may have been set already by
@@ -2794,7 +2825,12 @@
   if ((asect->flags & SEC_THREAD_LOCAL) != 0)
     {
       this_hdr->sh_flags |= SHF_TLS;
-      if (asect->size == 0
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      if (asect->rawsize == 0
 	  && (asect->flags & SEC_HAS_CONTENTS) == 0)
 	{
 	  struct bfd_link_order *o = asect->map_tail.link_order;
@@ -2863,7 +2899,12 @@
   if (sec->contents == NULL)
     {
       gas = FALSE;
-      sec->contents = bfd_alloc (abfd, sec->size);
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+      sec->contents = bfd_alloc (abfd, sec->rawsize);
 
       /* Arrange for the section to be written out.  */
       elf_section_data (sec)->this_hdr.contents = sec->contents;
@@ -2873,8 +2914,12 @@
 	  return;
 	}
     }
-
-  loc = sec->contents + sec->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  loc = sec->contents + sec->rawsize;
 
   /* Get the pointer to the first section in the group that gas
      squirreled away here.  objcopy arranges for this to be set to the
@@ -3991,9 +4036,13 @@
 
   /* Sort by size, to put zero sized sections
      before others at the same address.  */
-
-  size1 = (sec1->flags & SEC_LOAD) ? sec1->size : 0;
-  size2 = (sec2->flags & SEC_LOAD) ? sec2->size : 0;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+  size1 = (sec1->flags & SEC_LOAD) ? sec1->rawsize : 0;
+  size2 = (sec2->flags & SEC_LOAD) ? sec2->rawsize : 0;
 
   if (size1 < size2)
     return -1;
@@ -4420,8 +4469,13 @@
 	      if (i == 0)
 		{
 		  sec->filepos = off;
-		  off += sec->size;
-		  p->p_filesz = sec->size;
+		/*
+	 	 * FIXME
+	 	 * mayank@15th June, 2007
+	 	 * This should be size rather than rawsize
+	 	 */
+		  off += sec->rawsize;
+		  p->p_filesz = sec->rawsize;
 		  p->p_memsz = 0;
 		  p->p_align = 1;
 		}
@@ -4429,7 +4483,12 @@
 		{
 		  /* The rest are fake sections that shouldn't be written.  */
 		  sec->filepos = 0;
-		  sec->size = 0;
+		/*
+	 	 * FIXME
+	 	 * mayank@15th June, 2007
+	 	 * This should be size rather than rawsize
+	 	 */
+		  sec->rawsize = 0;
 		  sec->flags = 0;
 		  continue;
 		}
@@ -4455,13 +4514,23 @@
 		     not trashed.  */
 		  if ((flags & SEC_LOAD) != 0
 		      || (flags & SEC_HAS_CONTENTS) != 0)
-		    off += sec->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+		    off += sec->rawsize;
 		}
 
 	      if ((flags & SEC_LOAD) != 0)
 		{
-		  p->p_filesz += sec->size;
-		  p->p_memsz += sec->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+		  p->p_filesz += sec->rawsize;
+		  p->p_memsz += sec->rawsize;
 		}
 	      /* PR ld/594:  Sections in note segments which are not loaded
 		 contribute to the file size but not the in-memory size.  */
@@ -4473,10 +4542,15 @@
 		 normal segments.  */
 	      else if ((flags & SEC_THREAD_LOCAL) == 0
 		       || p->p_type == PT_TLS)
-		p->p_memsz += sec->size;
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+		p->p_memsz += sec->rawsize;
 
 	      if (p->p_type == PT_TLS
-		  && sec->size == 0
+		  && sec->rawsize == 0
 		  && (sec->flags & SEC_HAS_CONTENTS) == 0)
 		{
 		  struct bfd_link_order *o = sec->map_tail.link_order;
@@ -5147,14 +5221,18 @@
   (section->lma >= base							\
    && (section->lma + SECTION_SIZE (section, segment)			\
        <= SEGMENT_END (segment, base)))
-
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
   /* Special case: corefile "NOTE" section containing regs, prpsinfo etc.  */
 #define IS_COREFILE_NOTE(p, s)						\
   (p->p_type == PT_NOTE							\
    && bfd_get_format (ibfd) == bfd_core					\
    && s->vma == 0 && s->lma == 0					\
    && (bfd_vma) s->filepos >= p->p_offset				\
-   && ((bfd_vma) s->filepos + s->size				\
+   && ((bfd_vma) s->filepos + s->rawsize				\
        <= p->p_offset + p->p_filesz))
 
   /* The complicated case when p_vaddr is 0 is to handle the Solaris
@@ -5166,9 +5244,9 @@
    && p->p_memsz == 0							\
    && p->p_filesz > 0							\
    && (s->flags & SEC_HAS_CONTENTS) != 0				\
-   && s->size > 0							\
+   && s->rawsize > 0							\
    && (bfd_vma) s->filepos >= p->p_offset				\
-   && ((bfd_vma) s->filepos + s->size				\
+   && ((bfd_vma) s->filepos + s->rawsize				\
        <= p->p_offset + p->p_filesz))
 
   /* Decide if the given section should be included in the given segment.
@@ -5574,10 +5652,15 @@
 		      /* If the gap between the end of the previous section
 			 and the start of this section is more than
 			 maxpagesize then we need to start a new segment.  */
-		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->size,
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * This should be size rather than rawsize
+	 */
+		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->rawsize,
 				      maxpagesize)
 			   < BFD_ALIGN (output_section->lma, maxpagesize))
-			  || ((prev_sec->lma + prev_sec->size)
+			  || ((prev_sec->lma + prev_sec->rawsize)
 			      > output_section->lma))
 			{
 			  if (suggested_lma == 0)
diff -ruNbB binutils-2.17/bfd/hash.c binutils-2.17.sua/bfd/hash.c
--- binutils-2.17/bfd/hash.c	2006-03-16 13:20:15 +0100
+++ binutils-2.17.sua/bfd/hash.c	2008-04-01 09:03:08 +0200
@@ -547,6 +547,8 @@
   bfd_boolean xcoff;
 };
 
+static struct bfd_hash_entry *strtab_hash_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
 /* Routine to create an entry in a strtab.  */
 
 static struct bfd_hash_entry *
diff -ruNbB binutils-2.17/bfd/ieee.c binutils-2.17.sua/bfd/ieee.c
--- binutils-2.17/bfd/ieee.c	2006-03-06 14:42:03 +0100
+++ binutils-2.17.sua/bfd/ieee.c	2008-04-01 09:03:09 +0200
@@ -1975,7 +1975,8 @@
 ieee_print_symbol (bfd *abfd,
 		   void * afile,
 		   asymbol *symbol,
-		   bfd_print_symbol_type how)
+		   bfd_print_symbol_type how,
+		   asymbol * ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/ihex.c binutils-2.17.sua/bfd/ihex.c
--- binutils-2.17/bfd/ihex.c	2005-05-23 19:44:54 +0200
+++ binutils-2.17.sua/bfd/ihex.c	2008-04-01 09:03:09 +0200
@@ -124,6 +124,32 @@
 #include "libiberty.h"
 #include "safe-ctype.h"
 
+static void ihex_init
+  PARAMS ((void));
+static bfd_boolean ihex_mkobject
+  PARAMS ((bfd *));
+static INLINE int ihex_get_byte
+  PARAMS ((bfd *, bfd_boolean *));
+static void ihex_bad_byte
+  PARAMS ((bfd *, unsigned int, int, bfd_boolean));
+static bfd_boolean ihex_scan
+  PARAMS ((bfd *));
+static const bfd_target *ihex_object_p
+  PARAMS ((bfd *));
+static bfd_boolean ihex_read_section
+  PARAMS ((bfd *, asection *, bfd_byte *));
+static bfd_boolean ihex_get_section_contents
+  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
+static bfd_boolean ihex_set_section_contents
+  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
+static bfd_boolean ihex_write_record
+  PARAMS ((bfd *, size_t, unsigned int, unsigned int, bfd_byte *));
+static bfd_boolean ihex_write_object_contents
+  PARAMS ((bfd *));
+static bfd_boolean ihex_set_arch_mach
+  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
+static int ihex_sizeof_headers
+  PARAMS ((bfd *, bfd_boolean));
 /* The number of bytes we put on one line during output.  */
 
 #define CHUNK 16
@@ -947,6 +973,7 @@
 {
   "ihex",			/* Name.  */
   bfd_target_ihex_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* Target byte order.  */
   BFD_ENDIAN_UNKNOWN,		/* Target headers byte order.  */
   0,				/* Object flags.  */
diff -ruNbB binutils-2.17/bfd/libbfd-in.h binutils-2.17.sua/bfd/libbfd-in.h
--- binutils-2.17/bfd/libbfd-in.h	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/libbfd-in.h	2008-04-01 09:03:09 +0200
@@ -319,7 +319,7 @@
   ((long (*) (bfd *, asymbol **)) _bfd_n1)
 #define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
 #define _bfd_nosymbols_print_symbol \
-  ((void (*) (bfd *, void *, asymbol *, bfd_print_symbol_type)) bfd_void)
+  ((void (*) (bfd *, void *, asymbol *, bfd_print_symbol_type, asymbol *)) bfd_void)
 #define _bfd_nosymbols_get_symbol_info \
   ((void (*) (bfd *, asymbol *, symbol_info *)) bfd_void)
 #define _bfd_nosymbols_bfd_is_local_label_name \
@@ -658,6 +658,8 @@
 extern int real_fseek (FILE *file, file_ptr offset, int whence);
 extern FILE *real_fopen (const char *filename, const char *modes);
 
+extern bfd *bfd_last_cache;
+
 /* List of supported target vectors, and the default vector (if
    bfd_default_vector[0] is NULL, there is no default).  */
 extern const bfd_target * const *bfd_target_vector;
diff -ruNbB binutils-2.17/bfd/libbfd.c binutils-2.17.sua/bfd/libbfd.c
--- binutils-2.17/bfd/libbfd.c	2005-11-24 07:02:07 +0100
+++ binutils-2.17.sua/bfd/libbfd.c	2008-04-01 09:03:09 +0200
@@ -858,10 +858,10 @@
       || ! bfd_get_file_window (abfd, section->filepos + offset, count, w,
 				TRUE))
     return FALSE;
-  return TRUE;
 #else
   abort ();
 #endif
+  return TRUE;
 }
 
 /* This generic function can only be used in implementations where creating
diff -ruNbB binutils-2.17/bfd/libbfd.h binutils-2.17.sua/bfd/libbfd.h
--- binutils-2.17/bfd/libbfd.h	2006-03-26 01:38:42 +0100
+++ binutils-2.17.sua/bfd/libbfd.h	2008-04-01 09:03:09 +0200
@@ -324,7 +324,7 @@
   ((long (*) (bfd *, asymbol **)) _bfd_n1)
 #define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
 #define _bfd_nosymbols_print_symbol \
-  ((void (*) (bfd *, void *, asymbol *, bfd_print_symbol_type)) bfd_void)
+  ((void (*) (bfd *, void *, asymbol *, bfd_print_symbol_type, asymbol *)) bfd_void)
 #define _bfd_nosymbols_get_symbol_info \
   ((void (*) (bfd *, asymbol *, symbol_info *)) bfd_void)
 #define _bfd_nosymbols_bfd_is_local_label_name \
@@ -663,6 +663,8 @@
 extern int real_fseek (FILE *file, file_ptr offset, int whence);
 extern FILE *real_fopen (const char *filename, const char *modes);
 
+extern bfd *bfd_last_cache;
+
 /* List of supported target vectors, and the default vector (if
    bfd_default_vector[0] is NULL, there is no default).  */
 extern const bfd_target * const *bfd_target_vector;
@@ -768,6 +770,10 @@
   unsigned mapped : 1;         /* 1 = mmap, 0 = malloc */
 };
 /* Extracted from cache.c.  */
+#define BFD_CACHE_MAX_OPEN 10
+extern bfd *bfd_last_cache;
+
+
 bfd_boolean bfd_cache_init (bfd *abfd);
 
 bfd_boolean bfd_cache_close (bfd *abfd);
diff -ruNbB binutils-2.17/bfd/libcoff-in.h binutils-2.17.sua/bfd/libcoff-in.h
--- binutils-2.17/bfd/libcoff-in.h	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/libcoff-in.h	2008-04-01 09:03:09 +0200
@@ -22,6 +22,9 @@
 
 #include "bfdlink.h"
 
+#define DYNAMIC_LINKING /* Always defined, but useful as documentation. */
+#define USE_DLLS        /* Ditto */
+
 /* Object file tdata; access macros.  */
 
 #define coff_data(bfd)		      ((bfd)->tdata.coff_obj_data)
@@ -101,12 +104,18 @@
   /* The timestamp from the COFF file header.  */
   long timestamp;
 
+  /* list of sections (for quick access) */
+  asection **coff_sec;
+
   /* Copy of some of the f_flags bits in the COFF filehdr structure,
      used by ARM code.  */
   flagword flags;
 
 } coff_data_type;
 
+#define coff_coffsections(bfd)		((bfd)->tdata.coff_obj_data->coff_sec)
+
+
 /* Tdata for pe image files.  */
 typedef struct pe_tdata
 {
@@ -191,8 +200,17 @@
   bfd_vma offset;
   unsigned int i;
   const char *function;
-  /* Optional information about a COMDAT entry; NULL if not COMDAT. */
+#if 1
+  /* 
+   * Optional information about a COMDAT entry; NULL if not COMDAT.
+   * FIXME
+   * mayank@15th June, 2007
+   * in gcc3.3, this was present in 'struct sec' as  
+   * 'struct bfd_comdat_info *comdat'. Check if this is still required
+   * here ???
+   */
   struct coff_comdat_info *comdat;
+#endif
   int line_base;
   /* A pointer used for .stab linking optimizations.  */
   void * stab_info;
@@ -238,6 +256,188 @@
 #define pei_section_data(abfd, sec) \
   ((struct pei_section_tdata *) coff_section_data ((abfd), (sec))->tdata)
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* Dynamic section tags */
+
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH	15
+#define DT_SYMBOLIC	16
+#define DT_REL		17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+
+/* The next four dynamic tags are used on Solaris.  We support them
+   everywhere.  */
+#define DT_VERDEF	0x6ffffffc
+#define DT_VERDEFNUM	0x6ffffffd
+#define DT_VERNEED	0x6ffffffe
+#define DT_VERNEEDNUM	0x6fffffff
+
+/* These section tags are used on Solaris.  We support them
+   everywhere, and hope they do not conflict.  */
+
+#define DT_AUXILIARY	0x7ffffffd
+#define DT_FILTER	0x7fffffff
+
+/* This tag is a GNU extension to the Solaris version scheme.  */
+#define DT_VERSYM	0x6ffffff0
+
+
+/* External structure definitions */
+typedef struct {
+  unsigned char	d_tag[4];		/* entry tag value */
+  union {
+    unsigned char	d_val[4];
+    unsigned char	d_ptr[4];
+  } d_un;
+} coff_external_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vd_version[2];
+  unsigned char		vd_flags[2];
+  unsigned char		vd_ndx[2];
+  unsigned char		vd_cnt[2];
+  unsigned char		vd_hash[4];
+  unsigned char		vd_aux[4];
+  unsigned char		vd_next[4];
+} coff_external_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vda_name[4];
+  unsigned char		vda_next[4];
+} coff_external_verdaux;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vn_version[2];
+  unsigned char		vn_cnt[2];
+  unsigned char		vn_file[4];
+  unsigned char		vn_aux[4];
+  unsigned char		vn_next[4];
+} coff_external_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vna_hash[4];
+  unsigned char		vna_flags[2];
+  unsigned char		vna_other[2];
+  unsigned char		vna_name[4];
+  unsigned char		vna_next[4];
+} coff_external_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct {
+  unsigned char		vs_vers[2];
+} coff_external_versym;
+
+/* Internal structure definitions */
+typedef struct coff_internal_dyn {
+  bfd_vma d_tag;		/* entry tag value */
+  union {
+    bfd_vma	d_val;
+    bfd_vma	d_ptr;
+  } d_un;
+} coff_internal_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdef {
+  unsigned short vd_version;	/* Version number of structure.  */
+  unsigned short vd_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vd_ndx;	/* Version index.  */
+  unsigned short vd_cnt;	/* Number of verdaux entries.  */
+  unsigned long	 vd_hash;	/* Hash of name.  */
+  unsigned long	 vd_aux;	/* Offset to verdaux entries.  */
+  unsigned long	 vd_next;	/* Offset to next verdef.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vd_bfd;		/* BFD.  */
+  const char 		       *vd_nodename;	/* Version name.  */
+  struct coff_internal_verdef  *vd_nextdef;	/* vd_next as pointer.  */
+  struct coff_internal_verdaux *vd_auxptr;	/* vd_aux as pointer.  */
+  unsigned int		       vd_exp_refno;	/* Used by the linker.  */
+} coff_internal_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdaux {
+  unsigned long vda_name;	/* String table offset of name.  */
+  unsigned long vda_next;	/* Offset to next verdaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char *vda_nodename;			/* vda_name as pointer.  */
+  struct coff_internal_verdaux *vda_nextptr;	/* vda_next as pointer.  */
+} coff_internal_verdaux;
+ 
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_verneed {
+  unsigned short vn_version;	/* Version number of structure.  */
+  unsigned short vn_cnt;	/* Number of vernaux entries.  */
+  unsigned long	 vn_file;	/* String table offset of library name.  */
+  unsigned long	 vn_aux;	/* Offset to vernaux entries.  */
+  unsigned long	 vn_next;	/* Offset to next verneed.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vn_bfd;		/* BFD.  */
+  const char                   *vn_filename;	/* vn_file as pointer.  */
+  struct coff_internal_vernaux *vn_auxptr;	/* vn_aux as pointer.  */
+  struct coff_internal_verneed *vn_nextref;	/* vn_nextref as pointer.  */
+} coff_internal_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_vernaux {
+  unsigned long	 vna_hash;	/* Hash of dependency name.  */
+  unsigned short vna_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vna_other;	/* Unused.  */
+  unsigned long	 vna_name;	/* String table offset to version name.  */
+  unsigned long	 vna_next;	/* Offset to next vernaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char                  *vna_nodename;	/* vna_name as pointer.  */
+  struct coff_internal_vernaux *vna_nextptr;	/* vna_next as pointer.  */
+} coff_internal_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct coff_internal_versym {
+  unsigned short vs_vers;
+} coff_internal_versym;
+
+#define LOADER_NAME "/usr/lib/ld.so"
+
+#endif /* DYNAMIC_LINKING */ /* ] */
+
 /* COFF linker hash table entries.  */
 
 struct coff_link_hash_entry
@@ -266,7 +466,103 @@
   /* Flag word; legal values follow.  */
   unsigned short coff_link_hash_flags;
   /* Symbol is a PE section symbol.  */
-#define COFF_LINK_HASH_PE_SECTION_SYMBOL (01)
+#define COFF_LINK_HASH_PE_SECTION_SYMBOL 0x8000
+#ifdef DYNAMIC_LINKING /* [ */
+  /* More flag word values: */
+  /* Symbol is referenced by a non-shared object.  */
+#define COFF_LINK_HASH_REF_REGULAR	0x1
+  /* Symbol is defined by a non-shared object.  */
+#define COFF_LINK_HASH_DEF_REGULAR	0x2
+  /* Symbol is referenced by a shared object.  */
+#define COFF_LINK_HASH_REF_DYNAMIC	0x4
+  /* Symbol is defined by a shared object.  */
+#define COFF_LINK_HASH_DEF_DYNAMIC	0x8
+  /* Dynamic symbol has been adjustd.  */
+#define COFF_LINK_HASH_DYNAMIC_ADJUSTED 0x10
+  /* Symbol needs a copy reloc.  */
+#define COFF_LINK_HASH_NEEDS_COPY	0x20
+  /* Symbol needs a procedure linkage table entry.  */
+#define COFF_LINK_HASH_NEEDS_PLT	0x40
+  /* Symbol appears in a non-COFF input file.  */
+#define COFF_LINK_NON_COFF		0x80
+  /* Symbol should be marked as hidden in the version information.  */
+#define COFF_LINK_HIDDEN		0x100
+  /* Symbol was forced to local scope due to a version script file.  */
+#define COFF_LINK_FORCED_LOCAL		0x200
+  /* We'd like to force this local (via --retain-symbols-file), but don't 
+     know if we can, yet. */
+#define COFF_LINK_MAYBE_FORCED_LOCAL	0x400
+  /* Symbol (subsequently, mostly) found in a DLL library. */
+#define COFF_LINK_HASH_DLL_DEFINED	0x800
+  /* Dynsym has been renumbered.  Set exactly once on all renumbered ents. */
+#define COFF_LINK_HASH_RENUMBERED	0x1000
+  /* Dynsym has been emitted.  Set exactly once on all ents. */
+#define COFF_LINK_HASH_EMITTED          0x2000
+  /* Plt is a dup of another, due to weak/indirect; don't emit reloc. */
+#define COFF_LINK_WEAK_PLT              0x4000
+
+#ifdef USE_SIZE
+  /* Symbol size.  */
+  bfd_size_type size;
+#endif
+
+  /* Symbol index as a dynamic symbol.  Initialized to -1, and remains
+     -1 if this is not a dynamic symbol.  */
+  long dynindx;
+
+  /* String table index in .dynstr if this is a dynamic symbol.  */
+  unsigned long dynstr_index;
+
+#ifdef USE_WEAK
+  /* If this is a weak defined symbol from a dynamic object, this
+     field points to a defined symbol with the same value, if there is
+     one.  Otherwise it is NULL.  */
+  struct coff_link_hash_entry *weakdef;
+#endif
+
+  /* If this symbol requires an entry in the global offset table, the
+     processor specific backend uses this field to hold the offset
+     into the .got section.  If this field is -1, then the symbol does
+     not require a global offset table entry.  */
+  bfd_vma got_offset;
+
+  /* If this symbol requires an entry in the procedure linkage table,
+     the processor specific backend uses these two fields to hold the
+     offset into the procedure linkage section and the offset into the
+     .got section.  If plt_offset is -1, then the symbol does not
+     require an entry in the procedure linkage table.  */
+  bfd_vma plt_offset;
+
+  /* The number of DIR32 (etc.) relocation entries for this symbol;
+     used to allocate space in .rel.dyn section.  When linking
+     without COPY relocs, we otherwise would badly overestimate,
+     and it helps a little even for shared.  */
+  int num_long_relocs_needed;
+
+  /* Similarly; under some circumstances we can't know whether relative
+     relocs will be needed when counting, so we count them separately,
+     and apply once we do know. */
+  int num_relative_relocs_needed;
+
+  /* Version information.  */
+  union
+  {
+    /* This field is used for a symbol which is not defined in a
+       regular object.  It points to the version information read in
+       from the dynamic object.  */
+    coff_internal_verdef *verdef;
+
+    /* This field is used for a symbol which is defined in a regular
+       object.  It is set up in size_dynamic_sections.  It points to
+       the version information we should write out for this symbol.
+
+       Since it's already "global" (including in ld) as "elf_version_tree",
+       we'll leave it as "elf", even though it now applies to PE/COFF, too.
+       (Definition in bfdlink.h) */
+    struct bfd_elf_version_tree *vertree;
+
+  } verinfo;
+#endif /* ] */
 };
 
 /* COFF linker hash table.  */
@@ -276,6 +572,47 @@
   struct bfd_link_hash_table root;
   /* A pointer to information used to link stabs in sections.  */
   struct stab_info stab_info;
+#ifdef DYNAMIC_LINKING /* [ */
+  /* Whether we have created the special dynamic sections required
+     when linking against or generating a shared object.  */
+  bfd_boolean dynamic_sections_created;
+
+  /* The BFD used to hold special sections created by the linker.
+     This will be the first BFD found which requires these sections to
+     be created.  */
+  bfd *dynobj;
+
+  /* The number of symbols found in the link which must be put into
+     the .dynsym section.  */
+  bfd_size_type dynsymcount;
+
+  /* The string table of dynamic symbols, which becomes the .dynstr
+     section.  */
+  struct bfd_strtab_hash *dynstr;
+
+  /* The number of buckets in the hash table in the .hash section.
+     This is based on the number of dynamic symbols.  */
+  bfd_size_type bucketcount;
+
+  /* A linked list of DT_NEEDED names found in dynamic objects
+     included in the link.  */
+  struct bfd_link_needed_list *needed;
+
+  /* The _GLOBAL_OFFSET_TABLE_ symbol.  */
+  struct coff_link_hash_entry *hgot;
+
+  /* Certain dynamic sections which are frequently accessed, to skip
+     by-name lookup. (Apply to special cases hosted dynobj.) */
+  asection *sreloc;		/* .rel.internal */
+  asection *dynamic;		/* .dynamic */
+  asection *sgot;		/* .got */
+  asection *srelgot;		/* .rel.got */
+  asection *splt;		/* .plt */
+  asection *srelplt;		/* .rel.plt */
+  asection *sgotplt;		/* .rel.plt */
+
+#endif /* ] */
+
 };
 
 /* Look up an entry in a COFF linker hash table.  */
@@ -335,7 +672,7 @@
 extern asymbol *coff_make_empty_symbol
   (bfd *);
 extern void coff_print_symbol
-  (bfd *, void * filep, asymbol *, bfd_print_symbol_type);
+  (bfd *, void * filep, asymbol *, bfd_print_symbol_type,asymbol *);
 extern void coff_get_symbol_info
   (bfd *, asymbol *, symbol_info *ret);
 extern bfd_boolean _bfd_coff_is_local_label_name
@@ -495,6 +832,17 @@
   bfd_byte *external_relocs;
   /* Buffer large enough to hold swapped relocs of any input section.  */
   struct internal_reloc *internal_relocs;
+#ifdef DYNAMIC_LINKING
+  /* .dynsym section.  */
+  asection *dynsym_sec;
+
+  /* .hash section.  */
+  asection *hash_sec;
+
+  /* symbol version section (.gnu.version).  */
+  asection *symver_sec;
+#endif
+
 };
 
 /* Most COFF variants have no way to record the alignment of a
@@ -600,3 +948,123 @@
 extern bfd_boolean ppc_process_before_allocation
   (bfd *, struct bfd_link_info *);
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* in coffgen.c */
+long coff_get_dynamic_symtab_upper_bound PARAMS((bfd *));
+long coff_canonicalize_dynamic_symtab PARAMS((bfd *, asymbol **));
+long coff_get_dynamic_reloc_upper_bound PARAMS((bfd *));
+struct bfd_strtab_hash * _bfd_coff_stringtab_init PARAMS((void));
+char * bfd_coff_get_str_section PARAMS((bfd *, unsigned int));
+char * bfd_coff_string_from_coff_section 
+    PARAMS((bfd *, unsigned int, unsigned int));
+bfd_boolean _bfd_coff_slurp_version_tables PARAMS((bfd *abfd));
+long coff_get_synthetic_symtab PARAMS((long (*) (bfd *, long, asymbol **, long, asymbol **, asymbol **)));
+
+/* in cofflink.c */
+bfd_boolean _bfd_coff_link_record_dynamic_symbol 
+    PARAMS((struct bfd_link_info *, struct coff_link_hash_entry *h));
+bfd_boolean coff_add_dynamic_entry 
+    PARAMS((struct bfd_link_info *, bfd_vma, bfd_vma));
+void bfd_coff_set_dt_needed_name PARAMS((bfd *, const char *));
+struct bfd_link_needed_list * bfd_coff_get_needed_list 
+    PARAMS((bfd *, struct bfd_link_info *));
+const char * bfd_coff_get_dt_soname PARAMS((bfd *));
+bfd_boolean _bfd_coff_create_got_section 
+    PARAMS((bfd *, struct bfd_link_info *, char *, bfd_boolean));
+
+#define dyn_data(bfd) ((bfd)->dynamic_info)
+
+#define coff_local_got_offsets(bfd) ((bfd) -> local_got_offsets)
+#define coff_dynsymtab(bfd)   (dyn_data(bfd) -> dynsymtab)
+#define coff_dynstrtab(bfd)   (dyn_data(bfd) -> dynstrtab)
+#define coff_dynverdef(bfd)   (dyn_data(bfd) -> dynverdef)
+#define coff_dynverref(bfd)   (dyn_data(bfd) -> dynverref)
+#define coff_dynversym(bfd)   (dyn_data(bfd) -> dynversym)
+#define coff_dynamic(bfd)     (dyn_data(bfd) -> dynamic)
+#define coff_dt_name(bfd)     (dyn_data(bfd) -> dt_name)
+
+
+/* A cache of additional information if dynamic linking is actually
+   happening. */
+struct dynamic_info
+{
+  /* The "standard" secttions, where they're easy and quick to find */
+  asection *dynsymtab;
+  asection *dynstrtab;
+  asection *dynverdef;
+  asection *dynverref;
+  asection *dynversym;
+  asection *dynamic;
+
+  /* Number of symbol version definitions we are about to emit.  */
+  unsigned int cverdefs;
+
+  /* Number of symbol version references we are about to emit.  */
+  unsigned int cverrefs;
+
+  /* Symbol version definitions in external objects.  */
+  coff_internal_verdef *verdef;
+
+  /* Symbol version references to external objects.  */
+  coff_internal_verneed *verref;
+
+  /* A mapping from local symbols to offsets into the global offset
+     table, used when linking.  This is indexed by the symbol index.  */
+  bfd_vma *local_got_offsets;
+
+  /* The front end needs to let the back end know
+     what filename should be used for a dynamic object if the
+     dynamic object is found using a search.  The front end then
+     sometimes needs to know what name was actually used.  Until the
+     file has been added to the linker symbol table, this field holds
+     the name the linker wants.  After it has been added, it holds the
+     name actually used, which will be the DT_SONAME entry if there is
+     one.  */
+  const char *dt_name;
+
+};
+
+/* These constants are used for the version number of a Verdef structure.  */
+
+#define VER_DEF_NONE		0
+#define VER_DEF_CURRENT		1
+
+/* These constants appear in the vd_flags field of a Verdef structure.  */
+
+#define VER_FLG_BASE		0x1
+#define VER_FLG_WEAK		0x2
+
+/* These special constants can be found in an Versym field.  */
+
+#define VER_NDX_LOCAL		0
+#define VER_NDX_GLOBAL		1
+
+/* These constants are used for the version number of a Verneed structure.  */
+
+#define VER_NEED_NONE		0
+#define VER_NEED_CURRENT	1
+
+/* This flag appears in a Versym structure.  It means that the symbol
+   is hidden, and is only visible with an explicit version number.
+   This is a GNU extension.  */
+
+#define VERSYM_HIDDEN		0x8000
+
+/* This is the mask for the rest of the Versym information.  */
+
+#define VERSYM_VERSION		0x7fff
+
+/* This is a special token which appears as part of a symbol name.  It
+   indictes that the rest of the name is actually the name of a
+   version node, and is not part of the actual name.  This is a GNU
+   extension.  For example, the symbol name `stat%ver2' is taken to
+   mean the symbol `stat' in version `ver2'.  The historical use
+   of "@" doesn't work in PE, because @ is used by the Microsoft
+   tools. */
+#define COFF_VER_CHR '%'
+
+#define ARCH_SIZE 32   /* someday it might be 64 */
+
+#endif /* ] */
+
+
diff -ruNbB binutils-2.17/bfd/libcoff.h binutils-2.17.sua/bfd/libcoff.h
--- binutils-2.17/bfd/libcoff.h	2006-03-23 09:23:09 +0100
+++ binutils-2.17.sua/bfd/libcoff.h	2008-04-01 09:03:09 +0200
@@ -26,6 +26,9 @@
 
 #include "bfdlink.h"
 
+#define DYNAMIC_LINKING /* Always defined, but useful as documentation. */
+#define USE_DLLS        /* Ditto */
+
 /* Object file tdata; access macros.  */
 
 #define coff_data(bfd)		      ((bfd)->tdata.coff_obj_data)
@@ -105,12 +108,18 @@
   /* The timestamp from the COFF file header.  */
   long timestamp;
 
+  /* list of sections (for quick access) */
+  asection **coff_sec;
+
   /* Copy of some of the f_flags bits in the COFF filehdr structure,
      used by ARM code.  */
   flagword flags;
 
 } coff_data_type;
 
+#define coff_coffsections(bfd)		((bfd)->tdata.coff_obj_data->coff_sec)
+
+
 /* Tdata for pe image files.  */
 typedef struct pe_tdata
 {
@@ -195,8 +204,17 @@
   bfd_vma offset;
   unsigned int i;
   const char *function;
-  /* Optional information about a COMDAT entry; NULL if not COMDAT. */
+#if 1
+  /* 
+   * Optional information about a COMDAT entry; NULL if not COMDAT.
+   * FIXME
+   * mayank@15th June, 2007
+   * in gcc3.3, this was present in 'struct sec' as  
+   * 'struct bfd_comdat_info *comdat'. Check if this is still required
+   * here ???
+   */
   struct coff_comdat_info *comdat;
+#endif
   int line_base;
   /* A pointer used for .stab linking optimizations.  */
   void * stab_info;
@@ -242,6 +260,188 @@
 #define pei_section_data(abfd, sec) \
   ((struct pei_section_tdata *) coff_section_data ((abfd), (sec))->tdata)
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* Dynamic section tags */
+
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH	15
+#define DT_SYMBOLIC	16
+#define DT_REL		17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+
+/* The next four dynamic tags are used on Solaris.  We support them
+   everywhere.  */
+#define DT_VERDEF	0x6ffffffc
+#define DT_VERDEFNUM	0x6ffffffd
+#define DT_VERNEED	0x6ffffffe
+#define DT_VERNEEDNUM	0x6fffffff
+
+/* These section tags are used on Solaris.  We support them
+   everywhere, and hope they do not conflict.  */
+
+#define DT_AUXILIARY	0x7ffffffd
+#define DT_FILTER	0x7fffffff
+
+/* This tag is a GNU extension to the Solaris version scheme.  */
+#define DT_VERSYM	0x6ffffff0
+
+
+/* External structure definitions */
+typedef struct {
+  unsigned char	d_tag[4];		/* entry tag value */
+  union {
+    unsigned char	d_val[4];
+    unsigned char	d_ptr[4];
+  } d_un;
+} coff_external_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vd_version[2];
+  unsigned char		vd_flags[2];
+  unsigned char		vd_ndx[2];
+  unsigned char		vd_cnt[2];
+  unsigned char		vd_hash[4];
+  unsigned char		vd_aux[4];
+  unsigned char		vd_next[4];
+} coff_external_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vda_name[4];
+  unsigned char		vda_next[4];
+} coff_external_verdaux;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vn_version[2];
+  unsigned char		vn_cnt[2];
+  unsigned char		vn_file[4];
+  unsigned char		vn_aux[4];
+  unsigned char		vn_next[4];
+} coff_external_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vna_hash[4];
+  unsigned char		vna_flags[2];
+  unsigned char		vna_other[2];
+  unsigned char		vna_name[4];
+  unsigned char		vna_next[4];
+} coff_external_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct {
+  unsigned char		vs_vers[2];
+} coff_external_versym;
+
+/* Internal structure definitions */
+typedef struct coff_internal_dyn {
+  bfd_vma d_tag;		/* entry tag value */
+  union {
+    bfd_vma	d_val;
+    bfd_vma	d_ptr;
+  } d_un;
+} coff_internal_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdef {
+  unsigned short vd_version;	/* Version number of structure.  */
+  unsigned short vd_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vd_ndx;	/* Version index.  */
+  unsigned short vd_cnt;	/* Number of verdaux entries.  */
+  unsigned long	 vd_hash;	/* Hash of name.  */
+  unsigned long	 vd_aux;	/* Offset to verdaux entries.  */
+  unsigned long	 vd_next;	/* Offset to next verdef.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vd_bfd;		/* BFD.  */
+  const char 		       *vd_nodename;	/* Version name.  */
+  struct coff_internal_verdef  *vd_nextdef;	/* vd_next as pointer.  */
+  struct coff_internal_verdaux *vd_auxptr;	/* vd_aux as pointer.  */
+  unsigned int		       vd_exp_refno;	/* Used by the linker.  */
+} coff_internal_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdaux {
+  unsigned long vda_name;	/* String table offset of name.  */
+  unsigned long vda_next;	/* Offset to next verdaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char *vda_nodename;			/* vda_name as pointer.  */
+  struct coff_internal_verdaux *vda_nextptr;	/* vda_next as pointer.  */
+} coff_internal_verdaux;
+ 
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_verneed {
+  unsigned short vn_version;	/* Version number of structure.  */
+  unsigned short vn_cnt;	/* Number of vernaux entries.  */
+  unsigned long	 vn_file;	/* String table offset of library name.  */
+  unsigned long	 vn_aux;	/* Offset to vernaux entries.  */
+  unsigned long	 vn_next;	/* Offset to next verneed.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vn_bfd;		/* BFD.  */
+  const char                   *vn_filename;	/* vn_file as pointer.  */
+  struct coff_internal_vernaux *vn_auxptr;	/* vn_aux as pointer.  */
+  struct coff_internal_verneed *vn_nextref;	/* vn_nextref as pointer.  */
+} coff_internal_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_vernaux {
+  unsigned long	 vna_hash;	/* Hash of dependency name.  */
+  unsigned short vna_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vna_other;	/* Unused.  */
+  unsigned long	 vna_name;	/* String table offset to version name.  */
+  unsigned long	 vna_next;	/* Offset to next vernaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char                  *vna_nodename;	/* vna_name as pointer.  */
+  struct coff_internal_vernaux *vna_nextptr;	/* vna_next as pointer.  */
+} coff_internal_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct coff_internal_versym {
+  unsigned short vs_vers;
+} coff_internal_versym;
+
+#define LOADER_NAME "/usr/lib/ld.so"
+
+#endif /* DYNAMIC_LINKING */ /* ] */
+
 /* COFF linker hash table entries.  */
 
 struct coff_link_hash_entry
@@ -270,7 +470,103 @@
   /* Flag word; legal values follow.  */
   unsigned short coff_link_hash_flags;
   /* Symbol is a PE section symbol.  */
-#define COFF_LINK_HASH_PE_SECTION_SYMBOL (01)
+#define COFF_LINK_HASH_PE_SECTION_SYMBOL 0x8000
+#ifdef DYNAMIC_LINKING /* [ */
+  /* More flag word values: */
+  /* Symbol is referenced by a non-shared object.  */
+#define COFF_LINK_HASH_REF_REGULAR	0x1
+  /* Symbol is defined by a non-shared object.  */
+#define COFF_LINK_HASH_DEF_REGULAR	0x2
+  /* Symbol is referenced by a shared object.  */
+#define COFF_LINK_HASH_REF_DYNAMIC	0x4
+  /* Symbol is defined by a shared object.  */
+#define COFF_LINK_HASH_DEF_DYNAMIC	0x8
+  /* Dynamic symbol has been adjustd.  */
+#define COFF_LINK_HASH_DYNAMIC_ADJUSTED 0x10
+  /* Symbol needs a copy reloc.  */
+#define COFF_LINK_HASH_NEEDS_COPY	0x20
+  /* Symbol needs a procedure linkage table entry.  */
+#define COFF_LINK_HASH_NEEDS_PLT	0x40
+  /* Symbol appears in a non-COFF input file.  */
+#define COFF_LINK_NON_COFF		0x80
+  /* Symbol should be marked as hidden in the version information.  */
+#define COFF_LINK_HIDDEN		0x100
+  /* Symbol was forced to local scope due to a version script file.  */
+#define COFF_LINK_FORCED_LOCAL		0x200
+  /* We'd like to force this local (via --retain-symbols-file), but don't 
+     know if we can, yet. */
+#define COFF_LINK_MAYBE_FORCED_LOCAL	0x400
+  /* Symbol (subsequently, mostly) found in a DLL library. */
+#define COFF_LINK_HASH_DLL_DEFINED	0x800
+  /* Dynsym has been renumbered.  Set exactly once on all renumbered ents. */
+#define COFF_LINK_HASH_RENUMBERED	0x1000
+  /* Dynsym has been emitted.  Set exactly once on all ents. */
+#define COFF_LINK_HASH_EMITTED          0x2000
+  /* Plt is a dup of another, due to weak/indirect; don't emit reloc. */
+#define COFF_LINK_WEAK_PLT              0x4000
+
+#ifdef USE_SIZE
+  /* Symbol size.  */
+  bfd_size_type size;
+#endif
+
+  /* Symbol index as a dynamic symbol.  Initialized to -1, and remains
+     -1 if this is not a dynamic symbol.  */
+  long dynindx;
+
+  /* String table index in .dynstr if this is a dynamic symbol.  */
+  unsigned long dynstr_index;
+
+#ifdef USE_WEAK
+  /* If this is a weak defined symbol from a dynamic object, this
+     field points to a defined symbol with the same value, if there is
+     one.  Otherwise it is NULL.  */
+  struct coff_link_hash_entry *weakdef;
+#endif
+
+  /* If this symbol requires an entry in the global offset table, the
+     processor specific backend uses this field to hold the offset
+     into the .got section.  If this field is -1, then the symbol does
+     not require a global offset table entry.  */
+  bfd_vma got_offset;
+
+  /* If this symbol requires an entry in the procedure linkage table,
+     the processor specific backend uses these two fields to hold the
+     offset into the procedure linkage section and the offset into the
+     .got section.  If plt_offset is -1, then the symbol does not
+     require an entry in the procedure linkage table.  */
+  bfd_vma plt_offset;
+
+  /* The number of DIR32 (etc.) relocation entries for this symbol;
+     used to allocate space in .rel.dyn section.  When linking
+     without COPY relocs, we otherwise would badly overestimate,
+     and it helps a little even for shared.  */
+  int num_long_relocs_needed;
+
+  /* Similarly; under some circumstances we can't know whether relative
+     relocs will be needed when counting, so we count them separately,
+     and apply once we do know. */
+  int num_relative_relocs_needed;
+
+  /* Version information.  */
+  union
+  {
+    /* This field is used for a symbol which is not defined in a
+       regular object.  It points to the version information read in
+       from the dynamic object.  */
+    coff_internal_verdef *verdef;
+
+    /* This field is used for a symbol which is defined in a regular
+       object.  It is set up in size_dynamic_sections.  It points to
+       the version information we should write out for this symbol.
+
+       Since it's already "global" (including in ld) as "elf_version_tree",
+       we'll leave it as "elf", even though it now applies to PE/COFF, too.
+       (Definition in bfdlink.h) */
+    struct bfd_elf_version_tree *vertree;
+
+  } verinfo;
+#endif /* ] */
 };
 
 /* COFF linker hash table.  */
@@ -280,6 +576,47 @@
   struct bfd_link_hash_table root;
   /* A pointer to information used to link stabs in sections.  */
   struct stab_info stab_info;
+#ifdef DYNAMIC_LINKING /* [ */
+  /* Whether we have created the special dynamic sections required
+     when linking against or generating a shared object.  */
+  bfd_boolean dynamic_sections_created;
+
+  /* The BFD used to hold special sections created by the linker.
+     This will be the first BFD found which requires these sections to
+     be created.  */
+  bfd *dynobj;
+
+  /* The number of symbols found in the link which must be put into
+     the .dynsym section.  */
+  bfd_size_type dynsymcount;
+
+  /* The string table of dynamic symbols, which becomes the .dynstr
+     section.  */
+  struct bfd_strtab_hash *dynstr;
+
+  /* The number of buckets in the hash table in the .hash section.
+     This is based on the number of dynamic symbols.  */
+  bfd_size_type bucketcount;
+
+  /* A linked list of DT_NEEDED names found in dynamic objects
+     included in the link.  */
+  struct bfd_link_needed_list *needed;
+
+  /* The _GLOBAL_OFFSET_TABLE_ symbol.  */
+  struct coff_link_hash_entry *hgot;
+
+  /* Certain dynamic sections which are frequently accessed, to skip
+     by-name lookup. (Apply to special cases hosted dynobj.) */
+  asection *sreloc;		/* .rel.internal */
+  asection *dynamic;		/* .dynamic */
+  asection *sgot;		/* .got */
+  asection *srelgot;		/* .rel.got */
+  asection *splt;		/* .plt */
+  asection *srelplt;		/* .rel.plt */
+  asection *sgotplt;		/* .rel.plt */
+
+#endif /* ] */
+
 };
 
 /* Look up an entry in a COFF linker hash table.  */
@@ -339,7 +676,7 @@
 extern asymbol *coff_make_empty_symbol
   (bfd *);
 extern void coff_print_symbol
-  (bfd *, void * filep, asymbol *, bfd_print_symbol_type);
+  (bfd *, void * filep, asymbol *, bfd_print_symbol_type,asymbol *);
 extern void coff_get_symbol_info
   (bfd *, asymbol *, symbol_info *ret);
 extern bfd_boolean _bfd_coff_is_local_label_name
@@ -499,6 +836,17 @@
   bfd_byte *external_relocs;
   /* Buffer large enough to hold swapped relocs of any input section.  */
   struct internal_reloc *internal_relocs;
+#ifdef DYNAMIC_LINKING
+  /* .dynsym section.  */
+  asection *dynsym_sec;
+
+  /* .hash section.  */
+  asection *hash_sec;
+
+  /* symbol version section (.gnu.version).  */
+  asection *symver_sec;
+#endif
+
 };
 
 /* Most COFF variants have no way to record the alignment of a
@@ -604,6 +952,127 @@
 extern bfd_boolean ppc_process_before_allocation
   (bfd *, struct bfd_link_info *);
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* in coffgen.c */
+long coff_get_dynamic_symtab_upper_bound PARAMS((bfd *));
+long coff_canonicalize_dynamic_symtab PARAMS((bfd *, asymbol **));
+long coff_get_dynamic_reloc_upper_bound PARAMS((bfd *));
+struct bfd_strtab_hash * _bfd_coff_stringtab_init PARAMS((void));
+char * bfd_coff_get_str_section PARAMS((bfd *, unsigned int));
+char * bfd_coff_string_from_coff_section 
+    PARAMS((bfd *, unsigned int, unsigned int));
+bfd_boolean _bfd_coff_slurp_version_tables PARAMS((bfd *abfd));
+
+long coff_get_synthetic_symtab(bfd *, long , struct bfd_symbol **, long , struct bfd_symbol **,struct bfd_symbol **);
+
+/* in cofflink.c */
+bfd_boolean _bfd_coff_link_record_dynamic_symbol 
+    PARAMS((struct bfd_link_info *, struct coff_link_hash_entry *h));
+bfd_boolean coff_add_dynamic_entry 
+    PARAMS((struct bfd_link_info *, bfd_vma, bfd_vma));
+void bfd_coff_set_dt_needed_name PARAMS((bfd *, const char *));
+struct bfd_link_needed_list * bfd_coff_get_needed_list 
+    PARAMS((bfd *, struct bfd_link_info *));
+const char * bfd_coff_get_dt_soname PARAMS((bfd *));
+bfd_boolean _bfd_coff_create_got_section 
+    PARAMS((bfd *, struct bfd_link_info *, char *, bfd_boolean));
+
+#define dyn_data(bfd) ((bfd)->dynamic_info)
+
+#define coff_local_got_offsets(bfd) ((bfd) -> local_got_offsets)
+#define coff_dynsymtab(bfd)   (dyn_data(bfd) -> dynsymtab)
+#define coff_dynstrtab(bfd)   (dyn_data(bfd) -> dynstrtab)
+#define coff_dynverdef(bfd)   (dyn_data(bfd) -> dynverdef)
+#define coff_dynverref(bfd)   (dyn_data(bfd) -> dynverref)
+#define coff_dynversym(bfd)   (dyn_data(bfd) -> dynversym)
+#define coff_dynamic(bfd)     (dyn_data(bfd) -> dynamic)
+#define coff_dt_name(bfd)     (dyn_data(bfd) -> dt_name)
+
+
+/* A cache of additional information if dynamic linking is actually
+   happening. */
+struct dynamic_info
+{
+  /* The "standard" secttions, where they're easy and quick to find */
+  asection *dynsymtab;
+  asection *dynstrtab;
+  asection *dynverdef;
+  asection *dynverref;
+  asection *dynversym;
+  asection *dynamic;
+
+  /* Number of symbol version definitions we are about to emit.  */
+  unsigned int cverdefs;
+
+  /* Number of symbol version references we are about to emit.  */
+  unsigned int cverrefs;
+
+  /* Symbol version definitions in external objects.  */
+  coff_internal_verdef *verdef;
+
+  /* Symbol version references to external objects.  */
+  coff_internal_verneed *verref;
+
+  /* A mapping from local symbols to offsets into the global offset
+     table, used when linking.  This is indexed by the symbol index.  */
+  bfd_vma *local_got_offsets;
+
+  /* The front end needs to let the back end know
+     what filename should be used for a dynamic object if the
+     dynamic object is found using a search.  The front end then
+     sometimes needs to know what name was actually used.  Until the
+     file has been added to the linker symbol table, this field holds
+     the name the linker wants.  After it has been added, it holds the
+     name actually used, which will be the DT_SONAME entry if there is
+     one.  */
+  const char *dt_name;
+
+};
+
+/* These constants are used for the version number of a Verdef structure.  */
+
+#define VER_DEF_NONE		0
+#define VER_DEF_CURRENT		1
+
+/* These constants appear in the vd_flags field of a Verdef structure.  */
+
+#define VER_FLG_BASE		0x1
+#define VER_FLG_WEAK		0x2
+
+/* These special constants can be found in an Versym field.  */
+
+#define VER_NDX_LOCAL		0
+#define VER_NDX_GLOBAL		1
+
+/* These constants are used for the version number of a Verneed structure.  */
+
+#define VER_NEED_NONE		0
+#define VER_NEED_CURRENT	1
+
+/* This flag appears in a Versym structure.  It means that the symbol
+   is hidden, and is only visible with an explicit version number.
+   This is a GNU extension.  */
+
+#define VERSYM_HIDDEN		0x8000
+
+/* This is the mask for the rest of the Versym information.  */
+
+#define VERSYM_VERSION		0x7fff
+
+/* This is a special token which appears as part of a symbol name.  It
+   indictes that the rest of the name is actually the name of a
+   version node, and is not part of the actual name.  This is a GNU
+   extension.  For example, the symbol name `stat%ver2' is taken to
+   mean the symbol `stat' in version `ver2'.  The historical use
+   of "@" doesn't work in PE, because @ is used by the Microsoft
+   tools. */
+#define COFF_VER_CHR '%'
+
+#define ARCH_SIZE 32   /* someday it might be 64 */
+
+#endif /* ] */
+
+
 /* Extracted from coffcode.h.  */
 typedef struct coff_ptr_struct
 {
@@ -801,6 +1270,85 @@
   bfd_boolean (*_bfd_coff_final_link_postscript)
     (bfd *, struct coff_final_link_info *);
 
+ void (*_bfd_coff_canonicalize_one_symbol) PARAMS((
+       bfd *,
+       combined_entry_type *,
+       coff_symbol_type *));
+#ifdef DYNAMIC_LINKING
+ void (*_bfd_coff_swap_dyn_in) PARAMS ((
+       bfd *, 
+       const PTR, 
+       coff_internal_dyn *));
+ void (*_bfd_coff_swap_dyn_out) PARAMS ((
+       bfd *, 
+       const coff_internal_dyn *, 
+       coff_external_dyn *));
+ void (*_bfd_coff_swap_verdef_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verdef *src,
+       coff_internal_verdef *dst));
+ void (*_bfd_coff_swap_verdef_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verdef *src,
+       coff_external_verdef *dst));
+ void (*_bfd_coff_swap_verdaux_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verdaux *src,
+       coff_internal_verdaux *dst));
+ void (*_bfd_coff_swap_verdaux_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verdaux *src,
+       coff_external_verdaux *dst));
+ void (*_bfd_coff_swap_verneed_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_verneed *src,
+       coff_internal_verneed *dst));
+ void (*_bfd_coff_swap_verneed_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_verneed *src,
+       coff_external_verneed *dst));
+ void (*_bfd_coff_swap_vernaux_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_vernaux *src,
+       coff_internal_vernaux *dst));
+ void (*_bfd_coff_swap_vernaux_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_vernaux *src,
+       coff_external_vernaux *dst));
+ void (*_bfd_coff_swap_versym_in) PARAMS ((
+       bfd *abfd,
+       const coff_external_versym *src,
+       coff_internal_versym *dst));
+ void (*_bfd_coff_swap_versym_out) PARAMS ((
+       bfd *abfd,
+       const coff_internal_versym *src,
+       coff_external_versym *dst));
+ bfd_boolean (*_bfd_coff_backend_link_create_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+ bfd_boolean (*_bfd_coff_backend_check_relocs) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       asection *,
+       const struct internal_reloc *relocs));
+ bfd_boolean (*_bfd_coff_backend_adjust_dynamic_symbol) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       struct coff_link_hash_entry *,
+       bfd_boolean));
+ bfd_boolean (*_bfd_coff_backend_size_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+ bfd_boolean (*_bfd_coff_backend_finish_dynamic_symbol) PARAMS ((
+       bfd *,
+       struct bfd_link_info *,
+       struct coff_link_hash_entry *,
+       struct internal_syment *));
+ bfd_boolean (*_bfd_coff_backend_finish_dynamic_sections) PARAMS ((
+       bfd *,
+       struct bfd_link_info *));
+#endif
+
 } bfd_coff_backend_data;
 
 #define coff_backend_info(abfd) \
@@ -836,6 +1384,50 @@
 #define bfd_coff_swap_aouthdr_out(abfd, i,o) \
   ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
 
+#ifdef DYNAMIC_LINKING
+#define bfd_coff_swap_dyn_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_in) (abfd, i, o))
+#define bfd_coff_swap_dyn_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_out) (abfd, i, o))
+#define bfd_coff_swap_verdef_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_in) (abfd, i, o))
+#define bfd_coff_swap_verdef_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_out) (abfd, i, o))
+#define bfd_coff_swap_verdaux_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_in) (abfd, i, o))
+#define bfd_coff_swap_verdaux_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_out) (abfd, i, o))
+#define bfd_coff_swap_verneed_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_in) (abfd, i, o))
+#define bfd_coff_swap_verneed_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_out) (abfd, i, o))
+#define bfd_coff_swap_vernaux_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_in) (abfd, i, o))
+#define bfd_coff_swap_vernaux_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_out) (abfd, i, o))
+#define bfd_coff_swap_versym_in(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_in) (abfd, i, o))
+#define bfd_coff_swap_versym_out(abfd, i,o) \
+        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_out) (abfd, i, o))
+#define bfd_coff_backend_link_create_dynamic_sections(abfd, i) \
+        ((coff_backend_info (abfd)-> \
+           _bfd_coff_backend_link_create_dynamic_sections) (abfd, i))
+#define bfd_coff_backend_check_relocs(abfd, i, s, r) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_check_relocs) \
+           (abfd, i, s, r))
+#define bfd_coff_backend_adjust_dynamic_symbol(abfd, i, h, s) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_adjust_dynamic_symbol) \
+           (abfd, i, h, s))
+#define bfd_coff_backend_size_dynamic_sections(abfd, i) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_size_dynamic_sections) \
+           (abfd, i))
+#define bfd_coff_backend_finish_dynamic_symbol(abfd, i, h, s) \
+        ((coff_backend_info (abfd)->_bfd_coff_backend_finish_dynamic_symbol) \
+           (abfd, i, h, s))
+#define bfd_coff_backend_finish_dynamic_sections(abfd, i) \
+        ((coff_backend_info(abfd)->_bfd_coff_backend_finish_dynamic_sections) \
+           (abfd, i))
+#endif
 #define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
 #define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
 #define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
@@ -928,6 +1520,10 @@
   ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
    (info, abfd, name, flags, section, value, string, cp, coll, hashp))
 
+#define bfd_coff_canonicalize_one_symbol(abfd, src, dest) \
+        ((coff_backend_info (abfd)->_bfd_coff_canonicalize_one_symbol)\
+         (abfd, src, dest))
+
 #define bfd_coff_link_output_has_begun(a,p) \
   ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
 #define bfd_coff_final_link_postscript(a,p) \
diff -ruNbB binutils-2.17/bfd/libecoff.h binutils-2.17.sua/bfd/libecoff.h
--- binutils-2.17/bfd/libecoff.h	2005-05-23 19:44:55 +0200
+++ binutils-2.17.sua/bfd/libecoff.h	2008-04-01 09:03:09 +0200
@@ -277,7 +277,7 @@
 extern long _bfd_ecoff_canonicalize_symtab (bfd *, asymbol **);
 extern asymbol *_bfd_ecoff_make_empty_symbol (bfd *);
 extern void _bfd_ecoff_print_symbol
-  (bfd *, void *, asymbol *, bfd_print_symbol_type);
+  (bfd *, void *, asymbol *, bfd_print_symbol_type, asymbol *);
 extern void _bfd_ecoff_get_symbol_info
   (bfd *, asymbol *, symbol_info *);
 extern bfd_boolean _bfd_ecoff_bfd_is_local_label_name
diff -ruNbB binutils-2.17/bfd/libpei.h binutils-2.17.sua/bfd/libpei.h
--- binutils-2.17/bfd/libpei.h	2005-05-04 17:53:35 +0200
+++ binutils-2.17.sua/bfd/libpei.h	2008-04-01 09:03:09 +0200
@@ -315,6 +315,65 @@
 void        _bfd_XX_get_symbol_info (bfd *, asymbol *, symbol_info *);
 bfd_boolean _bfd_XXi_final_link_postscript (bfd *, struct coff_final_link_info *);
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+void pei_swap_dyn_out 
+    PARAMS((bfd *, const coff_internal_dyn *, coff_external_dyn *));
+#define coff_swap_dyn_out pei_swap_dyn_out
+
+void pei_swap_dyn_in PARAMS((bfd *, const PTR, coff_internal_dyn *));
+#define coff_swap_dyn_in pei_swap_dyn_in
+
+void pei_swap_verdef_in 
+    PARAMS((bfd *, const coff_external_verdef *, coff_internal_verdef *));
+#define coff_swap_verdef_in  pei_swap_verdef_in
+
+void pei_swap_verdef_out 
+    PARAMS((bfd *, const coff_internal_verdef *, coff_external_verdef *));
+#define coff_swap_verdef_out pei_swap_verdef_out 
+
+void pei_swap_verdaux_in 
+    PARAMS((bfd *, const coff_external_verdaux *, coff_internal_verdaux *));
+#define coff_swap_verdaux_in pei_swap_verdaux_in 
+
+void pei_swap_verdaux_out 
+    PARAMS((bfd *, const coff_internal_verdaux *, coff_external_verdaux *));
+#define coff_swap_verdaux_out pei_swap_verdaux_out 
+
+void pei_swap_verneed_in 
+    PARAMS((bfd *, const coff_external_verneed *, coff_internal_verneed *));
+#define coff_swap_verneed_in pei_swap_verneed_in 
+
+void pei_swap_verneed_out 
+    PARAMS((bfd *, const coff_internal_verneed *, coff_external_verneed *));
+#define coff_swap_verneed_out pei_swap_verneed_out 
+
+void pei_swap_vernaux_in 
+    PARAMS((bfd *, const coff_external_vernaux *, coff_internal_vernaux *));
+#define coff_swap_vernaux_in pei_swap_vernaux_in 
+
+void pei_swap_vernaux_out 
+    PARAMS((bfd *, const coff_internal_vernaux *, coff_external_vernaux *));
+#define coff_swap_vernaux_out pei_swap_vernaux_out 
+
+void pei_swap_versym_in 
+    PARAMS((bfd *, const coff_external_versym *, coff_internal_versym *));
+#define coff_swap_versym_in pei_swap_versym_in 
+
+void pei_swap_versym_out 
+    PARAMS((bfd *, const coff_internal_versym *, coff_external_versym *));
+#define coff_swap_versym_out pei_swap_versym_out 
+
+/* The #defines for below appear elsewhere. */
+bfd_boolean pei_generic_size_dynamic_sections 
+   PARAMS((bfd *, struct bfd_link_info *));
+
+#endif /* ] */
+
+
+#ifndef coff_final_link_postscript
+#define coff_final_link_postscript _bfd_XXi_final_link_postscript
+#endif
 /* The following are needed only for ONE of pe or pei, but don't
    otherwise vary; peicode.h fixes up ifdefs but we provide the
    prototype.  */
@@ -323,3 +382,8 @@
 unsigned    _bfd_XXi_only_swap_filehdr_out (bfd *, void *, void *);
 bfd_boolean _bfd_XX_bfd_copy_private_section_data (bfd *, asection *, bfd *, asection *);
 
+
+/* Macro: Returns true if the bfd is a PE executable as opposed to a PE object file.  */
+#define bfd_pe_executable_p(abfd) \
+  (strncmp ((abfd)->xvec->name, "pei-", 4) == 0		\
+   || strncmp ((abfd)->xvec->name, "efi-app-", 8) == 0)
diff -ruNbB binutils-2.17/bfd/linker.c binutils-2.17.sua/bfd/linker.c
--- binutils-2.17/bfd/linker.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/linker.c	2008-04-01 09:03:09 +0200
@@ -1405,7 +1405,9 @@
   COMMON_ROW,		/* Common.  */
   INDR_ROW,		/* Indirect.  */
   WARN_ROW,		/* Warning.  */
-  SET_ROW		/* Member of set.  */
+  SET_ROW,		/* Member of set.  */
+  ALIAS_ROW		/* Weak alias.  */
+
 };
 
 /* apparently needed for Hitachi 3050R(HI-UX/WE2)? */
@@ -1442,7 +1444,7 @@
 /* The state table itself.  The first index is a link_row and the
    second index is a bfd_link_hash_type.  */
 
-static const enum link_action link_action[8][8] =
+static const enum link_action link_action[9][8] =
 {
   /* current\prev    new    undef  undefw def    defw   com    indr   warn  */
   /* UNDEF_ROW 	*/  {UND,   NOACT, UND,   REF,   REF,   NOACT, REFC,  WARNC },
@@ -1452,7 +1454,8 @@
   /* COMMON_ROW	*/  {COM,   COM,   COM,   CREF,  COM,   BIG,   REFC,  WARNC },
   /* INDR_ROW	*/  {IND,   IND,   IND,   MDEF,  IND,   CIND,  MIND,  CYCLE },
   /* WARN_ROW   */  {MWARN, WARN,  WARN,  CWARN, CWARN, WARN,  CWARN, NOACT },
-  /* SET_ROW	*/  {SET,   SET,   SET,   SET,   SET,   SET,   CYCLE, CYCLE }
+  /* SET_ROW	*/  {SET,   SET,   SET,   SET,   SET,   SET,   CYCLE, CYCLE },
+  /* ALIAS_ROW 	*/  {IND,   IND,   IND,   NOACT, NOACT, NOACT, NOACT, CYCLE }
 };
 
 /* Most of the entries in the LINK_ACTION table are straightforward,
@@ -1534,10 +1537,18 @@
   enum link_row row;
   struct bfd_link_hash_entry *h;
   bfd_boolean cycle;
+  enum bfd_link_hash_type active_old_sym_type;
+
 
   if (bfd_is_ind_section (section)
       || (flags & BSF_INDIRECT) != 0)
+    {
+      /* Check for a weak alias */
+      if ((flags & BSF_WEAK) != 0)
+	row = ALIAS_ROW;
+      else
     row = INDR_ROW;
+    }
   else if ((flags & BSF_WARNING) != 0)
     row = WARN_ROW;
   else if ((flags & BSF_CONSTRUCTOR) != 0)
@@ -1584,12 +1595,21 @@
   if (hashp != NULL)
     *hashp = h;
 
+  /* Allow the symbol type for the old symbol to be changed for search
+     without actually having to change it. */
+  active_old_sym_type = h->type;
+
+  /* If it's an alias, pretend it's a weak def. */
+  if (active_old_sym_type == bfd_link_hash_indirect
+      && h->u.i.info.alias)
+    active_old_sym_type = bfd_link_hash_defweak;
+
   do
     {
       enum link_action action;
 
       cycle = FALSE;
-      action = link_action[(int) row][(int) h->type];
+      action = link_action[(int) row][(int) active_old_sym_type];
       switch (action)
 	{
 	case FAIL:
@@ -1897,6 +1917,7 @@
 
 	    h->type = bfd_link_hash_indirect;
 	    h->u.i.link = inh;
+	    h->u.i.info.alias = (flags & BSF_WEAK) != 0;
 	  }
 	  break;
 
@@ -1909,14 +1930,14 @@
 
 	case WARNC:
 	  /* Issue a warning and cycle.  */
-	  if (h->u.i.warning != NULL)
+	  if (h->u.i.info.warning != NULL)
 	    {
-	      if (! (*info->callbacks->warning) (info, h->u.i.warning,
+	      if (! (*info->callbacks->warning) (info, h->u.i.info.warning,
 						 h->root.string, abfd,
 						 NULL, 0))
 		return FALSE;
 	      /* Only issue a warning once.  */
-	      h->u.i.warning = NULL;
+	      h->u.i.info.warning = NULL;
 	    }
 	  /* Fall through.  */
 	case CYCLE:
@@ -1969,7 +1990,7 @@
 	    sub->type = bfd_link_hash_warning;
 	    sub->u.i.link = h;
 	    if (! copy)
-	      sub->u.i.warning = string;
+	      sub->u.i.info.warning = string;
 	    else
 	      {
 		char *w;
@@ -1979,7 +2000,7 @@
 		if (w == NULL)
 		  return FALSE;
 		memcpy (w, string, len);
-		sub->u.i.warning = w;
+		sub->u.i.info.warning = w;
 	      }
 
 	    bfd_hash_replace (&info->hash->table,
@@ -2366,12 +2387,24 @@
       else
 	abort ();
 
-      /* If this symbol is in a section which is not being included
-	 in the output file, then we don't want to output the
-	 symbol.  */
+#if 0
+	/*
+	 * FIXME
+	 * mayank@15th June, 2007
+	 * Check if this can be removed
+	 */
       if (!bfd_is_abs_section (sym->section)
 	  && bfd_section_removed_from_list (output_bfd,
 					    sym->section->output_section))
+#endif
+      /* If this symbol is in a section which is not being included
+	 in the output file, then we don't want to output the
+	 symbol.
+	 Gross.  .bss and similar sections won't have the linker_mark
+	 field set.  */
+      if ((sym->section->flags & SEC_HAS_CONTENTS) != 0
+	  && ! sym->section->linker_mark)
+
 	output = FALSE;
 
       if (output)
@@ -3006,6 +3039,10 @@
       struct coff_comdat_info *l_comdat
 	= bfd_coff_get_comdat_section (l->sec->owner, l->sec);
 
+      if (s_comdat == NULL /*&& abfd->filename[0]=='P'*/  /*name[1]=='i' && name[2] == 'd'*/)
+		s_comdat = sec->comdat;
+      if (l_comdat == NULL /*&& abfd->filename[0]=='P'*/ /*name[1]=='i' && name[2] == 'd'*/)
+		l_comdat = l->sec->comdat;
       /* We may have 3 different sections on the list: group section,
 	 comdat section and linkonce section. SEC may be a linkonce or
 	 comdat section. We always ignore group section. For non-COFF
@@ -3019,6 +3056,8 @@
 	{
 	  if (s_comdat != NULL
 	      && l_comdat != NULL
+	      && s_comdat->name != NULL
+	      && l_comdat->name != NULL
 	      && strcmp (s_comdat->name, l_comdat->name) != 0)
 	    skip = TRUE;
 	}
@@ -3066,6 +3105,9 @@
 	  sec->output_section = bfd_abs_section_ptr;
 	  sec->kept_section = l->sec;
 
+	  /* And if anyone is counting up relocs, say there are none. */
+	  sec->reloc_count = 0;
+
 	  return;
 	}
     }
diff -ruNbB binutils-2.17/bfd/mmo.c binutils-2.17.sua/bfd/mmo.c
--- binutils-2.17/bfd/mmo.c	2005-08-17 15:29:55 +0200
+++ binutils-2.17.sua/bfd/mmo.c	2008-04-01 09:03:09 +0200
@@ -349,7 +349,7 @@
   };
 
 /* Used when trying to find a section corresponding to addr.  */
-struct mmo_find_sec_info
+struct rawmmo_find_sec_info
   {
     asection *sec;
     bfd_vma addr;
@@ -382,7 +382,6 @@
 					     file_ptr, bfd_size_type);
 static long mmo_get_symtab_upper_bound (bfd *);
 static long mmo_canonicalize_symtab (bfd *, asymbol **);
-static void mmo_get_symbol_info (bfd *, asymbol *, symbol_info *);
 static void mmo_print_symbol (bfd *, void *, asymbol *,
 			      bfd_print_symbol_type);
 static bfd_boolean mmo_set_section_contents (bfd *, sec_ptr, const void *,
@@ -611,7 +610,7 @@
       !=  (SEC_LOAD | SEC_ALLOC))
     return;
 
-  if (infop->addr >= vma && infop->addr < vma + sec->size)
+  if (infop->addr >= vma && infop->addr < vma + sec->rawsize)
     infop->sec = sec;
 }
 
@@ -1515,6 +1514,7 @@
 mmo_map_set_sizes (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
 		   void *ignored ATTRIBUTE_UNUSED)
 {
+  sec->size = sec->rawsize;
   sec->lma = sec->vma;
 }
 
diff -ruNbB binutils-2.17/bfd/nlmcode.h binutils-2.17.sua/bfd/nlmcode.h
--- binutils-2.17/bfd/nlmcode.h	2005-05-04 17:53:36 +0200
+++ binutils-2.17.sua/bfd/nlmcode.h	2008-04-01 09:03:09 +0200
@@ -1105,7 +1105,8 @@
 nlm_print_symbol (bfd *abfd,
 		  void * afile,
 		  asymbol *symbol,
-		  bfd_print_symbol_type how)
+		  bfd_print_symbol_type how,
+		  asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/oasys.c binutils-2.17.sua/bfd/oasys.c
--- binutils-2.17/bfd/oasys.c	2005-10-06 21:21:14 +0200
+++ binutils-2.17.sua/bfd/oasys.c	2008-04-01 09:03:09 +0200
@@ -657,7 +657,7 @@
 }
 
 static void
-oasys_print_symbol (bfd *abfd, void * afile, asymbol *symbol, bfd_print_symbol_type how)
+oasys_print_symbol (bfd *abfd, void * afile, asymbol *symbol, bfd_print_symbol_type how, asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/opncls.c binutils-2.17.sua/bfd/opncls.c
--- binutils-2.17/bfd/opncls.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/opncls.c	2008-04-01 09:03:09 +0200
@@ -21,6 +21,13 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
+/*
+ * FIXME
+ * mayank@15th June, 2007
+ * This is not the correct place for this definition
+ */
+#define _ALL_SOURCE
+
 #include "bfd.h"
 #include "sysdep.h"
 #include "objalloc.h"
diff -ruNbB binutils-2.17/bfd/pdp11.c binutils-2.17.sua/bfd/pdp11.c
--- binutils-2.17/bfd/pdp11.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/pdp11.c	2008-04-01 09:03:09 +0200
@@ -2078,7 +2078,8 @@
 NAME (aout, print_symbol) (bfd * abfd,
 			   void * afile,
 			   asymbol *symbol,
-			   bfd_print_symbol_type how)
+			   bfd_print_symbol_type how,
+			   asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/peXXigen.c binutils-2.17.sua/bfd/peXXigen.c
--- binutils-2.17/bfd/peXXigen.c	2006-01-09 16:58:42 +0100
+++ binutils-2.17.sua/bfd/peXXigen.c	2008-04-01 09:03:09 +0200
@@ -168,6 +168,7 @@
 	  sec->lineno_count = 0;
 	  sec->userdata = NULL;
 	  sec->next = NULL;
+	  sec->flags = 0;
 	  sec->alignment_power = 2;
 	  sec->flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;
 
@@ -326,6 +327,14 @@
 	  return AUXESZ;
 	}
       break;
+  case C_NT_WEAK:
+    bfd_h_put_32(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
+    /* --- MAKE MORE PORTABLE or del below */
+    BFD_ASSERT (in->x_sym.x_misc.x_fsize == 3);
+    bfd_h_put_32 (abfd, in->x_sym.x_misc.x_fsize,
+	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
+    return AUXESZ;
+
     }
 
   H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
@@ -436,7 +445,8 @@
   {
     int idx;
 
-    for (idx = 0; idx < 16; idx++)
+    /* Believe the count that's in the file */
+    for (idx = 0; idx < a->NumberOfRvaAndSizes; idx++)
       {
         /* If data directory is empty, rva also should be 0.  */
 	int size =
@@ -451,35 +461,13 @@
       }
   }
 
-  if (aouthdr_int->entry)
-    {
-      aouthdr_int->entry += a->ImageBase;
-#ifndef COFF_WITH_pep
-      aouthdr_int->entry &= 0xffffffff;
-#endif
-    }
-
-  if (aouthdr_int->tsize)
-    {
-      aouthdr_int->text_start += a->ImageBase;
-#ifndef COFF_WITH_pep
-      aouthdr_int->text_start &= 0xffffffff;
-#endif
-    }
-
-#ifndef COFF_WITH_pep
-  /* PE32+ does not have data_start member!  */
-  if (aouthdr_int->dsize)
-    {
-      aouthdr_int->data_start += a->ImageBase;
-      aouthdr_int->data_start &= 0xffffffff;
-    }
-#endif
-
 #ifdef POWERPC_LE_PE
   /* These three fields are normally set up by ppc_relocate_section.
      In the case of reading a file in, we can pick them up from the
-     DataDirectory.  */
+     DataDirectory.  
+     The other NT versions use these same values, but don't use the globals
+     to get to them.  [12] is the IAT, [1] is the import table. */
+
   first_thunk_address = a->DataDirectory[12].VirtualAddress;
   thunk_size = a->DataDirectory[12].Size;
   import_table_size = a->DataDirectory[1].Size;
@@ -493,7 +481,8 @@
 		struct internal_extra_pe_aouthdr *aout,
 		int idx,
 		char *name,
-		bfd_vma base)
+     bfd_vma base ATTRIBUTE_UNUSED)
+	
 {
   asection *sec = bfd_get_section_by_name (abfd, name);
 
@@ -509,7 +498,7 @@
       if (size)
 	{
 	  aout->DataDirectory[idx].VirtualAddress =
-	    (sec->vma - base) & 0xffffffff;
+	    (sec->vma ) & 0xffffffff;
 	  sec->flags |= SEC_DATA;
 	}
     }
@@ -522,7 +511,7 @@
   pe_data_type *pe = pe_data (abfd);
   struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
   PEAOUTHDR *aouthdr_out = (PEAOUTHDR *) out;
-  bfd_vma sa, fa, ib;
+  bfd_vma sa, fa;
   IMAGE_DATA_DIRECTORY idata2, idata5, tls;
   
   if (pe->force_minimum_alignment)
@@ -538,36 +527,10 @@
 
   sa = extra->SectionAlignment;
   fa = extra->FileAlignment;
-  ib = extra->ImageBase;
-
   idata2 = pe->pe_opthdr.DataDirectory[1];
   idata5 = pe->pe_opthdr.DataDirectory[12];
   tls = pe->pe_opthdr.DataDirectory[9];
   
-  if (aouthdr_in->tsize)
-    {
-      aouthdr_in->text_start -= ib;
-#ifndef COFF_WITH_pep
-      aouthdr_in->text_start &= 0xffffffff;
-#endif
-    }
-
-  if (aouthdr_in->dsize)
-    {
-      aouthdr_in->data_start -= ib;
-#ifndef COFF_WITH_pep
-      aouthdr_in->data_start &= 0xffffffff;
-#endif
-    }
-
-  if (aouthdr_in->entry)
-    {
-      aouthdr_in->entry -= ib;
-#ifndef COFF_WITH_pep
-      aouthdr_in->entry &= 0xffffffff;
-#endif
-    }
-
 #define FA(x) (((x) + fa -1 ) & (- fa))
 #define SA(x) (((x) + sa -1 ) & (- sa))
 
@@ -576,12 +539,9 @@
 
   extra->NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
 
-  /* First null out all data directory entries.  */
-  memset (extra->DataDirectory, 0, sizeof (extra->DataDirectory));
-
-  add_data_entry (abfd, extra, 0, ".edata", ib);
-  add_data_entry (abfd, extra, 2, ".rsrc", ib);
-  add_data_entry (abfd, extra, 3, ".pdata", ib);
+  add_data_entry (abfd, extra, 0, ".edata", 0);
+  add_data_entry (abfd, extra, 2, ".rsrc", 0);
+  add_data_entry (abfd, extra, 3, ".pdata", 0);
 
   /* In theory we do not need to call add_data_entry for .idata$2 or
      .idata$5.  It will be done in bfd_coff_final_link where all the
@@ -596,10 +556,12 @@
   extra->DataDirectory[12] = idata5;
   extra->DataDirectory[9] = tls;
 
+#if 0
   if (extra->DataDirectory[1].VirtualAddress == 0)
     /* Until other .idata fixes are made (pending patch), the entry for
        .idata is needed for backwards compatibility.  FIXME.  */
     add_data_entry (abfd, extra, 1, ".idata", ib);
+#endif
     
   /* For some reason, the virtual size (which is what's set by
      add_data_entry) for .reloc is not the same as the size recorded
@@ -607,19 +569,18 @@
      but since it's the best we've got, use it.  It does do the right
      thing for .pdata.  */
   if (pe->has_reloc_section)
-    add_data_entry (abfd, extra, 5, ".reloc", ib);
+    add_data_entry (abfd, extra, 5, ".reloc", 0);
 
   {
     asection *sec;
     bfd_vma hsize = 0;
     bfd_vma dsize = 0;
-    bfd_vma isize = 0;
+    bfd_vma isize = SA(abfd->sections->filepos);
     bfd_vma tsize = 0;
 
     for (sec = abfd->sections; sec; sec = sec->next)
       {
-	int rounded = FA (sec->size);
-
+	int rounded = FA(sec->size);
 	/* The first non-zero section filepos is the header size.
 	   Sections without contents will have a filepos of 0.  */
 	if (hsize == 0)
@@ -642,8 +603,9 @@
     aouthdr_in->tsize = tsize;
     extra->SizeOfHeaders = hsize;
     extra->SizeOfImage = SA (hsize) + isize;
+    extra->SizeOfImage = isize;
   }
-
+  extra->SizeOfHeaders = abfd->sections->filepos;
   H_PUT_16 (abfd, aouthdr_in->magic, aouthdr_out->standard.magic);
 
 #define LINKER_VERSION 256 /* That is, 2.56 */
@@ -697,9 +659,10 @@
   H_PUT_32 (abfd, extra->NumberOfRvaAndSizes,
 	    aouthdr_out->NumberOfRvaAndSizes);
   {
-    int idx;
+    unsigned int idx;
 
-    for (idx = 0; idx < 16; idx++)
+    /* Believe the count that's in the file */
+    for (idx = 0; idx < H_GET_32(abfd,aouthdr_out->NumberOfRvaAndSizes); idx++)
       {
 	H_PUT_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
 		  aouthdr_out->DataDirectory[idx][0]);
@@ -848,29 +811,22 @@
   memcpy (scnhdr_ext->s_name, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));
 
   PUT_SCNHDR_VADDR (abfd,
-		    ((scnhdr_int->s_vaddr
-		      - pe_data (abfd)->pe_opthdr.ImageBase)
-		     & 0xffffffff),
+		    (scnhdr_int->s_vaddr),
 		    scnhdr_ext->s_vaddr);
 
   /* NT wants the size data to be rounded up to the next
-     NT_FILE_ALIGNMENT, but zero if it has no content (as in .bss,
-     sometimes).  */
-  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
-    {
-      if (bfd_pe_executable_p (abfd))
+     but zero if it has no content (as in .bss, sometimes).  However, this
+     applies only to executables, not objects. */
+
+  if (scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA
+     && coff_data (abfd)->link_info
+     && ! coff_data (abfd)->link_info->relocatable)
 	{
 	  ps = scnhdr_int->s_size;
 	  ss = 0;
 	}
       else
        {
-         ps = 0;
-         ss = scnhdr_int->s_size;
-       }
-    }
-  else
-    {
       if (bfd_pe_executable_p (abfd))
 	ps = scnhdr_int->s_paddr;
       else
@@ -953,6 +907,10 @@
 
     H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
   }
+    int flags = scnhdr_int->s_flags;
+
+    H_PUT_32 (abfd, flags, scnhdr_ext->s_flags);
+
 
   if (coff_data (abfd)->link_info
       && ! coff_data (abfd)->link_info->relocatable
@@ -988,7 +946,7 @@
          consistent with other parts of bfd. Also it lets us warn, as
          we should never see 0xffff here w/o having the overflow flag
          set.  */
-      if (scnhdr_int->s_nreloc < 0xffff)
+      if (scnhdr_int->s_nreloc <= 0xffff)
 	H_PUT_16 (abfd, scnhdr_int->s_nreloc, scnhdr_ext->s_nreloc);
       else
 	{
@@ -1001,6 +959,171 @@
   return ret;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+void
+pei_swap_dyn_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_dyn *src;
+     coff_external_dyn *dst;
+{
+  bfd_h_put_32 (abfd, src->d_tag, dst->d_tag);
+  bfd_h_put_32 (abfd, src->d_un.d_val, dst->d_un.d_val);
+}
+
+void
+pei_swap_dyn_in (abfd, p, dst)
+     bfd *abfd;
+     const PTR p;
+     coff_internal_dyn *dst;
+{
+  const coff_external_dyn *src = (const coff_external_dyn *) p;
+
+  dst->d_tag = bfd_h_get_32 (abfd, src->d_tag);
+  dst->d_un.d_val = bfd_h_get_32 (abfd, src->d_un.d_val);
+}
+
+/* Swap in a Verdef structure.  */
+
+void
+pei_swap_verdef_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verdef *src;
+     coff_internal_verdef *dst;
+{
+  dst->vd_version = bfd_h_get_16 (abfd, src->vd_version);
+  dst->vd_flags   = bfd_h_get_16 (abfd, src->vd_flags);
+  dst->vd_ndx     = bfd_h_get_16 (abfd, src->vd_ndx);
+  dst->vd_cnt     = bfd_h_get_16 (abfd, src->vd_cnt);
+  dst->vd_hash    = bfd_h_get_32 (abfd, src->vd_hash);
+  dst->vd_aux     = bfd_h_get_32 (abfd, src->vd_aux);
+  dst->vd_next    = bfd_h_get_32 (abfd, src->vd_next);
+}
+
+/* Swap out a Verdef structure.  */
+
+void
+pei_swap_verdef_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verdef *src;
+     coff_external_verdef *dst;
+{
+  bfd_h_put_16 (abfd, src->vd_version, dst->vd_version);
+  bfd_h_put_16 (abfd, src->vd_flags, dst->vd_flags);
+  bfd_h_put_16 (abfd, src->vd_ndx, dst->vd_ndx);
+  bfd_h_put_16 (abfd, src->vd_cnt, dst->vd_cnt);
+  bfd_h_put_32 (abfd, src->vd_hash, dst->vd_hash);
+  bfd_h_put_32 (abfd, src->vd_aux, dst->vd_aux);
+  bfd_h_put_32 (abfd, src->vd_next, dst->vd_next);
+}
+
+/* Swap in a Verdaux structure.  */
+
+void
+pei_swap_verdaux_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verdaux *src;
+     coff_internal_verdaux *dst;
+{
+  dst->vda_name = bfd_h_get_32 (abfd, src->vda_name);
+  dst->vda_next = bfd_h_get_32 (abfd, src->vda_next);
+}
+
+/* Swap out a Verdaux structure.  */
+
+void
+pei_swap_verdaux_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verdaux *src;
+     coff_external_verdaux *dst;
+{
+  bfd_h_put_32 (abfd, src->vda_name, dst->vda_name);
+  bfd_h_put_32 (abfd, src->vda_next, dst->vda_next);
+}
+
+/* Swap in a Verneed structure.  */
+
+void
+pei_swap_verneed_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verneed *src;
+     coff_internal_verneed *dst;
+{
+  dst->vn_version = bfd_h_get_16 (abfd, src->vn_version);
+  dst->vn_cnt     = bfd_h_get_16 (abfd, src->vn_cnt);
+  dst->vn_file    = bfd_h_get_32 (abfd, src->vn_file);
+  dst->vn_aux     = bfd_h_get_32 (abfd, src->vn_aux);
+  dst->vn_next    = bfd_h_get_32 (abfd, src->vn_next);
+}
+
+/* Swap out a Verneed structure.  */
+
+void
+pei_swap_verneed_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verneed *src;
+     coff_external_verneed *dst;
+{
+  bfd_h_put_16 (abfd, src->vn_version, dst->vn_version);
+  bfd_h_put_16 (abfd, src->vn_cnt, dst->vn_cnt);
+  bfd_h_put_32 (abfd, src->vn_file, dst->vn_file);
+  bfd_h_put_32 (abfd, src->vn_aux, dst->vn_aux);
+  bfd_h_put_32 (abfd, src->vn_next, dst->vn_next);
+}
+
+/* Swap in a Vernaux structure.  */
+
+void
+pei_swap_vernaux_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_vernaux *src;
+     coff_internal_vernaux *dst;
+{
+  dst->vna_hash  = bfd_h_get_32 (abfd, src->vna_hash);
+  dst->vna_flags = bfd_h_get_16 (abfd, src->vna_flags);
+  dst->vna_other = bfd_h_get_16 (abfd, src->vna_other);
+  dst->vna_name  = bfd_h_get_32 (abfd, src->vna_name);
+  dst->vna_next  = bfd_h_get_32 (abfd, src->vna_next);
+}
+
+/* Swap out a Vernaux structure.  */
+
+void
+pei_swap_vernaux_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_vernaux *src;
+     coff_external_vernaux *dst;
+{
+  bfd_h_put_32 (abfd, src->vna_hash, dst->vna_hash);
+  bfd_h_put_16 (abfd, src->vna_flags, dst->vna_flags);
+  bfd_h_put_16 (abfd, src->vna_other, dst->vna_other);
+  bfd_h_put_32 (abfd, src->vna_name, dst->vna_name);
+  bfd_h_put_32 (abfd, src->vna_next, dst->vna_next);
+}
+
+/* Swap in a Versym structure.  */
+
+void
+pei_swap_versym_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_versym *src;
+     coff_internal_versym *dst;
+{
+  dst->vs_vers = bfd_h_get_16 (abfd, src->vs_vers);
+}
+
+/* Swap out a Versym structure.  */
+
+void
+pei_swap_versym_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_versym *src;
+     coff_external_versym *dst;
+{
+  bfd_h_put_16 (abfd, src->vs_vers, dst->vs_vers);
+}
+
+#endif /* ] */
+
 static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
 {
   N_("Export Directory [.edata (or where ever we found it)]"),
@@ -1067,7 +1190,15 @@
     }
   else
     {
+#if 0
+	/*
+	 * mayank@15th June, 2007
+	 * New in 2.17 Check
+	 * remove if not required. The new code assumes that ImageBase is added
+	 * in section->vma whereas gcc3.3 ported to Interix assumed otherwise
+	 */
       addr += extra->ImageBase;
+#endif
       for (section = abfd->sections; section != NULL; section = section->next)
 	{
 	  datasize = section->size;
@@ -1102,9 +1233,8 @@
       bfd_vma loadable_toc_address;
       bfd_vma toc_address;
       bfd_vma start_address;
-      bfd_byte *data;
+      bfd_byte *data=0;
       bfd_vma offset;
-
       if (!bfd_malloc_and_get_section (abfd, rel_section, &data))
 	{
 	  if (data != NULL)
@@ -1156,8 +1285,12 @@
 	free (data);
       return FALSE;
     }
-
-  adj = section->vma - extra->ImageBase;
+  /*
+   * mayank@15th June, 2007
+   * Same assumption that section->vma has Imagebase added
+   * 2.17 has 'adj = section->vma - extra->ImageBase'
+   */
+  adj = section->vma;
 
   /* Print all image import descriptors.  */
   for (i = 0; i < datasize; i += onaline)
@@ -1353,11 +1486,19 @@
     }
   else
     {
-      addr += extra->ImageBase;
-
+#if 0
+	/*
+	 * mayank@15th June, 2007
+	 * ImageBase added in 2.17
+	 */
+	addr +=extra->ImageBase;	    	
+#endif
       for (section = abfd->sections; section != NULL; section = section->next)
-	if (addr >= section->vma && addr < section->vma + section->size)
+      {
+	  datasize = section->size;
+	if (addr >= section->vma && addr < section->vma + datasize)
 	  break;
+      }
 
       if (section == NULL)
 	{
@@ -1380,6 +1520,9 @@
   fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
 	   section->name, (unsigned long) addr);
 
+  dataoff = addr - section->vma;
+  datasize -= dataoff;
+
   data = bfd_malloc (datasize);
   if (data == NULL)
     return FALSE;
@@ -1401,7 +1544,11 @@
   edt.npt_addr       = bfd_get_32 (abfd, data + 32);
   edt.ot_addr        = bfd_get_32 (abfd, data + 36);
 
-  adj = section->vma - extra->ImageBase + dataoff;
+  /*
+   * mayank@15th June, 2007
+   * gcc 3.3 has 'adj= section->vma - extra->ImageBase + dataoff'
+   */
+  adj = section->vma + dataoff;
 
   /* Dump the EDT first.  */
   fprintf (file,
@@ -1756,6 +1903,164 @@
   return TRUE;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+static bfd_boolean pe_print_dynamic PARAMS((bfd *, PTR));
+static bfd_boolean
+pe_print_dynamic (abfd, vfile)
+     bfd *abfd;
+     PTR vfile;
+{
+  FILE *f = (FILE *) vfile;
+  asection *s;
+  bfd_byte *dynbuf = NULL;
+
+  if ((abfd->flags & DYNAMIC) == 0)
+      return TRUE;
+
+  s = coff_dynamic(abfd);
+  if (s != NULL)
+    {
+      unsigned long link;
+      coff_external_dyn *extdyn, *extdynend;
+
+      fprintf (f, _("\nDynamic (.so) Section:\n"));
+
+      dynbuf = (bfd_byte *) bfd_malloc (s->size);
+      if (dynbuf == NULL)
+	return FALSE;
+      if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
+				      s->size))
+	return FALSE;
+
+      link = s->link_index;
+
+      extdyn = (coff_external_dyn *)dynbuf;
+      extdynend = extdyn + s->size / sizeof (coff_external_dyn);
+
+      for (; extdyn < extdynend; extdyn++)
+	{
+	  coff_internal_dyn dyn;
+	  const char *name;
+	  char ab[20];
+	  bfd_boolean stringp;
+
+	  bfd_coff_swap_dyn_in (abfd, (PTR) extdyn, &dyn);
+
+	  if (dyn.d_tag == DT_NULL)
+	    break;
+
+	  stringp = FALSE;
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
+	      name = ab;
+	      break;
+
+	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
+	    case DT_PLTRELSZ: name = "PLTRELSZ"; break;
+	    case DT_PLTGOT: name = "PLTGOT"; break;
+	    case DT_HASH: name = "HASH"; break;
+	    case DT_STRTAB: name = "STRTAB"; break;
+	    case DT_SYMTAB: name = "SYMTAB"; break;
+	    case DT_RELA: name = "RELA"; break;
+	    case DT_RELASZ: name = "RELASZ"; break;
+	    case DT_RELAENT: name = "RELAENT"; break;
+	    case DT_STRSZ: name = "STRSZ"; break;
+	    case DT_SYMENT: name = "SYMENT"; break;
+	    case DT_INIT: name = "INIT"; break;
+	    case DT_FINI: name = "FINI"; break;
+	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
+	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
+	    case DT_SYMBOLIC: name = "SYMBOLIC"; break;
+	    case DT_REL: name = "REL"; break;
+	    case DT_RELSZ: name = "RELSZ"; break;
+	    case DT_RELENT: name = "RELENT"; break;
+	    case DT_PLTREL: name = "PLTREL"; break;
+	    case DT_DEBUG: name = "DEBUG"; break;
+	    case DT_TEXTREL: name = "TEXTREL"; break;
+	    case DT_JMPREL: name = "JMPREL"; break;
+	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
+	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
+	    case DT_VERSYM: name = "VERSYM"; break;
+	    case DT_VERDEF: name = "VERDEF"; break;
+	    case DT_VERDEFNUM: name = "VERDEFNUM"; break;
+	    case DT_VERNEED: name = "VERNEED"; break;
+	    case DT_VERNEEDNUM: name = "VERNEEDNUM"; break;
+	    }
+
+	  fprintf (f, "  %-11s ", name);
+	  if (! stringp)
+	    fprintf (f, "0x%lx", (unsigned long) dyn.d_un.d_val);
+	  else
+	    {
+	      const char *string;
+
+	      string = bfd_coff_string_from_coff_section (abfd, link,
+							dyn.d_un.d_val);
+	      if (string == NULL)
+		 string = "<BAD STRING>";
+	      fprintf (f, "%s", string);
+	    }
+	  fprintf (f, "\n");
+	}
+
+      free (dynbuf);
+      dynbuf = NULL;
+    }
+
+  if ((coff_dynverdef (abfd) != 0 && dyn_data(abfd)->verdef == NULL)
+      || (coff_dynverref (abfd) != 0 && dyn_data(abfd)->verref == NULL))
+    {
+      if (! _bfd_coff_slurp_version_tables (abfd))
+	return FALSE;
+    }
+
+  if (coff_dynverdef (abfd) != 0)
+    {
+      coff_internal_verdef *t;
+
+      fprintf (f, _("\nVersion definitions:\n"));
+      for (t = dyn_data(abfd)->verdef; t != NULL; t = t->vd_nextdef)
+	{
+	  fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
+		   t->vd_flags, t->vd_hash, t->vd_nodename);
+	  if (t->vd_auxptr->vda_nextptr != NULL)
+	    {
+	      coff_internal_verdaux *a;
+
+	      fprintf (f, "\t");
+	      for (a = t->vd_auxptr->vda_nextptr;
+		   a != NULL;
+		   a = a->vda_nextptr)
+		fprintf (f, "%s ", a->vda_nodename);
+	      fprintf (f, "\n");
+	    }
+	}
+    }
+
+  if (coff_dynverref (abfd) != 0)
+    {
+      coff_internal_verneed *t;
+
+      fprintf (f, _("\nVersion References:\n"));
+      for (t = dyn_data(abfd)->verref; t != NULL; t = t->vn_nextref)
+	{
+	  coff_internal_vernaux *a;
+
+	  fprintf (f, _("  required from %s:\n"), t->vn_filename);
+	  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	    fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
+		     a->vna_flags, a->vna_other, a->vna_nodename);
+	}
+    }
+    return TRUE;
+}
+
+#endif /* ] */
+
+
 /* Print out the program headers.  */
 
 bfd_boolean
@@ -1784,6 +2089,17 @@
   PF (IMAGE_FILE_SYSTEM, "system file");
   PF (IMAGE_FILE_DLL, "DLL");
   PF (IMAGE_FILE_BYTES_REVERSED_HI, "big endian");
+  PF (F_RELFLG, "relocations stripped");
+  PF (F_EXEC, "executable");
+  PF (F_LNNO, "line numbers stripped");
+  PF (F_LSYMS, "symbols stripped");
+  PF (0x80, "little endian");
+  PF (F_AR32WR, "32 bit words");
+  PF (0x200, "debugging information removed");
+  PF (0x1000, "system file");
+  PF (F_DLL, "DLL");
+  PF (0x8000, "big endian");
+
 #undef PF
 
   /* ctime implies '\n'.  */
@@ -1865,6 +2181,9 @@
 
   pe_print_idata (abfd, vfile);
   pe_print_edata (abfd, vfile);
+#ifdef DYNAMIC_LINKING
+  pe_print_dynamic (abfd, vfile);
+#endif
   pe_print_pdata (abfd, vfile);
   pe_print_reloc (abfd, vfile);
 
@@ -1932,6 +2251,12 @@
 	pei_section_data (ibfd, isec)->pe_flags;
     }
 
+#ifdef DYNAMIC_LINKING
+    osec->info_r = isec->info_r;
+    osec->info_l = isec->info_l;
+#endif
+
+
   return TRUE;
 }
 
@@ -1964,8 +2289,11 @@
     {
       pe_data (abfd)->pe_opthdr.DataDirectory[1].VirtualAddress =
 	(h1->root.u.def.value
-	 + h1->root.u.def.section->output_section->vma
-	 + h1->root.u.def.section->output_offset);
+	 + h1->root.u.def.section->output_section->vma);
+/*     #25549 idata$2 or import table is first  in this section and
+ *     we need not to add the offset at all here.
+ *     + h1->root.u.def.section->output_offset);
+ */
       h1 = coff_link_hash_lookup (coff_hash_table (info),
 				  ".idata$4", FALSE, FALSE, TRUE);
       pe_data (abfd)->pe_opthdr.DataDirectory[1].Size =
@@ -2008,3 +2334,241 @@
      program....  */
   return TRUE;
 }
+
+bfd_vma bfd_getImageBase (bfd *abfd);
+bfd_vma bfd_getImageBase (bfd *abfd)
+{
+  extern const bfd_target i386pei_vec;
+
+  /* We want to check for specifically PE, not just COFF, so we can't
+     use the flavour. */
+
+  if (abfd->xvec == &i386pei_vec)
+    return pe_data (abfd)->pe_opthdr.ImageBase;
+  else
+    return 0;
+}
+
+#ifdef DYNAMIC_LINKING /* [ */
+
+#define LOADER_SYM "__LOADER_NAME"
+
+bfd_boolean
+pei_generic_size_dynamic_sections (output_bfd, info)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+{
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean plt;
+  bfd_boolean relocs;
+  bfd_boolean reltext;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  /* We can get here because we're looking to see if any PIC modules
+     got in a static main program.  If none did, dynobj will be null,
+     and we're done.  */
+  if (dynobj == 0)
+      return TRUE;
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (! info->shared)
+	{
+          struct coff_link_hash_entry *h = NULL;
+
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = sizeof LOADER_NAME;
+	  s->contents = (unsigned char *) LOADER_NAME;
+
+	  /* Define the symbol __LOADER_NAME_ at the start of the
+	     .plt section.  */
+	  if (! (bfd_coff_link_add_one_symbol
+		 (info, dynobj, 
+		  &LOADER_SYM[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+		  BSF_GLOBAL, s,
+		  (bfd_vma) 0, (const char *) NULL, 
+		  FALSE, FALSE,
+		  ((struct bfd_link_hash_entry **) ((void *)&h)))))
+	    return FALSE;
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+	  h->type = 0;
+	}
+    }
+  else
+    {
+      /* We may have created entries in the .rel.got section.
+         However, if we are not creating the dynamic sections, we will
+         not actually use these entries.  Reset the size of .rel.got,
+         which will cause it to get stripped from the output file
+         below.  */
+      s = bfd_get_section_by_name (dynobj, ".rel.got");
+      if (s != NULL)
+	s->size = 0;
+    }
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  plt = FALSE;
+  relocs = FALSE;
+  reltext = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      const char *name;
+      bfd_boolean strip;
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      /* It's OK to base decisions on the section name, because none
+	 of the dynobj section names depend upon the input files.  */
+      name = bfd_get_section_name (dynobj, s);
+
+      strip = FALSE;
+
+      if (strcmp (name, ".plt") == 0)
+	{
+	  if (s->size == 0)
+	    {
+	      /* Strip this section if we don't need it; see the
+                 comment below.  */
+	      strip = TRUE;
+	    }
+	  else
+	    {
+	      /* Remember whether there is a PLT.  */
+	      plt = TRUE;
+	    }
+	}
+      else if (strncmp (name, ".rel", 4) == 0)
+	{
+	  if (s->size == 0)
+	    {
+	      /* If we don't need this section, strip it from the
+		 output file.  This is mostly to handle .rel.bss and
+		 .rel.plt.  We must create both sections in
+		 create_dynamic_sections, because they must be created
+		 before the linker maps input sections to output
+		 sections.  The linker does that before
+		 adjust_dynamic_symbol is called, and it is that
+		 function which decides whether anything needs to go
+		 into these sections.  */
+	      strip = TRUE;
+	    }
+	  else
+	    {
+	      /* Remember whether there are any reloc sections other
+                 than .rel.plt.  */
+	      if (strcmp (name, ".rel.plt") != 0)
+		{
+		  relocs = TRUE;
+
+		  /* We're left with .rel.internal and .rel.got.
+		     If there is a GOT (there may not be), it is
+		     by definition already read-write.  That leaves
+		     rel.internal to reflect relocations in all other
+		     sections; if it exists (and is non-zero size) then
+		     there are relocations that will (probably) cause 
+		     the text section to be written. It would be nice
+		     to be more accurate in this estimation.  That would
+		     speed up runtime startup. */
+		     
+	          if (strcmp (name, ".rel.internal") == 0)
+		    reltext = TRUE;
+		}
+
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
+      else if (strncmp (name, ".got", 4) != 0)
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (strip && strcmp(s->output_section->name,s->name)==0)
+	{
+	  asection **spp;
+
+	  for (spp = &s->output_section->owner->sections;
+	       *spp != s->output_section;
+	       spp = &(*spp)->next)
+	    ;
+	  *spp = s->output_section->next;
+	  --s->output_section->owner->section_count;
+
+	  continue;
+	}
+
+      /* Allocate memory for the section contents.  */
+      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
+      if (s->contents == NULL && s->size != 0)
+	return FALSE;
+    }
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in coff_i386_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+      if (! info->shared)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (plt)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_PLTGOT, 0)
+	      || ! coff_add_dynamic_entry (info, DT_PLTRELSZ, 0)
+	      || ! coff_add_dynamic_entry (info, DT_PLTREL, DT_REL)
+	      || ! coff_add_dynamic_entry (info, DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (relocs)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_REL, 0)
+	      || ! coff_add_dynamic_entry (info, DT_RELSZ, 0)
+	      || ! coff_add_dynamic_entry (info, DT_RELENT, RELSZ))
+	    return FALSE;
+	}
+
+      if (reltext)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_TEXTREL, 0))
+	    return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+
+/* Used in the final link pass to sort relocations; since the relocations
+   have been swapped out, it's somewhat target dependent. */
+int reloc_compar(const void *av, const void *bv);
+
+int
+reloc_compar(const void *av, const void *bv)
+{
+    struct external_reloc *a = (struct external_reloc *)av;
+    struct external_reloc *b = (struct external_reloc *)bv;
+
+    if (((*(int *)&a->r_symndx)&0xffffff) < ((*(int *)&b->r_symndx)&0xffffff))
+       return -1;
+    if (((*(int *)&a->r_symndx)&0xffffff) > ((*(int *)&b->r_symndx)&0xffffff))
+       return 1;
+    return 0;
+}
+
+#endif /* ] */
+
diff -ruNbB binutils-2.17/bfd/pei-i386.c binutils-2.17.sua/bfd/pei-i386.c
--- binutils-2.17/bfd/pei-i386.c	2005-05-04 17:53:37 +0200
+++ binutils-2.17.sua/bfd/pei-i386.c	2008-04-01 09:03:09 +0200
@@ -30,6 +30,8 @@
 #define COFF_SUPPORT_GNU_LINKONCE
 #define COFF_LONG_FILENAMES
 
+#define INPUT_FORMAT i386pe_vec
+
 #define COFF_SECTION_ALIGNMENT_ENTRIES \
 { COFF_SECTION_NAME_EXACT_MATCH (".bss"), \
   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \
diff -ruNbB binutils-2.17/bfd/peicode.h binutils-2.17.sua/bfd/peicode.h
--- binutils-2.17/bfd/peicode.h	2005-05-04 17:53:37 +0200
+++ binutils-2.17.sua/bfd/peicode.h	2008-04-01 09:03:09 +0200
@@ -38,7 +38,7 @@
    The *sole* difference between the pe format and the pei format is that the
    latter has an MSDOS 2.0 .exe header on the front that prints the message
    "This app must be run under Windows." (or some such).
-   (FIXME: Whether that statement is *really* true or not is unknown.
+   (FIXME: Whether that statement is *really* TRUE or not is unknown.
    Are there more subtle differences between pe and pei formats?
    For now assume there aren't.  If you find one, then for God sakes
    document it here!)
@@ -74,13 +74,23 @@
 #undef coff_bfd_copy_private_bfd_data
 #endif
 
+const bfd_target *
+pei_bfd_object_p (bfd * abfd);
 static bfd_boolean                     pe_bfd_copy_private_bfd_data (bfd *, bfd *);
 #define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data
 
 #define coff_mkobject      pe_mkobject
 #define coff_mkobject_hook pe_mkobject_hook
+#ifndef NO_COFF_RELOCS
+static void coff_swap_reloc_in PARAMS ((bfd *, PTR, PTR));
+static unsigned int coff_swap_reloc_out PARAMS ((bfd *, PTR, PTR));
+#endif
+static void coff_swap_filehdr_in PARAMS ((bfd *, PTR, PTR));
+static void coff_swap_scnhdr_in PARAMS ((bfd *, PTR, PTR));
+static bfd_boolean pe_mkobject PARAMS ((bfd *));
+static PTR pe_mkobject_hook PARAMS ((bfd *, PTR, PTR));
 
-#ifdef COFF_IMAGE_WITH_PE
+#ifndef COFF_IMAGE_WITH_PE
 /* This structure contains static variables used by the ILF code.  */
 typedef asection * asection_ptr;
 
@@ -94,16 +104,20 @@
   arelent *		reltab;
   unsigned int 		relcount;
 
+  /* The symbols themselves */
   coff_symbol_type * 	sym_cache;
   coff_symbol_type * 	sym_ptr;
   unsigned int       	sym_index;
 
+  /* The translation between internal and external symbol numbers */
   unsigned int * 	sym_table;
   unsigned int * 	table_ptr;
 
+  /* Internal symbol pointers */
   combined_entry_type * native_syms;
   combined_entry_type * native_ptr;
 
+  /* A required list of pointers to symbols */
   coff_symbol_type **	sym_ptr_table;
   coff_symbol_type **	sym_ptr_ptr;
 
@@ -113,6 +127,7 @@
   char *                string_ptr;
   char *		end_string_ptr;
 
+  /* External symbols */
   SYMENT *              esym_table;
   SYMENT *              esym_ptr;
 
@@ -121,6 +136,11 @@
 pe_ILF_vars;
 #endif /* COFF_IMAGE_WITH_PE */
 
+const bfd_target *coff_real_object_p
+  PARAMS ((bfd *, unsigned, struct internal_filehdr *,
+          struct internal_aouthdr *));
+
+
 #ifndef NO_COFF_RELOCS
 static void
 coff_swap_reloc_in (bfd * abfd, void * src, void * dst)
@@ -156,6 +176,13 @@
 }
 #endif /* not NO_COFF_RELOCS */
 
+#ifdef COFF_IMAGE_WITH_PE
+#undef FILHDR
+#define FILHDR struct external_PEI_IMAGE_hdr
+#endif
+
+static void coff_swap_filehdr_in PARAMS((bfd*, PTR, PTR));
+
 static void
 coff_swap_filehdr_in (bfd * abfd, void * src, void * dst)
 {
@@ -174,7 +201,7 @@
   if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
     {
       filehdr_dst->f_nsyms = 0;
-      filehdr_dst->f_flags |= F_LSYMS;
+      filehdr_dst->f_flags |= F_LSYMS;  // THIS LOOKS WRONG!!!!
     }
 
   filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
@@ -205,6 +232,22 @@
   /* MS handles overflow of line numbers by carrying into the reloc
      field (it appears).  Since it's supposed to be zero for PE
      *IMAGE* format, that's safe.  This is still a bit iffy.  */
+
+#if defined(COFF_IMAGE_WITH_PE) && defined(DYNAMIC_LINKING)
+  if ((abfd->flags & DYNAMIC) == 0 &&
+     strcmp(scnhdr_int->s_name,".text") == 0)
+    {
+      scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
+			     + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
+      scnhdr_int->s_nreloc = 0;
+    }
+  else
+    {
+      scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
+      scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
+    }
+#else
+
 #ifdef COFF_IMAGE_WITH_PE
   scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
 			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
@@ -213,14 +256,11 @@
   scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
   scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
 #endif
+#endif
 
-  if (scnhdr_int->s_vaddr != 0)
-    {
-      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
-      scnhdr_int->s_vaddr &= 0xffffffff;
-    }
-
+#ifdef COFF_IMAGE_WITH_PE
 #ifndef COFF_NO_HACK_SCNHDR_SIZE
+
   /* If this section holds uninitialized data and is from an object file
      or from an executable image that has not initialized the field,
      or if the image is an executable file and the physical size is padded,
@@ -235,6 +275,7 @@
      section.  */
     scnhdr_int->s_size = scnhdr_int->s_paddr;
 #endif
+#endif
 }
 
 static bfd_boolean
@@ -308,6 +349,13 @@
 #ifdef COFF_IMAGE_WITH_PE
   if (aouthdr)
     pe->pe_opthdr = ((struct internal_aouthdr *) aouthdr)->pe;
+#ifdef DYNAMIC_LINKING
+  if ((pe->pe_opthdr.DllCharacteristics & 0x0001) != 0)
+    abfd->flags |= DYNAMIC;
+
+  if ((pe->pe_opthdr.DllCharacteristics & 0x0002) != 0)
+    abfd->flags |= NO_LINK;
+#endif
 #endif
 
 #ifdef ARM
@@ -362,7 +409,7 @@
 
 #define coff_get_symbol_info _bfd_XX_get_symbol_info
 
-#ifdef COFF_IMAGE_WITH_PE
+#ifndef COFF_IMAGE_WITH_PE /* [ */
 
 /* Code to handle Microsoft's Image Library Format.
    Also known as LINK6 format.
@@ -373,9 +420,16 @@
 /* The following constants specify the sizes of the various data
    structures that we have to create in order to build a bfd describing
    an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6
-   and SIZEOF_IDATA7 below is to allow for the possibility that we might
-   need a padding byte in order to ensure 16 bit alignment for the section's
-   contents.
+   below is to allow for the possibility that we might need a padding byte
+   in order to ensure 16 bit alignment for the section's contents.
+   (SIZEOF_IDATA6 is a ceiling value anyway, as we may strip some decoration
+   off the symbol.)  We don't need an IDATA7.
+
+   Each section gets a section symbol, which has an AUX entry, so there
+   will be 2 symbol table entries for each section.  Four sections are
+   usually generated (.idata$4, .idata$5, .idata$6, and .text).
+   (.debug$S is not handled here.)
+
 
    The value for SIZEOF_ILF_STRINGS is computed as follows:
 
@@ -383,15 +437,16 @@
       per symbol for their names (longest section name is .idata$x).
 
       There will be two symbols for the imported value, one the symbol name
-      and one with _imp__ prefixed.  Allowing for the terminating nul's this
-      is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).
+      and one with _imp__ prefixed.  There will be one symbol referencing
+      __IMPORT_DESCRIPTOR_<name of source_dll>.  Allowing for the terminating
+      nul's this is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).
 
       The strings in the string table must start STRING__SIZE_SIZE bytes into
       the table in order to for the string lookup code in coffgen/coffcode to
       work.  */
 #define NUM_ILF_RELOCS		8
-#define NUM_ILF_SECTIONS        6
-#define NUM_ILF_SYMS 		(2 + NUM_ILF_SECTIONS)
+#define NUM_ILF_SECTIONS        4
+#define NUM_ILF_SYMS 		(3 + 2*NUM_ILF_SECTIONS)
 
 #define SIZEOF_ILF_SYMS		 (NUM_ILF_SYMS * sizeof (* vars.sym_cache))
 #define SIZEOF_ILF_SYM_TABLE	 (NUM_ILF_SYMS * sizeof (* vars.sym_table))
@@ -408,7 +463,6 @@
 #define SIZEOF_IDATA4		(1 * 4)
 #define SIZEOF_IDATA5		(1 * 4)
 #define SIZEOF_IDATA6		(2 + strlen (symbol_name) + 1 + 1)
-#define SIZEOF_IDATA7		(strlen (source_dll) + 1 + 1)
 #define SIZEOF_ILF_SECTIONS     (NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))
 
 #define ILF_DATA_SIZE				\
@@ -425,7 +479,6 @@
     + SIZEOF_IDATA4				\
     + SIZEOF_IDATA5				\
     + SIZEOF_IDATA6				\
-    + SIZEOF_IDATA7				\
     + SIZEOF_ILF_SECTIONS			\
     + MAX_TEXT_SECTION_SIZE
 
@@ -450,7 +503,8 @@
   entry->sym_ptr_ptr = sym;
 
   internal->r_vaddr  = address;
-  internal->r_symndx = sym_index;
+  /* External symbol number */
+  internal->r_symndx = vars->sym_table[sym_index];
   internal->r_type   = entry->howto->type;
 
   vars->relcount ++;
@@ -466,7 +520,14 @@
 		     bfd_reloc_code_real_type  reloc,
 		     asection_ptr              sec)
 {
-  pe_ILF_make_a_symbol_reloc (vars, address, reloc, sec->symbol_ptr_ptr,
+  /* We want to be sure to use the symbol we created, not the one
+     that was created as part of the section creation, for our
+     purposes.  (It might be possible to recycle the one built by
+     bfd_make_a_section_old_way, but it seems to be simpler this way,
+     except for the one line below.) */
+  pe_ILF_make_a_symbol_reloc (vars, address, reloc, 
+      (asymbol **)&((vars->sym_ptr_table)
+	    [coff_section_data (vars->abfd, sec)->i]),
 			      coff_section_data (vars->abfd, sec)->i);
 }
 
@@ -497,17 +558,25 @@
 
 /* Create a global symbol and add it to the relevant tables.  */
 
-static void
+static unsigned int
 pe_ILF_make_a_symbol (pe_ILF_vars *  vars,
 		      const char *   prefix,
 		      const char *   symbol_name,
 		      asection_ptr   section,
-		      flagword       extra_flags)
+		      flagword       extra_flags,
+		      int	     nreloc,
+		      asection_ptr   assoc_section)
 {
   coff_symbol_type * sym;
   combined_entry_type * ent;
   SYMENT * esym;
+  AUXENT * eaux;  		/* External format aux. */
+
   unsigned short sclass;
+  unsigned int this_index;
+
+  this_index = vars->sym_index;
+
 
   if (extra_flags & BSF_LOCAL)
     sclass = C_STAT;
@@ -544,6 +613,14 @@
   H_PUT_16 (vars->abfd, section->target_index, esym->e_scnum);
   esym->e_sclass[0] = sclass;
 
+  if ((section->flags & SEC_CODE) != 0
+     && (extra_flags & BSF_SECTION_SYM) == 0)
+     ent->u.syment.n_type = DT_FCN << N_BTSHFT;
+ else
+     ent->u.syment.n_type = T_NULL;
+
+ H_PUT_16 (vars->abfd, ent->u.syment.n_type, esym->e_type);
+
   /* The following initialisations are unnecessary - the memory is
      zero initialised.  They are just kept here as reminders.  */
 
@@ -554,13 +631,70 @@
 
   sym->symbol.the_bfd = vars->abfd;
   sym->symbol.name    = vars->string_ptr;
-  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | extra_flags;
+  /* We set NOT_AT_END because we generate things in the right order, and
+     we don't need any help from subsequent steps... they reorder things
+     improperly.  If NOT_AT_END is set for all our symbols, all is well.
+     Order is important when parsing comdat symbols. */
+
+  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | BSF_NOT_AT_END | extra_flags;
   sym->symbol.section = section;
   sym->native         = ent;
 
-  * vars->table_ptr = vars->sym_index;
+  /* This field is used when emitting relocs (e.g. objcopy); the
+     external symbol number. */
+  sym->symbol.udata.i = vars->native_ptr - vars->native_syms;
+
+  /* Record the translation for later use */
+  * vars->table_ptr = vars->native_ptr - vars->native_syms;
   * vars->sym_ptr_ptr = sym;
 
+  if ((extra_flags & BSF_SECTION_SYM) != 0)
+    {
+      /* Sections get an AUX entry. */ 
+      ent->u.syment.n_numaux = 1;
+      H_PUT_8 (vars->abfd, 1, esym->e_numaux);
+
+      /* We only increment the external symbol pointers; the AUX
+	entry internally doesn't take up a slot */
+      vars->native_ptr ++;
+      vars->esym_ptr ++;
+
+      ent = vars->native_ptr;
+      eaux = (AUXENT *)vars->esym_ptr;
+
+      ent->u.auxent.x_scn.x_scnlen = 
+	  bfd_get_section_size_before_reloc (section);
+      ent->u.auxent.x_scn.x_nreloc = nreloc;
+
+      H_PUT_32 (vars->abfd, ent->u.auxent.x_scn.x_scnlen,
+	  eaux->x_scn.x_scnlen);
+      H_PUT_16 (vars->abfd, ent->u.auxent.x_scn.x_nreloc,
+	  eaux->x_scn.x_nreloc);
+
+#if 0 /* See comment above.  */
+      ent->u.auxent.x_scn.x_nlinno = 0;
+      ent->u.auxent.x_scn.x_checksum = 0;
+      H_PUT_32 (vars->abfd, ent->u.auxent.x_scn.x_nlinno,
+	  eaux->x_scn.x_nlinno);
+      H_PUT_16 (vars->abfd, ent->u.auxent.x_scn.x_checksum,
+	  eaux->x_scn.x_checksum);
+#endif
+
+      if (assoc_section != NULL)
+	{
+	  ent->u.auxent.x_scn.x_comdat = IMAGE_COMDAT_SELECT_ASSOCIATIVE;
+	  ent->u.auxent.x_scn.x_associated = assoc_section->target_index;
+	}
+      else
+	{
+	  ent->u.auxent.x_scn.x_comdat = IMAGE_COMDAT_SELECT_NODUPLICATES;
+	}
+      H_PUT_8 (vars->abfd,  ent->u.auxent.x_scn.x_comdat,
+                         eaux->x_scn.x_comdat);
+      H_PUT_16 (vars->abfd, ent->u.auxent.x_scn.x_associated,
+		         eaux->x_scn.x_associated);
+    }
+
   /* Adjust pointers for the next symbol.  */
   vars->sym_index ++;
   vars->sym_ptr ++;
@@ -571,6 +705,7 @@
   vars->string_ptr += strlen (symbol_name) + strlen (prefix) + 1;
 
   BFD_ASSERT (vars->string_ptr < vars->end_string_ptr);
+  return this_index;
 }
 
 /* Create a section.  */
@@ -579,7 +714,10 @@
 pe_ILF_make_a_section (pe_ILF_vars * vars,
 		       const char *  name,
 		       unsigned int  size,
-		       flagword      extra_flags)
+		       flagword      extra_flags,
+		       int	     align,
+		       int	     nreloc,
+		       asection_ptr  assoc_section)
 {
   asection_ptr sec;
   flagword     flags;
@@ -592,7 +730,7 @@
 
   bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);
 
-  bfd_set_section_alignment (vars->abfd, sec, 2);
+  bfd_set_section_alignment (vars->abfd, sec, align);
 
   /* Check that we will not run out of space.  */
   BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);
@@ -601,29 +739,30 @@
      contents are filled in by our parent.  */
   bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);
   sec->contents = vars->data;
-  sec->target_index = vars->sec_index ++;
+  sec->target_index = ++vars->sec_index;  /* Target_index is off by 1 */
 
   /* Advance data pointer in the vars structure.  */
   vars->data += size;
 
-  /* Skip the padding byte if it was not needed.
-     The logic here is that if the string length is odd,
-     then the entire string length, including the null byte,
-     is even and so the extra, padding byte, is not needed.  */
+  /* Realign; we allocated oversize in a few places to allow for this
+     possibility.  (Arguably, it should be 32 bit aligned.) */
   if (size & 1)
-    vars->data --;
+    vars->data ++;
 
   /* Create a coff_section_tdata structure for our use.  */
   sec->used_by_bfd = (struct coff_section_tdata *) vars->data;
+  coff_section_data (vars->abfd, sec)->keep_contents = TRUE;
   vars->data += sizeof (struct coff_section_tdata);
 
   BFD_ASSERT (vars->data <= vars->bim->buffer + vars->bim->size);
 
-  /* Create a symbol to refer to this section.  */
-  pe_ILF_make_a_symbol (vars, "", name, sec, BSF_LOCAL);
+  /* Create a symbol to refer to this section; it must be a section symbol. 
+     Then cache the index to the symbol in the coff_section_data structure.  */
+
+  coff_section_data (vars->abfd, sec)->i = 
+      pe_ILF_make_a_symbol (vars, "", name, sec, 
+          BSF_LOCAL | BSF_SECTION_SYM, nreloc, assoc_section);
 
-  /* Cache the index to the symbol in the coff_section_data structure.  */
-  coff_section_data (vars->abfd, sec)->i = vars->sym_index - 1;
 
   return sec;
 }
@@ -649,6 +788,9 @@
 
 static jump_table jtab[] =
 {
+/* In MSVC, the trailing NOOPs are not generated, but this works and
+   should yield faster code.  (But then, since the DLL functions it's
+   calling are usually pretty heavy weight, it doesn't really matter much.) */
 #ifdef I386MAGIC
   { I386MAGIC,
     { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
@@ -715,6 +857,10 @@
   asection_ptr             id4, id5, id6 = NULL, text = NULL;
   coff_symbol_type **      imp_sym;
   unsigned int             imp_index;
+#ifdef DYNAMIC_LINKING
+  asection_ptr             secp;
+#endif
+
 
   /* Decode and verify the types field of the ILF structure.  */
   import_type = types & 0x3;
@@ -727,10 +873,7 @@
       break;
 
     case IMPORT_CONST:
-      /* XXX code yet to be written.  */
-      _bfd_error_handler (_("%B: Unhandled import type; %x"),
-			  abfd, import_type);
-      return FALSE;
+      break;
 
     default:
       _bfd_error_handler (_("%B: Unrecognised import type; %x"),
@@ -818,8 +961,11 @@
 
      Note we do not create a .idata$3 section as this is
      created for us by the linker script.  */
-  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 0);
-  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 0);
+  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 
+      SEC_LINK_ONCE | SEC_LINK_DUPLICATES_ONE_ONLY, 2, 1, NULL);
+  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 
+      SEC_DATA | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD, 2, 1, id5);
+
   if (id4 == NULL || id5 == NULL)
     return FALSE;
 
@@ -836,14 +982,10 @@
   else
     {
       char * symbol;
-      unsigned int len;
-
-      /* Create .idata$6 - the Hint Name Table.  */
-      id6 = pe_ILF_make_a_section (& vars, ".idata$6", SIZEOF_IDATA6, 0);
-      if (id6 == NULL)
-	return FALSE;
+      char * symend;
 
-      /* If necessary, trim the import symbol name.  */
+      /* If necessary, trim the import symbol name; that's not the same
+        as the linker names, so we have to be careful. */
       symbol = symbol_name;
 
       /* As used by MS compiler, '_', '@', and '?' are alternative
@@ -854,27 +996,39 @@
 	 PE COFF 6.0 spec (section 8.3, Import Name Type).  */
 
       if (import_name_type != IMPORT_NAME)
-	{
-	  char c = symbol[0];
-	  if (c == '_' || c == '@' || c == '?')
-	    symbol++;
-	}
+	/* Skip any prefix in symbol_name.  Only the first _ gets
+	   clobbered. */
+	if (* symbol == bfd_get_symbol_leading_char(abfd))
+	  ++ symbol;
+	while (*symbol == '@' || * symbol == '?')
+	  ++ symbol;
       
-      len = strlen (symbol);
       if (import_name_type == IMPORT_NAME_UNDECORATE)
 	{
-	  /* Truncate at the first '@'.  */
-	  char *at = strchr (symbol, '@');
+	  symend = symbol;
+	  /* Truncate at the first '@'  */
 
-	  if (at != NULL)
-	    len = at - symbol;
+	  while (* symend != 0 && * symend != '@')
+	    symend ++;
 	}
+      else
+	{
+          symend = strchr(symbol, 0);
+	}
+
+      /* Create .idata$6 - the Hint Name Table.  */
+      id6 = pe_ILF_make_a_section (& vars, ".idata$6", 
+	  (2 + symend-symbol + 1),
+	  SEC_DATA | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD, 1, 0, id5);
+      if (id6 == NULL)
+	return FALSE;
 
       id6->contents[0] = ordinal & 0xff;
       id6->contents[1] = ordinal >> 8;
 
-      memcpy ((char *) id6->contents + 2, symbol, len);
-      id6->contents[len + 2] = '\0';
+      strncpy (id6->contents + 2, symbol, symend-symbol);
+      *(id6->contents + 2 + (symend-symbol)) = '\0';
+   
     }
 
   if (import_name_type != IMPORT_ORDINAL)
@@ -906,7 +1060,9 @@
 	abort ();
 
       /* Create the .text section.  */
-      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, SEC_CODE);
+      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, 
+	SEC_CODE | SEC_READONLY | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_ONE_ONLY,
+	1, 1, NULL);
       if (text == NULL)
 	return FALSE;
 
@@ -914,9 +1070,9 @@
       memcpy (text->contents, jtab[i].data, jtab[i].size);
 
       /* Create an import symbol.  */
-      pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0);
-      imp_sym   = vars.sym_ptr_ptr - 1;
-      imp_index = vars.sym_index - 1;
+      imp_index =
+         pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0, 0, NULL);
+      imp_sym   = &(vars.sym_ptr_table)[imp_index];
 
       /* Create a reloc for the data in the text section.  */
 #ifdef MIPS_ARCH_MAGIC_WINCE
@@ -936,9 +1092,70 @@
 				    BFD_RELOC_32, (asymbol **) imp_sym,
 				    imp_index);
 
+      /* Fill in the comdat info. */
+      id5->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+      if (id5->comdat == NULL)
+	return FALSE;
+      id5->comdat->symbol = imp_index;
+      id5->comdat->name = (*imp_sym)->symbol.name;
+
+      /* Setting .idata$4 and .idata$6 comdats is an internal-only
+	 trick which causes the linker to handle these correctly
+	 since IMAGE_COMDAT_SELECT_ASSOCIATIVE isn't implemented.
+	 (The code in coffgen.c that handles this stuff has the
+	 same effect on the internal structures.)
+	 It makes objdumps of .lib files look a bit odd, because
+	 what objdump sees is the member after this process. */
+
+      id4->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+      if (id4->comdat == NULL)
+	return FALSE;
+      id4->comdat->symbol = imp_index;
+      id4->comdat->name = (*imp_sym)->symbol.name;
+
+      if (import_name_type != IMPORT_ORDINAL) { 
+          id6->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+          if (id6->comdat == NULL)
+	    return FALSE;
+          id6->comdat->symbol = imp_index;
+          id6->comdat->name = (*imp_sym)->symbol.name;
+      }
+
       pe_ILF_save_relocs (& vars, text);
       break;
 
+    case IMPORT_CONST:
+      /* Create an import symbol.  */
+      imp_index = 
+	  pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0, 0, NULL);
+      imp_sym   = &(vars.sym_ptr_table)[imp_index];
+
+      /* Fill in the comdat info. */
+      id5->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+      id5->comdat->symbol = imp_index;
+      id5->comdat->name = (char *)(*imp_sym)->symbol.name;
+
+      /* Setting .idata$4 and .idata$6 comdats is an internal-only
+	 trick which causes the linker to handle these correctly
+	 since IMAGE_COMDAT_SELECT_ASSOCIATIVE isn't implemented.
+	 (The code in coffgen.c that handles this stuff has the
+	 same effect on the internal structures.)
+	 It makes objdumps of .lib files look a bit odd, because
+	 what objdump sees is the member after this process. */
+
+      /* Fill in the comdat info. */
+      id4->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+      id4->comdat->symbol = imp_index;
+      id4->comdat->name = (char *)(*imp_sym)->symbol.name;
+
+      /* Fill in the comdat info. */
+      if (import_name_type != IMPORT_ORDINAL) { 
+          id6->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+          id6->comdat->symbol = imp_index;
+          id6->comdat->name = (char *)(*imp_sym)->symbol.name;
+      }
+      break;
+
     case IMPORT_DATA:
       break;
 
@@ -981,15 +1198,42 @@
   switch (import_type)
     {
     case IMPORT_CODE:
+      /* Make the comdat symbol and fill it into the required data. */
+      text->comdat = bfd_zalloc(abfd, sizeof(struct coff_comdat_info));
+      if (text->comdat == NULL)
+	return FALSE;
+
+      text->comdat->symbol = 
       pe_ILF_make_a_symbol (& vars, "", symbol_name, text,
-			    BSF_NOT_AT_END | BSF_FUNCTION);
+			    BSF_FUNCTION, 0, NULL);
+      text->comdat->name = symbol_name;
+
 
       /* Create an import symbol for the DLL, without the
        .dll suffix.  */
       ptr = (bfd_byte *) strrchr (source_dll, '.');
       if (ptr)
 	* ptr = 0;
-      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 0);
+      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 
+	0, 0, NULL);
+      if (ptr)
+	* ptr = '.';
+      break;
+
+    case IMPORT_CONST:
+      /* Create the symbol. */
+
+      pe_ILF_make_a_symbol (& vars, "", symbol_name, id5,
+			    0, 0, NULL);
+
+      /* Create an import symbol for the DLL, without the
+       .dll suffix.  */
+      ptr = strrchr (source_dll, '.');
+      if (ptr)
+	* ptr = 0;
+      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 
+	  0, 0, NULL);
+		
       if (ptr)
 	* ptr = '.';
       break;
@@ -1008,7 +1252,8 @@
   bfd_get_symcount (abfd) = vars.sym_index;
 
   obj_raw_syments (abfd) = vars.native_syms;
-  obj_raw_syment_count (abfd) = vars.sym_index;
+  obj_raw_syment_count (abfd) = vars.native_ptr - vars.native_syms;
+
 
   obj_coff_external_syms (abfd) = (void *) vars.esym_table;
   obj_coff_keep_syms (abfd) = TRUE;
@@ -1019,6 +1264,20 @@
   obj_coff_strings (abfd) = vars.string_table;
   obj_coff_keep_strings (abfd) = TRUE;
 
+#ifdef DYNAMIC_LINKING
+  /* Image the section lookup stuff used elsewhere. */
+  coff_coffsections(abfd) =
+     (asection **)bfd_alloc(abfd, sizeof(asection *) * abfd->section_count);
+
+  secp = abfd->sections;
+  while (secp)
+    {
+      coff_coffsections(abfd)[secp->index] = secp;
+      secp = secp->next;
+    }
+#endif
+
+
   abfd->flags |= HAS_SYMS;
 
   return TRUE;
@@ -1171,7 +1430,7 @@
     }
 
   symbol_name = (char *) ptr;
-  source_dll  = symbol_name + strlen (symbol_name) + 1;
+  source_dll  = ptr + strlen (ptr) + 1;
 
   /* Verify that the strings are null terminated.  */
   if (ptr[size - 1] != 0
@@ -1194,16 +1453,35 @@
 
   return abfd->xvec;
 }
+#endif /* ] */
 
-static const bfd_target *
-pe_bfd_object_p (bfd * abfd)
+
+#ifdef COFF_IMAGE_WITH_PE /* [ */
+
+/* Two versions... one for PE, the other for PEI.  Both need special
+   treatment. */
+
+/* Export this symbol so Interix core can use it, too. */
+
+const bfd_target *
+pei_bfd_object_p (bfd * abfd)
 {
+  /* It used to be the case that the front of the PE image was a fixed
+     size (up to the beginning of the section header table).  In principle
+     it was more complex than that, but other PE linkers didn't take
+     advantage of that.  Now they do.  We need to adapt bfd's conventions
+     on COFF executable headers to deal with that change.  An earlier
+     version of this dealt with variability in just one of the several
+     places it could occur.  That no longer serves, either. */
+
   bfd_byte buffer[4];
   struct external_PEI_DOS_hdr dos_hdr;
   struct external_PEI_IMAGE_hdr image_hdr;
+  struct internal_filehdr internal_f;
+  struct internal_aouthdr internal_a;
   file_ptr offset;
+  bfd_size_type opt_hdr_size;
 
-  /* Detect if this a Microsoft Import Library Format element.  */
   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
       || bfd_bread (buffer, (bfd_size_type) 4, abfd) != 4)
     {
@@ -1212,9 +1490,7 @@
       return NULL;
     }
 
-  if (H_GET_32 (abfd, buffer) == 0xffff0000)
-    return pe_ILF_object_p (abfd);
-
+  /* Read the DOS header */
   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
       || bfd_bread (&dos_hdr, (bfd_size_type) sizeof (dos_hdr), abfd)
 	 != sizeof (dos_hdr))
@@ -1233,13 +1509,16 @@
      of relocs in section 3).  Since this routine can only be called
      correctly for a PEI file, check the e_magic number here, and, if
      it doesn't match, clobber the f_magic number so that we don't get
-     a false match.  */
+     a FALSE match.  */
   if (H_GET_16 (abfd, dos_hdr.e_magic) != DOSMAGIC)
     {
       bfd_set_error (bfd_error_wrong_format);
       return NULL;
     }
 
+  /* Get the location of the NT image header out of the DOS header,
+     and read that */
+
   offset = H_GET_32 (abfd, dos_hdr.e_lfanew);
   if (bfd_seek (abfd, offset, SEEK_SET) != 0
       || (bfd_bread (&image_hdr, (bfd_size_type) sizeof (image_hdr), abfd)
@@ -1250,16 +1529,96 @@
       return NULL;
     }
 
+  /* Look for the NT magic number. */
   if (H_GET_32 (abfd, image_hdr.nt_signature) != 0x4550)
     {
       bfd_set_error (bfd_error_wrong_format);
       return NULL;
     }
+  /* To call real_object_p we need a swapped file header, which is
+     the composite of the DOS and Image headers.  */
+  bfd_coff_swap_filehdr_in (abfd, (PTR)&image_hdr, &internal_f);
+
+  /* If there's an optional header (size not zero) read it; the size
+     varies. */
+
+  opt_hdr_size = internal_f.f_opthdr;
+
+  if (opt_hdr_size != 0)
+    {
+      PTR opthdr;
+
+      opthdr = bfd_alloc (abfd, opt_hdr_size);
+      if (opthdr == NULL)
+       return NULL;
+
+      if (bfd_bread (opthdr, opt_hdr_size, abfd) != opt_hdr_size)
+       {
+         return NULL;
+       }
+
+      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) & internal_a);
+
+#if 0
+      /* If it's 0x20b (documented in the 1999 spec) we don't have
+        a chance (64 bit data structs vary widely); just give up now. */
+      if (internal_a.magic == 0x20b)
+       {
+         return NULL;
+       }
+#endif
+    }
+
+  /* The section headers follow immediately, and coff_real_object_p
+     will read them. */
+
+  return coff_real_object_p (abfd, internal_f.f_nscns, &internal_f,
+                            (opt_hdr_size != 0
+                             ? &internal_a
+                             : (struct internal_aouthdr *) NULL));
+}
+
+static const bfd_target *
+pe_bfd_object_p (bfd * abfd)
+{
+  /* pei_bfd_object_p will recognize an Interix core file, too.  We don't
+     want that, here. */
+  if (abfd->format == bfd_core) 
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  return pei_bfd_object_p (abfd);
+}
+
+ 
+#else /* ][ */
+
+static const bfd_target *
+pe_bfd_object_p (bfd * abfd)
+{
+  /*  For PE (non image) we need to recognize that we have a ILF library,
+      and if so, handle it (very!) specially.  However, it would be wrong
+      to recognize it as PEI; only PE will do. */
+  bfd_byte buffer[4];
+  unsigned long signature;
+
+  /* Detect if this a Microsoft Import Library Format element.  */
+  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
+      || bfd_bread (buffer, 4, abfd) != 4)
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+  
+  signature = H_GET_32 (abfd, buffer);
 
-  /* Here is the hack.  coff_object_p wants to read filhsz bytes to
-     pick up the COFF header for PE, see "struct external_PEI_filehdr"
-     in include/coff/pe.h.  We adjust so that that will work. */
-  if (bfd_seek (abfd, (file_ptr) (offset - sizeof (dos_hdr)), SEEK_SET) != 0)
+  if (signature == 0xffff0000)
+    return pe_ILF_object_p (abfd);
+
+  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0)
     {
       if (bfd_get_error () != bfd_error_system_call)
 	bfd_set_error (bfd_error_wrong_format);
@@ -1268,6 +1627,6 @@
 
   return coff_object_p (abfd);
 }
+#endif /* ~COFF_IMAGE_WITH_PE ] */
 
 #define coff_object_p pe_bfd_object_p
-#endif /* COFF_IMAGE_WITH_PE */
diff -ruNbB binutils-2.17/bfd/reloc.c binutils-2.17.sua/bfd/reloc.c
--- binutils-2.17/bfd/reloc.c	2006-03-26 01:38:42 +0100
+++ binutils-2.17.sua/bfd/reloc.c	2008-04-01 09:03:09 +0200
@@ -442,7 +442,7 @@
     case 4: return 8;
     case 8: return 16;
     case -2: return 4;
-    default: abort ();
+    default: abort (); return 0;
     }
 }
 
@@ -1012,7 +1013,7 @@
      initial relocation command value.  */
 
   /* Get symbol value.  (Common symbols are special.)  */
-  if (bfd_is_com_section (symbol->section))
+  if (bfd_is_com_section (symbol->section) || strncmp(howto->name,"GOTOFF",6)==0)
     relocation = 0;
   else
     relocation = symbol->value;
diff -ruNbB binutils-2.17/bfd/section.c binutils-2.17.sua/bfd/section.c
--- binutils-2.17/bfd/section.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/section.c	2008-04-01 09:03:09 +0200
@@ -149,6 +149,44 @@
 
 CODE_FRAGMENT
 .
+.
+.{* This enum exists so that transition to an abstraction can start;
+.   use with bfd_{get_,set_,}section_value_flag. *}
+.enum section_sec_flags {
+.	sec_flag_ALLOC,
+.	sec_flag_LOAD,
+.	sec_flag_RELOC,
+.	sec_flag_ARCH_BIT_0,
+.	sec_flag_READONLY,
+.	sec_flag_CODE,
+.	sec_flag_DATA,
+.	sec_flag_ROM,
+.	sec_flag_CONSTRUCTOR,
+.	sec_flag_HAS_CONTENTS,
+.	sec_flag_NEVER_LOAD,
+.	sec_flag_COFF_SHARED_LIBRARY,
+.	sec_flag_reserved1, sec_flag_reserved2, {* for constructor types *}
+.	sec_flag_HAS_GOT_REF,
+.	sec_flag_IS_COMMON,
+.	sec_flag_DEBUGGING,
+.	sec_flag_IN_MEMORY,
+.	sec_flag_EXCLUDE,
+.	sec_flag_SORT_ENTRIES,
+.	sec_flag_LINK_ONCE,
+.	sec_flag_reserved3,sec_flag_reserved4, {* for comdat types *}
+.	sec_flag_LINKER_CREATED,
+.	sec_flag_KEEP,
+.	sec_flag_SMALL_DATA,
+.	sec_flag_SHARED,
+.	sec_flag_BLOCK,
+.	sec_flag_CLINK,
+.	sec_flag_MERGE,
+.	sec_flag_STRINGS,
+.	sec_flag_GROUP,
+.	sec_flag_NOREAD,
+.      sec_flag_last  {* The traditional "last" value *}
+.};
+.
 .typedef struct bfd_section
 .{
 .  {* The name of the section; the name isn't a copy, the pointer is
@@ -171,6 +209,8 @@
 .     flags are read in from the object file, and some are
 .     synthesized from other information.  *}
 .  flagword flags;
+.  flagword more_flags[1];
+.
 .
 .#define SEC_NO_FLAGS   0x000
 .
@@ -458,6 +498,24 @@
 .  {* File position of line data.  *}
 .  file_ptr line_filepos;
 .
+.{* #ifdef DYNAMIC_LINKING *}
+.  {* Certain sections need counts, which we overload into the
+.     coff number of relocs and/or number of line numbers fields,
+.     but carrying those in the same fields here is asking for 
+.     trouble, so the overloaded ones live here. *}
+.
+.  unsigned int info_r;
+.  unsigned int info_l;
+.
+.  {* There are multiple string tables possible when dynamically
+.     linking; this is the section number for the string table
+.     for this section *}
+.
+.  int link_index;
+.
+.{* #endif *}
+
+.
 .  {* Pointer to data for applications.  *}
 .  void *userdata;
 .
@@ -701,10 +759,67 @@
   GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, &bfd_ind_section)
 };
 
+#if 0
+/*
+ * FIXME
+ * mayank@15th June, 2007
+ * This was causing too much confusion while bringing changes
+ * from gcc3.3. Probably later we can reinclude to make clean
+ * code
+ */
 #define STD_SECTION(SEC, FLAGS, SYM, NAME, IDX)				\
   const asymbol * const SYM = (asymbol *) &global_syms[IDX]; 		\
   asection SEC = BFD_FAKE_SECTION(SEC, FLAGS, &global_syms[IDX], &SYM,	\
 				  NAME, IDX)
+#endif
+
+#define STD_SECTION(SEC, FLAGS, SYM, NAME, IDX)				\
+  const asymbol * const SYM = (asymbol *) &global_syms[IDX]; 		\
+  asection SEC =   							\
+	 /* name, id,  index, next, prev, flags, moreflags, user_set_vma, */  \
+	{ NAME,  IDX, 0,     NULL, NULL, FLAGS, {0},	0,      \
+                                                                       \
+  /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */  \
+     0,           0,                1,       0,                        \
+                                                                       \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_gp_reloc, need_finalize_relax, reloc_done,                */  \
+     0,            0,                   0,                             \
+                                                                       \
+  /* vma, lma, size, rawsize                                       */  \
+     0,   0,   0,    0,                                                \
+                                                                       \
+  /* output_offset, output_section,              alignment_power,  */  \
+     0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                       \
+  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+     NULL,       NULL,        0,           0,       0,                 \
+                                                                       \
+  /* line_filepos,  */							\
+	  0,								\
+   /* info_r, info_l, link_index */					\
+	  0,	0,	0,						\
+   /* userdata, contents, lineno, lineno_count,       */  		\
+       NULL,     NULL,     NULL,   0,                      		\
+                                                                       \
+  /* entsize, comdat , kept_section, moving_line_filepos,           */ \
+     0,       NULL, NULL,          0,                                  \
+                                                                       \
+  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+     0,            NULL,        NULL,              NULL,               \
+                                                                       \
+  /* symbol,                                                       */  \
+     (struct bfd_symbol *) &global_syms[IDX],                          \
+                                                                       \
+  /* symbol_ptr_ptr,                                               */  \
+     (struct bfd_symbol **) &SYM,                                   \
+                                                                       \
+  /* map_head, map_tail                                            */  \
+     { NULL }, { NULL }                                                \
+    }
+
 
 STD_SECTION (bfd_com_section, SEC_IS_COMMON, bfd_com_symbol,
 	     BFD_COM_SECTION_NAME, 0);
@@ -766,6 +881,13 @@
   newsect->symbol->section = newsect;
   newsect->symbol->flags = BSF_SECTION_SYM;
 
+#ifdef DYNAMIC_LINKING
+  newsect->info_r = newsect->info_l = 0;
+#endif
+#ifdef DYNAMIC_LINKING
+  newsect->info_r = newsect->info_l = 0;
+#endif
+
   newsect->symbol_ptr_ptr = &newsect->symbol;
 
   if (! BFD_SEND (abfd, _new_section_hook, (abfd, newsect)))
@@ -1125,7 +1247,7 @@
   if (newsect->name != NULL)
     {
       /* Section already exists.  */
-      return NULL;
+      return newsect;
     }
 
   newsect->name = name;
@@ -1289,6 +1411,13 @@
     }
 
   ptr->size = val;
+
+  /*
+   * mayank@15th June, 2007
+   * this is necessary or else rawsize is zero in most places and
+   * we hit ASSERTS
+   */
+  ptr->rawsize = val;
   return TRUE;
 }
 
@@ -1319,6 +1448,12 @@
 
 */
 
+#define bfd_get_section_size_now(abfd,sec) \
+(sec->reloc_done \
+ ? bfd_get_section_size_after_reloc (sec) \
+ : bfd_get_section_size_before_reloc (sec))
+
+
 bfd_boolean
 bfd_set_section_contents (bfd *abfd,
 			  sec_ptr section,
@@ -1349,6 +1483,30 @@
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
     }
+#if 0
+  /*
+   * FIXME
+   * mayank@15th June, 2007
+   * remove old code
+   */
+  switch (abfd->direction)
+    {
+    case read_direction:
+    case no_direction:
+      bfd_set_error (bfd_error_invalid_operation);
+      return FALSE;
+
+    case write_direction:
+      break;
+
+    case both_direction:
+      /* File is opened for update. `output_has_begun' some time ago when
+	   the file was created.  Do not recompute sections sizes or alignments
+	   in _bfd_set_section_content.  */
+      abfd->output_has_begun = TRUE;
+      break;
+    }
+#endif
 
   /* Record a copy of the data in memory if desired.  */
   if (section->contents
@@ -1486,6 +1644,49 @@
 
 /*
 FUNCTION
+	_bfd_strip_section_from_output
+
+SYNOPSIS
+	void _bfd_strip_section_from_output
+	  (struct bfd_link_info *info, asection *section);
+
+DESCRIPTION
+	Remove @var{section} from the output.  If the output section
+	becomes empty, remove it from the output bfd.
+
+	This function won't actually do anything except twiddle flags
+	if called too late in the linking process, when it's not safe
+	to remove sections.
+*/
+void
+_bfd_strip_section_from_output (struct bfd_link_info *info, asection *s)
+{
+  asection *os;
+  asection *is;
+  bfd *abfd;
+
+  s->flags |= SEC_EXCLUDE;
+
+  /* If the section wasn't assigned to an output section, or the
+     section has been discarded by the linker script, there's nothing
+     more to do.  */
+  os = s->output_section;
+  if (os == NULL || os->owner == NULL)
+    return;
+
+  /* If the output section has other (non-excluded) input sections, we
+     can't remove it.  */
+  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
+    for (is = abfd->sections; is != NULL; is = is->next)
+      if (is->output_section == os && (is->flags & SEC_EXCLUDE) == 0)
+	return;
+
+  /* If the output section is empty, flag it for removal too.
+     See ldlang.c:strip_excluded_output_sections for the action.  */
+  os->flags |= SEC_EXCLUDE;
+}
+/*
+FUNCTION
 	bfd_generic_is_group_section
 
 SYNOPSIS
diff -ruNbB binutils-2.17/bfd/som.c binutils-2.17.sua/bfd/som.c
--- binutils-2.17/bfd/som.c	2005-11-20 20:21:06 +0100
+++ binutils-2.17.sua/bfd/som.c	2008-04-01 09:03:09 +0200
@@ -4448,7 +4448,8 @@
 som_print_symbol (bfd *abfd,
 		  void *afile,
 		  asymbol *symbol,
-		  bfd_print_symbol_type how)
+		  bfd_print_symbol_type how,
+		  asection *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/srec.c binutils-2.17.sua/bfd/srec.c
--- binutils-2.17/bfd/srec.c	2005-05-23 19:44:55 +0200
+++ binutils-2.17.sua/bfd/srec.c	2008-04-01 09:03:09 +0200
@@ -107,6 +107,35 @@
 #include "libiberty.h"
 #include "safe-ctype.h"
 
+static void srec_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
+static void srec_print_symbol
+ PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol *));
+static void srec_init PARAMS ((void));
+static bfd_boolean srec_mkobject PARAMS ((bfd *));
+static int srec_get_byte PARAMS ((bfd *, bfd_boolean *));
+static void srec_bad_byte PARAMS ((bfd *, unsigned int, int, bfd_boolean));
+static bfd_boolean srec_scan PARAMS ((bfd *));
+static const bfd_target *srec_object_p PARAMS ((bfd *));
+static const bfd_target *symbolsrec_object_p PARAMS ((bfd *));
+static bfd_boolean srec_read_section PARAMS ((bfd *, asection *, bfd_byte *));
+
+static bfd_boolean srec_write_record
+  PARAMS ((bfd *, unsigned int, bfd_vma, const bfd_byte *, const bfd_byte *));
+static bfd_boolean srec_write_header PARAMS ((bfd *));
+static bfd_boolean srec_write_symbols PARAMS ((bfd *));
+static bfd_boolean srec_new_symbol PARAMS ((bfd *, const char *, bfd_vma));
+static bfd_boolean srec_get_section_contents
+  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
+static bfd_boolean srec_set_arch_mach
+  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
+static bfd_boolean srec_set_section_contents
+  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
+static bfd_boolean internal_srec_write_object_contents PARAMS ((bfd *, int));
+static bfd_boolean srec_write_object_contents PARAMS ((bfd *));
+static bfd_boolean symbolsrec_write_object_contents PARAMS ((bfd *));
+static int srec_sizeof_headers PARAMS ((bfd *, bfd_boolean));
+static long srec_get_symtab_upper_bound PARAMS ((bfd *));
+static long srec_canonicalize_symtab PARAMS ((bfd *, asymbol **));
 
 /* Macros for converting between hex and binary.  */
 
@@ -1164,7 +1193,8 @@
 srec_print_symbol (bfd *abfd,
 		   void * afile,
 		   asymbol *symbol,
-		   bfd_print_symbol_type how)
+		   bfd_print_symbol_type how,
+     		   asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
@@ -1215,6 +1245,7 @@
 {
   "srec",			/* Name.  */
   bfd_target_srec_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* Target byte order.  */
   BFD_ENDIAN_UNKNOWN,		/* Target headers byte order.  */
   (HAS_RELOC | EXEC_P |		/* Object flags.  */
@@ -1270,6 +1301,7 @@
 {
   "symbolsrec",			/* Name.  */
   bfd_target_srec_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* Target byte order.  */
   BFD_ENDIAN_UNKNOWN,		/* Target headers byte order.  */
   (HAS_RELOC | EXEC_P |		/* Object flags.  */
diff -ruNbB binutils-2.17/bfd/stabs.c binutils-2.17.sua/bfd/stabs.c
--- binutils-2.17/bfd/stabs.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/stabs.c	2008-04-01 09:03:09 +0200
@@ -111,6 +111,8 @@
   bfd_size_type stridxs[1];
 };
 
+static struct bfd_hash_entry *stab_link_includes_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
 
 /* The function to create a new entry in the header file hash table.  */
 
@@ -725,7 +727,8 @@
 bfd_boolean
 _bfd_write_stab_strings (bfd *output_bfd, struct stab_info *sinfo)
 {
-  if (bfd_is_abs_section (sinfo->stabstr->output_section))
+  if (sinfo->stabstr->output_section == NULL
+  	|| bfd_is_abs_section (sinfo->stabstr->output_section))
     /* The section was discarded from the link.  */
     return TRUE;
 
diff -ruNbB binutils-2.17/bfd/syms.c binutils-2.17.sua/bfd/syms.c
--- binutils-2.17/bfd/syms.c	2005-05-04 17:53:39 +0200
+++ binutils-2.17.sua/bfd/syms.c	2008-04-01 09:03:09 +0200
@@ -1055,7 +1055,20 @@
 	      val = bfd_get_32 (abfd, info->stabs + r->address);
 	      val &= r->howto->src_mask;
 	      sym = *r->sym_ptr_ptr;
-	      val += sym->value + sym->section->vma + r->addend;
+
+	      /* I'm not sure about the use of partial_inplace
+		 below; the goal is that for COFF and related
+		 formats, the addend is meaningless.
+		 coff_slurp_relocation_table (that is,
+		 bfd_canonicalise_reloc) puts the wrong value for
+		 this use in the ->addend field.  It may be a bug
+		 there, but if so, it seems pretty intentional.
+
+		 For other relocations, the addend is calculated by
+		 ...rtype_to_howto, which doesn't make this mistake */
+
+	      val += sym->value + sym->section->vma + 
+		      r->howto->partial_inplace ? 0 : r->addend;
 	      bfd_put_32 (abfd, (bfd_vma) val, info->stabs + r->address);
 	    }
 	}
diff -ruNbB binutils-2.17/bfd/targets.c binutils-2.17.sua/bfd/targets.c
--- binutils-2.17/bfd/targets.c	2006-04-05 14:41:57 +0200
+++ binutils-2.17.sua/bfd/targets.c	2008-04-01 09:03:09 +0200
@@ -184,6 +184,12 @@
 .    the contents of a file.  *}
 .  enum bfd_flavour flavour;
 .
+. {* Input format: if the file format for input to the linker is not the same
+.    as the output format, then a pointer to the input format type goes here
+.    in the output format's record.  (This happens for PE/PEI, at least.) *}
+.
+.  const struct bfd_target *input_format;
+.
 .  {* The order of bytes within the data area of a file.  *}
 .  enum bfd_endian byteorder;
 .
@@ -368,7 +374,7 @@
 .  struct bfd_symbol *
 .              (*_bfd_make_empty_symbol) (bfd *);
 .  void        (*_bfd_print_symbol)
-.    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+.    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type, struct bfd_symbol *);
 .#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
 .  void        (*_bfd_get_symbol_info)
 .    (bfd *, struct bfd_symbol *, symbol_info *);
@@ -797,6 +803,7 @@
 extern const bfd_target hppabsd_core_vec;
 extern const bfd_target hpux_core_vec;
 extern const bfd_target irix_core_vec;
+extern const bfd_target interix_core_vec;
 extern const bfd_target netbsd_core_vec;
 extern const bfd_target osf_core_vec;
 extern const bfd_target ptrace_core_vec;
@@ -1174,6 +1181,9 @@
 #ifdef IRIX_CORE
 	&irix_core_vec,
 #endif
+#ifdef INTERIX_CORE
+	&interix_core_vec,
+#endif
 #ifdef NETBSD_CORE
 	&netbsd_core_vec,
 #endif
diff -ruNbB binutils-2.17/bfd/tekhex.c binutils-2.17.sua/bfd/tekhex.c
--- binutils-2.17/bfd/tekhex.c	2006-05-04 20:41:00 +0200
+++ binutils-2.17.sua/bfd/tekhex.c	2008-04-01 09:03:09 +0200
@@ -94,6 +94,40 @@
   (d)[1] = digs[(x) & 0xf]; \
   (d)[0] = digs[((x)>>4)&0xf];
 
+static void tekhex_init PARAMS ((void));
+static bfd_boolean
+getvalue (char **srcp, bfd_vma *valuep);
+static void tekhex_print_symbol
+ PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol *));
+static void tekhex_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
+static asymbol *tekhex_make_empty_symbol PARAMS ((bfd *));
+static int tekhex_sizeof_headers PARAMS ((bfd *, bfd_boolean));
+static bfd_boolean tekhex_write_object_contents PARAMS ((bfd *));
+static void out PARAMS ((bfd *, int, char *, char *));
+static void writesym PARAMS ((char **, const char *));
+static void writevalue PARAMS ((char **, bfd_vma));
+static bfd_boolean tekhex_set_section_contents
+ PARAMS ((bfd*, sec_ptr, const PTR, file_ptr, bfd_size_type));
+static bfd_boolean tekhex_set_arch_mach
+ PARAMS ((bfd *, enum bfd_architecture, unsigned long));
+static bfd_boolean tekhex_get_section_contents
+ PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
+static void move_section_contents
+ PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type, bfd_boolean));
+static const bfd_target *tekhex_object_p PARAMS ((bfd *));
+static bfd_boolean tekhex_mkobject PARAMS ((bfd *));
+static long tekhex_get_symtab_upper_bound PARAMS ((bfd *));
+static long tekhex_canonicalize_symtab PARAMS ((bfd *, asymbol **));
+static bfd_boolean
+pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *));
+
+static bfd_boolean
+first_phase (bfd *abfd, int type, char *src);
+
+static void insert_byte PARAMS ((bfd *, int, bfd_vma));
+static struct data_struct *find_chunk PARAMS ((bfd *, bfd_vma));
+static bfd_boolean
+getsym (char *dstp, char **srcp, unsigned int *lenp);
 /* Here's an example
    %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75
    %1B3709T_SEGMENT1108FFFFFFFF
@@ -398,7 +432,9 @@
 		return FALSE;
 	      if (!getvalue (&src, &val))
 		return FALSE;
-	      section->size = val - section->vma;
+	      if (!getvalue (&src, &section->size))
+			return FALSE;
+		section->size -=section->vma;
 	      section->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC;
 	      break;
 	    case '0':
@@ -889,7 +925,8 @@
 static void
 tekhex_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
 			asymbol *symbol,
-			symbol_info *ret)
+			symbol_info *ret
+			)
 {
   bfd_symbol_info (symbol, ret);
 }
@@ -898,7 +935,8 @@
 tekhex_print_symbol (bfd *abfd,
 		     void * filep,
 		     asymbol *symbol,
-		     bfd_print_symbol_type how)
+		     bfd_print_symbol_type how,
+		     asymbol *ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) filep;
 
@@ -952,6 +990,7 @@
 {
   "tekhex",			/* Name.  */
   bfd_target_tekhex_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* Target byte order.  */
   BFD_ENDIAN_UNKNOWN,		/* Target headers byte order.  */
   (EXEC_P |			/* Object flags.  */
diff -ruNbB binutils-2.17/bfd/versados.c binutils-2.17.sua/bfd/versados.c
--- binutils-2.17/bfd/versados.c	2005-05-23 19:44:55 +0200
+++ binutils-2.17.sua/bfd/versados.c	2008-04-01 09:03:09 +0200
@@ -721,7 +721,8 @@
 versados_print_symbol (bfd *abfd,
 		       void * afile,
 		       asymbol *symbol,
-		       bfd_print_symbol_type how)
+		       bfd_print_symbol_type how,
+		       asymbol * ignored ATTRIBUTE_UNUSED)
 {
   FILE *file = (FILE *) afile;
 
diff -ruNbB binutils-2.17/bfd/vms.c binutils-2.17.sua/bfd/vms.c
--- binutils-2.17/bfd/vms.c	2006-03-16 13:20:16 +0100
+++ binutils-2.17.sua/bfd/vms.c	2008-04-01 09:03:09 +0200
@@ -849,7 +849,8 @@
 vms_print_symbol (bfd * abfd,
 		  void * file,
 		  asymbol *symbol,
-		  bfd_print_symbol_type how)
+		  bfd_print_symbol_type how,
+		  asymbol *ignored ATTRIBUTE_UNUSED)
 {
 #if VMS_DEBUG
   vms_debug (1, "vms_print_symbol (%p, %p, %p, %d)\n", abfd, file, symbol, how);
diff -ruNbB binutils-2.17/binutils/bucomm.h binutils-2.17.sua/binutils/bucomm.h
--- binutils-2.17/binutils/bucomm.h	2006-02-09 12:49:53 +0100
+++ binutils-2.17.sua/binutils/bucomm.h	2008-04-01 09:03:09 +0200
@@ -78,7 +78,16 @@
 
 #ifdef HAVE_SBRK
 #if !HAVE_DECL_SBRK
-extern char *sbrk ();
+#if 0
+/*
+ * mayank@15th June, 2007
+ * configure doesnt detect sbrk, hence this prototype gets
+ * included which conflicts with the one in interix hence
+ * putting the correct prototype
+ */
+extern char * sbrk();
+#endif
+extern void *sbrk (intptr_t);
 #endif
 #endif
 
diff -ruNbB binutils-2.17/binutils/configure binutils-2.17.sua/binutils/configure
--- binutils-2.17/binutils/configure	2006-04-06 23:49:29 +0200
+++ binutils-2.17.sua/binutils/configure	2008-04-01 09:03:09 +0200
@@ -10893,7 +10893,7 @@
 }'
 fi
 
-DEFS=-DHAVE_CONFIG_H
+DEFS="-DHAVE_CONFIG_H -D_ALL_SOURCE"
 
 ac_libobjs=
 ac_ltlibobjs=
diff -ruNbB binutils-2.17/binutils/objdump.c binutils-2.17.sua/binutils/objdump.c
--- binutils-2.17/binutils/objdump.c	2006-04-12 15:05:36 +0200
+++ binutils-2.17.sua/binutils/objdump.c	2008-04-01 09:03:10 +0200
@@ -2467,19 +2467,20 @@
 static void
 dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean dynamic)
 {
+  asymbol **base;
   asymbol **current;
   long max;
   long count;
 
   if (dynamic)
     {
-      current = dynsyms;
+      base = current = dynsyms;
       max = dynsymcount;
       printf ("DYNAMIC SYMBOL TABLE:\n");
     }
   else
     {
-      current = syms;
+      base = current = syms;
       max = symcount;
       printf ("SYMBOL TABLE:\n");
     }
@@ -2513,14 +2514,19 @@
 		 bfd_print_symbol.  FIXME: This is a gross hack.  */
 	      alloc = demangle (cur_bfd, name);
 	      (*current)->name = alloc;
+/*
+ * mayank@15th June, 2007
+ * bfd_print_symbol takes extra parameter in old gcc3.3
+ * and hence this change
+ */
 	      bfd_print_symbol (cur_bfd, stdout, *current,
-				bfd_print_symbol_all);
+				bfd_print_symbol_all, *base);
 	      (*current)->name = name;
 	      free (alloc);
 	    }
 	  else
 	    bfd_print_symbol (cur_bfd, stdout, *current,
-			      bfd_print_symbol_all);
+			      bfd_print_symbol_all, *base);
 	  printf ("\n");
 	}
 
diff -ruNbB binutils-2.17/gas/as.c binutils-2.17.sua/gas/as.c
--- binutils-2.17/gas/as.c	2006-02-09 01:07:41 +0100
+++ binutils-2.17.sua/gas/as.c	2008-04-01 09:03:11 +0200
@@ -54,7 +54,7 @@
 
 #ifdef HAVE_SBRK
 #ifdef NEED_DECLARATION_SBRK
-extern PTR sbrk ();
+extern PTR sbrk (int incr);
 #endif
 #endif
 
diff -ruNbB binutils-2.17/gas/config/obj-coff.c binutils-2.17.sua/gas/config/obj-coff.c
--- binutils-2.17/gas/config/obj-coff.c	2005-11-07 18:57:00 +0100
+++ binutils-2.17.sua/gas/config/obj-coff.c	2008-04-01 09:03:12 +0200
@@ -1126,6 +1126,7 @@
       *input_line_pointer = c;
       SKIP_WHITESPACE ();
       S_SET_WEAK (symbolP);
+      S_SET_STORAGE_CLASS (symbolP, C_WEAKEXT);
 
       if (c == ',')
 	{
@@ -1301,7 +1302,8 @@
 		}
 	    }
 
-	  if (coff_last_function == 0 && SF_GET_FUNCTION (symp))
+	  if (coff_last_function == 0 && SF_GET_FUNCTION (symp)
+	      && S_IS_DEFINED (symp))
 	    {
 	      union internal_auxent *auxp;
 
@@ -1313,7 +1315,8 @@
 		      sizeof (auxp->x_sym.x_fcnary.x_ary.x_dimen));
 	    }
 
-	  if (S_GET_STORAGE_CLASS (symp) == C_EFCN)
+	  if (S_GET_STORAGE_CLASS (symp) == C_EFCN
+	      && S_IS_DEFINED (symp))
 	    {
 	      if (coff_last_function == 0)
 		as_fatal (_("C_EFCN symbol for %s out of scope"),
@@ -1476,6 +1479,7 @@
                                                  'x' for text
   						 'r' for read-only data
   						 's' for shared data (PE)
+						 'y' for nonreadable data
    But if the argument is not a quoted string, treat it as a
    subsegment number.
 
@@ -1492,6 +1496,8 @@
   unsigned int exp;
   flagword flags, oldflags;
   asection *sec;
+  bfd_boolean set_flags[sec_flag_last];
+  enum section_sec_flags flagval;
 
   if (flag_mri)
     {
@@ -1514,6 +1520,7 @@
   exp = 0;
   flags = SEC_NO_FLAGS;
 
+  memset(set_flags, 0, sizeof(set_flags));
   if (*input_line_pointer == ',')
     {
       ++input_line_pointer;
@@ -1584,6 +1591,7 @@
 		  if (! readonly_removed)
 		    flags |= SEC_READONLY;
 		  break;
+ 		case 'y': set_flags[sec_flag_NOREAD] = TRUE; break;
 
 		case 'i': /* STYP_INFO */
 		case 'l': /* STYP_LIB */
@@ -1623,6 +1631,13 @@
 	as_warn (_("error setting flags for \"%s\": %s"),
 		 bfd_section_name (stdoutput, sec),
 		 bfd_errmsg (bfd_get_error ()));
+      for (flagval=0; flagval < sec_flag_last; flagval++) 
+	{
+	  if (set_flags[flagval]) 
+	    {
+	      bfd_set_section_flag_value(bfd, sec, flagval);
+	    }
+        }
     }
   else if (flags != SEC_NO_FLAGS)
     {
@@ -1632,11 +1647,90 @@
 			     | SEC_DATA | SEC_COFF_SHARED | SEC_NEVER_LOAD);
       if ((flags ^ oldflags) & matchflags)
 	as_warn (_("Ignoring changed section attributes for %s"), name);
+      for (flagval=0; flagval < sec_flag_last; flagval++) 
+	{
+	  if (flagval == sec_flag_NOREAD   /* add more here */
+	  && set_flags[flagval] != bfd_section_flag_value(abfd, sec, flagval))
+	    {
+	      as_warn (_("Ignoring changed section attributes for %s"), name);
+	    }
+        }
     }
 
   demand_empty_rest_of_line ();
 }
 
+#ifdef TE_PE
+/* Parse .alias directives, which is how PE does weak symbols:
+   An alias defines a "weak" name for an exising symbol; it does
+   not label an entry point directly.  There are 3 types of PE
+   weak; we only support the alias form (IMAGE_WEAK_EXTERN_SEARCH_ALIAS)
+   
+   Syntax:   .alias <new weak name>,<old strong name>
+
+   */
+
+void obj_coff_alias PARAMS((int));
+
+void
+obj_coff_alias (ignore)
+     int ignore ATTRIBUTE_UNUSED;
+{
+  char *name;
+  int c;
+  symbolS *symbolP;
+  symbolS *symbolQ;
+  union internal_auxent *auxp;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+  symbolP = symbol_find_or_make (name);
+  *input_line_pointer = c;
+
+  symbolQ = NULL;
+
+  SKIP_WHITESPACE ();
+
+  if (*input_line_pointer == ',')
+    {
+      if (S_IS_DEFINED (symbolP))
+	{
+	  as_bad ("Ignoring attempt to redefine symbol `%s'.",
+		  S_GET_NAME (symbolP));
+	  ignore_rest_of_line ();
+	  return;
+	}
+
+      ++input_line_pointer;
+      SKIP_WHITESPACE ();
+      if (! is_end_of_line[(unsigned char) *input_line_pointer])
+	{
+  	  name = input_line_pointer;
+	  c = get_symbol_end ();
+  	  symbolQ = symbol_find_or_make (name);
+	  *input_line_pointer = c;
+	}
+    }
+
+  if (symbolQ == NULL)
+    {
+      as_bad ("No alias target for `%s'.",
+	      S_GET_NAME (symbolP));
+      ignore_rest_of_line();
+      return;
+    }
+
+  S_SET_NUMBER_AUXILIARY (symbolP, 1);
+  S_SET_WEAK (symbolP);
+
+  /* Set alias type to IMAGE_WEAK_EXTERN_SEARCH_ALIAS */
+  auxp = SYM_AUXENT(symbolP);
+  auxp->x_sym.x_misc.x_fsize = 3;
+  SA_SET_SYM_TAGNDX (symbolP, symbolQ);
+
+  demand_empty_rest_of_line ();
+}
+#endif
 void
 coff_adjust_symtab (void)
 {
@@ -1774,6 +1868,9 @@
 
 const pseudo_typeS coff_pseudo_table[] =
 {
+#ifdef TE_PE
+  {"alias", obj_coff_alias, 0},
+#endif
   {"ABORT", s_abort, 0},
   {"appline", obj_coff_ln, 1},
   /* We accept the .bss directive for backward compatibility with
diff -ruNbB binutils-2.17/gas/config/tc-i386.c binutils-2.17.sua/gas/config/tc-i386.c
--- binutils-2.17/gas/config/tc-i386.c	2006-04-07 08:40:57 +0200
+++ binutils-2.17.sua/gas/config/tc-i386.c	2008-04-01 09:03:12 +0200
@@ -43,6 +43,8 @@
 #define INFER_ADDR_PREFIX 1
 #endif
 
+#define RELOC_ENUM enum bfd_reloc_code_real
+
 #ifndef SCALE1_WHEN_NO_INDEX
 /* Specifying a scale factor besides 1 when there is no index is
    futile.  eg. `mov (%ebx,2),%al' does exactly the same as
@@ -421,10 +423,10 @@
   {"i286",	Cpu086|Cpu186|Cpu286 },
   {"i386",	Cpu086|Cpu186|Cpu286|Cpu386 },
   {"i486",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486 },
-  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586 },
-  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686 },
-  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586 },
-  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686 },
+  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
+  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
+  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
+  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
   {"pentiumii",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX },
   {"pentiumiii",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuMMX2|CpuSSE },
   {"pentium4",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuMMX2|CpuSSE|CpuSSE2 },
@@ -1330,7 +1332,17 @@
 #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
   if (!IS_ELF)
     return 1;
+#endif
+#ifdef TE_PE
+    /* External (and weak) symbols are always themselves in PE */
+    if (S_IS_EXTERNAL (fixP->fx_addsy)
+	|| S_IS_WEAK (fixP->fx_addsy))
+      {
+	return 0;
+      }
+#endif
 
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
   /* Don't adjust pc-relative references to merge sections in 64-bit
      mode.  */
   if (use_rela_relocations
@@ -3694,6 +3706,15 @@
 		  if (!object_64bit)
 		    {
 		      reloc_type = BFD_RELOC_386_GOTPC;
+#ifndef PUSHMI_PULLU
+                  /* Changing reloc type; compensate offsets.
+		     See long comment on GOTPC relocations below. */
+		  add += 4;
+#endif
+
+
+
+
 		      i.op[n].imms->X_add_number += add;
 		    }
 		  else if (reloc_type == BFD_RELOC_64)
@@ -3837,7 +3858,15 @@
 		    }
 
 		  if (!object_64bit)
+		{
 		    reloc_type = BFD_RELOC_386_GOTPC;
+#ifndef PUSHMI_PULLU
+                  /* Changing reloc type; compensate offsets.
+		     See long comment on GOTPC relocations below. */
+		  add += 4;
+#endif
+
+		}
 		  else if (size == 4)
 		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
 		  else if (size == 8)
@@ -3877,9 +3906,48 @@
   fix_new_exp (frag, off, len, exp, 0, r);
 }
 
-#if (!defined (OBJ_ELF) && !defined (OBJ_MAYBE_ELF)) || defined (LEX_AT)
-# define lex_got(reloc, adjust, types) NULL
-#else
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
+static const struct {
+  const char *str;
+  const int   len;
+  const bfd_boolean need_got;
+  const enum bfd_reloc_code_real rel[NUM_FLAG_CODE];
+} gotrel[] = {
+  { "PLT",      sizeof("PLT")-1,        TRUE,
+		{ BFD_RELOC_386_PLT32,      0, BFD_RELOC_X86_64_PLT32    } },
+  { "GOTOFF",   sizeof("GOTOFF")-1,     TRUE,
+		{ BFD_RELOC_386_GOTOFF,     0, 0                         } },
+  { "GOTPCREL", sizeof("GOTPCREL")-1,   TRUE,
+		{ 0,                        0, BFD_RELOC_X86_64_GOTPCREL } },
+  { "TLSGD",    sizeof("TLSGD")-1,      TRUE,
+		{ BFD_RELOC_386_TLS_GD,     0, BFD_RELOC_X86_64_TLSGD    } },
+  { "TLSLDM",   sizeof("TLSLDM")-1,     TRUE,
+		{ BFD_RELOC_386_TLS_LDM,    0, 0                         } },
+  { "TLSLD",    sizeof("TLSLD")-1,      TRUE,
+		{ 0,                        0, BFD_RELOC_X86_64_TLSLD    } },
+  { "GOTTPOFF", sizeof("GOTTPOFF")-1,   TRUE,
+		{ BFD_RELOC_386_TLS_IE_32,  0, BFD_RELOC_X86_64_GOTTPOFF } },
+  { "TPOFF",    sizeof("TPOFF")-1,      TRUE,
+		{ BFD_RELOC_386_TLS_LE_32,  0, BFD_RELOC_X86_64_TPOFF32  } },
+  { "NTPOFF",   sizeof("NTPOFF")-1,     TRUE,
+		{ BFD_RELOC_386_TLS_LE,     0, 0                         } },
+  { "DTPOFF",   sizeof("DTOPFF")-1,     TRUE,
+		{ BFD_RELOC_386_TLS_LDO_32, 0, BFD_RELOC_X86_64_DTPOFF32 } },
+  { "GOTNTPOFF",sizeof("GOTNTPOFF")-1,  TRUE,
+		{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         } },
+  { "INDNTPOFF",sizeof("INDNTPOFF")-1,  TRUE,
+		{ BFD_RELOC_386_TLS_IE,     0, 0                         } },
+  { "GOT",      sizeof("GOT")-1,        TRUE,
+		{ BFD_RELOC_386_GOT32,      0, BFD_RELOC_X86_64_GOT32    } },
+#ifdef TE_PE_DYN
+  { "IMAGEBASE",sizeof("IMAGE_BASE")-1, FALSE,
+		{ BFD_RELOC_RVA,            0, 0 /* add when needed */   } },
+#endif
+};
+
+static const char * const mode_name[NUM_FLAG_CODE] = { "32", "16", "64" };
+
+
 /* Parse operands of the form
    <symbol>@GOTOFF+<nnn>
    and similar .plt or .got references.
@@ -3894,6 +3962,7 @@
      int *adjust,
      unsigned int *types)
 {
+#if 0
   /* Some of the relocations depend on the size of what field is to
      be relocated.  But in our callers i386_immediate and i386_displacement
      we don't yet know the operand size (this will be set by insn
@@ -3922,22 +3991,38 @@
     { "TLSDESC",  { BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_X86_64_GOTPC32_TLSDESC }, Imm32|Imm32S|Disp32 },
     { "TLSCALL",  { BFD_RELOC_386_TLS_DESC_CALL, BFD_RELOC_X86_64_TLSDESC_CALL }, Imm32|Imm32S|Disp32 }
   };
-  char *cp;
+#endif
+  char *cp, *cp2;
   unsigned int j;
 
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+
   if (!IS_ELF)
     return NULL;
+#endif
+  cp = NULL;
 
-  for (cp = input_line_pointer; *cp != '@'; cp++)
-    if (is_end_of_line[(unsigned char) *cp])
+   /* Find the last @ in this identifier; if LEX_AT is on, we can
+      get things like foo@8@PLT (for _cdecl foo(int,int), e.g.). */
+  for (cp2 = input_line_pointer; ;cp2++)
+    {
+      if (*cp2 == '@') 
+	{
+	  cp = cp2;
+	}
+      if (!is_part_of_name((unsigned char) *cp2))
+	{
+	  if (cp == NULL)
       return NULL;
+	  else
+	     break;
+	 }
+    }
 
   for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
     {
-      int len;
 
-      len = strlen (gotrel[j].str);
-      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
+      if (strncasecmp (cp + 1, gotrel[j].str, gotrel[j].len) == 0)
 	{
 	  if (gotrel[j].rel[object_64bit] != 0)
 	    {
@@ -3946,17 +4031,20 @@
 
 	      *reloc = gotrel[j].rel[object_64bit];
 	      if (adjust)
-		*adjust = len;
+		*adjust = gotrel[j].len;
 
 	      if (types)
 		{
 		  if (flag_code != CODE_64BIT)
 		    *types = Imm32|Disp32;
+#if 0
+		  //Mayank
 		  else
 		    *types = gotrel[j].types64;
+#endif
 		}
 
-	      if (GOT_symbol == NULL)
+	      if (GOT_symbol == NULL && gotrel[j].need_got)
 		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
 
 	      /* Replace the relocation token with ' ', so that
@@ -3968,7 +4056,7 @@
 	      /* The second part goes from after the reloc token until
 		 (and including) an end_of_line char.  Don't use strlen
 		 here as the end_of_line char may not be a NUL.  */
-	      past_reloc = cp + 1 + len;
+	      past_reloc = cp + 1 + gotrel[j].len;
 	      for (cp = past_reloc; !is_end_of_line[(unsigned char) *cp++]; )
 		;
 	      second = cp - past_reloc;
@@ -3993,6 +4081,67 @@
   return NULL;
 }
 
+#ifdef RECOGNIZE_AT_GOT_ANYWAY
+/* If we're overloading the @ as both an ordinary character and a 
+   separator for modifiers, we have to recheck identifiers in expressions
+   to get the parse to stop in the right place. (This is md_parse_name.) */
+
+int
+i386_parse_name (name, exprP, nextcharP)
+     char *name;
+     expressionS *exprP ATTRIBUTE_UNUSED;
+     char *nextcharP ATTRIBUTE_UNUSED;
+{
+  char *cp, *cp2;
+  unsigned int j;
+
+  cp = NULL;
+   /* Find the last @ in this identifier; if LEX_AT is on, we can
+      get things like foo@8@PLT (for _cdecl foo(int,int), e.g.). */
+ 
+  for (cp2 = name; ;cp2++) {
+    if (*cp2 == '@') 
+      {
+        cp = cp2;
+      }
+    if (!is_part_of_name((unsigned char) *cp2))
+      {
+	if (cp == NULL)
+ 	   return 0;
+ 	else
+ 	   break;
+       }
+  }
+
+  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
+    {
+      if (strncasecmp (cp + 1, gotrel[j].str, gotrel[j].len) == 0)
+	{
+	  if (gotrel[j].rel[(unsigned int) flag_code] != 0)
+	    {
+	      /* We've found an acceptable addressing modifier; record
+		 that in the expr we're building. */
+              i.reloc[this_operand] = gotrel[j].rel[(unsigned int) flag_code];
+
+	      /* Make sure we have a GOT now that we need it. */
+	      if (GOT_symbol == NULL && gotrel[j].need_got)
+		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
+
+	      /* We shorten "name" to be just the interesting part, but
+		 don't otherwise change anything in the parse. */
+	      *cp = '\0';
+
+	      return 0;
+	    }
+
+	  as_bad (_("@%s reloc is not supported in %s bit mode"),
+		  gotrel[j].str, mode_name[(unsigned int) flag_code]);
+	  return 0;
+	}
+    }
+    return 0;
+}
+#endif 
 void
 x86_cons (exp, size)
      expressionS *exp;
@@ -4065,7 +4213,9 @@
      char *imm_start;
 {
   char *save_input_line_pointer;
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
   char *gotfree_input_line;
+#endif
   segT exp_seg = 0;
   expressionS *exp;
   unsigned int types = ~0U;
@@ -4085,9 +4235,11 @@
   save_input_line_pointer = input_line_pointer;
   input_line_pointer = imm_start;
 
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
   gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
   if (gotfree_input_line)
     input_line_pointer = gotfree_input_line;
+#endif
 
   exp_seg = expression (exp);
 
@@ -4204,7 +4356,10 @@
   expressionS *exp;
   segT exp_seg = 0;
   char *save_input_line_pointer;
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
   char *gotfree_input_line;
+#endif
+
   int bigdisp, override;
   unsigned int types = Disp;
 
@@ -4296,9 +4451,11 @@
       *displacement_string_end = '0';
     }
 #endif
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
   gotfree_input_line = lex_got (&i.reloc[this_operand], NULL, &types);
   if (gotfree_input_line)
     input_line_pointer = gotfree_input_line;
+#endif
 
   exp_seg = expression (exp);
 
@@ -4310,8 +4467,10 @@
 #endif
   RESTORE_END_STRING (disp_end);
   input_line_pointer = save_input_line_pointer;
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
   if (gotfree_input_line)
     free (gotfree_input_line);
+#endif
 
   /* We do this to make sure that the section symbol is in
      the symbol table.  We will ultimately change the relocation
@@ -4790,8 +4949,12 @@
      an externally visible symbol, because it may be overridden by a
      shared library.  */
   if (S_GET_SEGMENT (fragP->fr_symbol) != segment
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-      || (IS_ELF
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
+#if defined (TE_PE)  /* Coded this way for patch maintainablity only! */
+      || (TRUE
+#else
+      || (OUTPUT_FLAVOR == bfd_target_elf_flavour
+#endif
 	  && (S_IS_EXTERNAL (fragP->fr_symbol)
 	      || S_IS_WEAK (fragP->fr_symbol)))
 #endif
@@ -5079,32 +5242,33 @@
 
   if (fixP->fx_addsy != NULL
       && (fixP->fx_r_type == BFD_RELOC_32_PCREL
+#ifdef TE_PE_DYN
+          || fixP->fx_r_type == BFD_RELOC_386_PLT32
+#endif
 	  || fixP->fx_r_type == BFD_RELOC_64_PCREL
 	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
 	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
-      && !use_rela_relocations)
+      && !use_rela_relocations
+      && EXTERN_FORCE_RELOC)
     {
+      segT sym_seg;
+
+      value += md_pcrel_from (fixP);
       /* This is a hack.  There should be a better way to handle this.
 	 This covers for the fact that bfd_install_relocation will
 	 subtract the current location (for partial_inplace, PC relative
 	 relocations); see more below.  */
-#ifndef OBJ_AOUT
-      if (IS_ELF
-#ifdef TE_PE
-	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
-#endif
-	  )
-	value += fixP->fx_where + fixP->fx_frag->fr_address;
-#endif
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-      if (IS_ELF)
-	{
-	  segT sym_seg = S_GET_SEGMENT (fixP->fx_addsy);
+      sym_seg = S_GET_SEGMENT (fixP->fx_addsy);
+#ifndef TE_PE
+      /* For some reason, the PE format does not ever store a section
+	 address offset for a PC relative symbol.  */
 
 	  if ((sym_seg == seg
 	       || (symbol_section_p (fixP->fx_addsy)
 		   && sym_seg != absolute_section))
 	      && !generic_force_reloc (fixP))
+#endif
+
 	    {
 	      /* Yes, we add the values in twice.  This is because
 		 bfd_install_relocation subtracts them out again.  I think
@@ -5113,29 +5277,40 @@
 	      value += fixP->fx_where + fixP->fx_frag->fr_address;
 	    }
 	}
-#endif
-#if defined (OBJ_COFF) && defined (TE_PE)
-      /* For some reason, the PE format does not store a
-	 section address offset for a PC relative symbol.  */
-      if (S_GET_SEGMENT (fixP->fx_addsy) != seg
-	  || S_IS_WEAK (fixP->fx_addsy))
-	value += md_pcrel_from (fixP);
-#endif
-    }
 
   /* Fix a few things - the dynamic linker expects certain values here,
      and we must not disappoint it.  */
-#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE_DYN) /* [ */
   if (IS_ELF && fixP->fx_addsy)
     switch (fixP->fx_r_type)
       {
       case BFD_RELOC_386_PLT32:
+#ifdef TE_PE_DYN
+       /* We already took care of this above for PE */
+       break;
+#endif
       case BFD_RELOC_X86_64_PLT32:
 	/* Make the jump instruction point to the address of the operand.  At
 	   runtime we merely add the offset to the actual PLT entry.  */
 	value = -4;
 	break;
 
+#ifdef TE_PE_DYN
+      case BFD_RELOC_32:
+	/* On PE, to get the right value in the .o file, we need to fake out 
+	   _bfd_install_relocaction, see above.
+	   In this case, we're looking to see if this might be transformed
+	   into a GOTPC, later*/
+	if (GOT_symbol == NULL || fixP->fx_addsy != GOT_symbol)
+	    break;
+	/* drop thru */
+      case BFD_RELOC_386_GOTPC:   /* Can this ever happen? */
+	/* On PE, to get the right value in the .o file, we need to fake out
+	   _bfd_install_relocaction, see above.  */
+	value += fixP->fx_where + fixP->fx_frag->fr_address;
+	break;
+#endif
+
       case BFD_RELOC_386_TLS_GD:
       case BFD_RELOC_386_TLS_LDM:
       case BFD_RELOC_386_TLS_IE_32:
@@ -5369,6 +5544,8 @@
   return r;
 }
 
+#if 0
+//mayank
 int
 i386_parse_name (char *name, expressionS *e, char *nextcharP)
 {
@@ -5390,6 +5567,7 @@
   return 0;
 }
 
+#endif
 void
 md_operand (expressionS *e)
 {
@@ -5885,7 +6063,20 @@
       rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
       assert (rel->howto != NULL);
     }
-
+#ifdef STRICT_PE_FORMAT
+  /*
+   * Ohhh, this is ugly.  The problem is that if this is a local global
+   * symbol, the relocation will entirely be performed at link time, not
+   * at assembly time.  bfd_install_reloc doesn't know about this sort
+   * of thing, and as a result we need to fake it out here.
+   *
+   * Note that if you change this as part of cleaning up the apalling
+   * mess of complementary adds/subtracts of which this is part, that
+   * bfd:coff_i386_reloc may need attention too.
+   */
+  if (S_IS_EXTERN (fixp->fx_addsy) && !S_IS_COMMON(fixp->fx_addsy))
+    rel->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
+#endif
   return rel;
 }
 
diff -ruNbB binutils-2.17/gas/config/tc-i386.h binutils-2.17.sua/gas/config/tc-i386.h
--- binutils-2.17/gas/config/tc-i386.h	2006-02-27 16:35:37 +0100
+++ binutils-2.17.sua/gas/config/tc-i386.h	2008-04-01 09:03:12 +0200
@@ -391,15 +391,22 @@
 #define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
 #endif
 
-#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (LEX_AT)
+#if !defined(LEX_AT) || defined(RECOGNIZE_AT_GOT_ANYWAY)
 #define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
 extern void x86_cons PARAMS ((expressionS *, int));
-#endif
 
 #define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
 extern void x86_cons_fix_new
   PARAMS ((fragS *, unsigned int, unsigned int, expressionS *));
 
+#ifdef RECOGNIZE_AT_GOT_ANYWAY
+#define md_parse_name(name, exprP, m, nextcharP) \
+  i386_parse_name ((name), (exprP), (nextcharP))
+int i386_parse_name PARAMS ((char *name,
+			   expressionS *exprP,
+			   char *nextchar));
+#endif
+#endif
 #define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */
 
 #define NO_RELOC BFD_RELOC_NONE
@@ -438,8 +445,10 @@
    || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC		\
    || TC_FORCE_RELOCATION (FIX))
 
+#if 0
 extern int i386_parse_name (char *, expressionS *, char *);
 #define md_parse_name(s, e, m, c) i386_parse_name (s, e, c)
+#endif
 
 extern const struct relax_type md_relax_table[];
 #define TC_GENERIC_RELAX_TABLE md_relax_table
diff -ruNbB binutils-2.17/gas/config/te-interix.h binutils-2.17.sua/gas/config/te-interix.h
--- binutils-2.17/gas/config/te-interix.h	2000-05-14 20:53:18 +0200
+++ binutils-2.17.sua/gas/config/te-interix.h	2008-04-01 09:03:12 +0200
@@ -1,6 +1,7 @@
 #define TE_PE_DYN /* PE with dynamic linking (UNIX shared lib) support */
 #define TE_PE
 #define LEX_AT 1 /* can have @'s inside labels */
+#define RECOGNIZE_AT_GOT_ANYWAY   /* @GOTOFF, etc, still apply! */
 #define LEX_QM 3 /* can have ?'s in or begin labels */
 
 /* The PE format supports long section names.  */
@@ -13,4 +14,5 @@
 #define LOCAL_LABELS_FB 1
 #endif
 
+#define STRICT_PE_FORMAT
 #include "obj-format.h"
diff -ruNbB binutils-2.17/gas/configure binutils-2.17.sua/gas/configure
--- binutils-2.17/gas/configure	2006-04-06 23:49:31 +0200
+++ binutils-2.17.sua/gas/configure	2008-04-01 09:03:13 +0200
@@ -11208,7 +11208,7 @@
 }'
 fi
 
-DEFS=-DHAVE_CONFIG_H
+DEFS="-DHAVE_CONFIG_H -D_ALL_SOURCE"
 
 ac_libobjs=
 ac_ltlibobjs=
diff -ruNbB binutils-2.17/gas/symbols.c binutils-2.17.sua/gas/symbols.c
--- binutils-2.17/gas/symbols.c	2006-01-09 18:14:40 +0100
+++ binutils-2.17.sua/gas/symbols.c	2008-04-01 09:03:13 +0200
@@ -1987,6 +1987,11 @@
 			  && name[0] == '?'
 			  && name[1] == '?')))));
 }
+int
+S_IS_EXTERN (symbolS *s)
+{
+  return S_IS_EXTERNAL (s);
+}
 
 int
 S_IS_STABD (symbolS *s)
diff -ruNbB binutils-2.17/gas/symbols.h binutils-2.17.sua/gas/symbols.h
--- binutils-2.17/gas/symbols.h	2005-12-22 18:05:40 +0100
+++ binutils-2.17.sua/gas/symbols.h	2008-04-01 09:03:13 +0200
@@ -84,6 +84,7 @@
 
 extern int S_IS_FUNCTION (symbolS *);
 extern int S_IS_EXTERNAL (symbolS *);
+extern int S_IS_EXTERN (symbolS *);
 extern int S_IS_WEAK (symbolS *);
 extern int S_IS_WEAKREFR (symbolS *);
 extern int S_IS_WEAKREFD (symbolS *);
diff -ruNbB binutils-2.17/include/bfdlink.h binutils-2.17.sua/include/bfdlink.h
--- binutils-2.17/include/bfdlink.h	2006-04-06 20:52:45 +0200
+++ binutils-2.17.sua/include/bfdlink.h	2008-04-01 09:03:28 +0200
@@ -127,7 +127,10 @@
 	{
 	  struct bfd_link_hash_entry *next;
 	  struct bfd_link_hash_entry *link;	/* Real symbol.  */
+	  union {
 	  const char *warning;	/* Warning (bfd_link_hash_warning only).  */
+	      bfd_boolean alias;		/* Alias flag (..._indirect only). */
+	  }info;
 	} i;
       /* bfd_link_hash_common.  */
       struct
diff -ruNbB binutils-2.17/include/coff/internal.h binutils-2.17.sua/include/coff/internal.h
--- binutils-2.17/include/coff/internal.h	2006-02-05 12:57:34 +0100
+++ binutils-2.17.sua/include/coff/internal.h	2008-04-01 09:03:28 +0200
@@ -84,6 +84,7 @@
  	F_AR32W		file is 32-bit big-endian
  	F_DYNLOAD	rs/6000 aix: dynamically loadable w/imports & exports
  	F_SHROBJ	rs/6000 aix: file is a shared object
+ 	F_SHRLIB	DYNAMIC_LINKING: shared library
         F_DLL           PE format DLL.  */
 
 #define	F_RELFLG	(0x0001)
@@ -96,6 +97,7 @@
 #define	F_DYNLOAD	(0x1000)
 #define	F_SHROBJ	(0x2000)
 #define F_DLL           (0x2000)
+#define	F_SHRLIB	(0x4000)
 
 /* Extra structure which is used in the optional header.  */
 typedef struct _IMAGE_DATA_DIRECTORY 
@@ -625,6 +627,20 @@
 #define R_PARTLS16      32
 #define R_PARTMS8       33
 
+/* For interix, these collied and will have to be renumbered at
+   some point, but that requires breaking binary compatability */
+
+/* These must be in the same order as the corr. BFD_RELOC_386... symbols */
+#define R_GNU_GOT32     030  /* 24 */
+#define R_GNU_PLT32     031
+#define R_GNU_COPY      032
+#define R_GNU_GLOB_DAT  033
+#define R_GNU_JUMP_SLOT 034
+#define R_GNU_RELATIVE  035
+#define R_GNU_GOTOFF    036
+#define R_GNU_GOTPC     037
+
+
 #define R_PCR16L       128
 #define R_PCR26L       129
 #define R_VRT16        130
diff -ruNbB binutils-2.17/ld/configure binutils-2.17.sua/ld/configure
--- binutils-2.17/ld/configure	2006-04-11 12:36:26 +0200
+++ binutils-2.17.sua/ld/configure	2008-04-01 09:03:29 +0200
@@ -9877,7 +9877,7 @@
 }'
 fi
 
-DEFS=-DHAVE_CONFIG_H
+DEFS="-DHAVE_CONFIG_H -D_ALL_SOURCE"
 
 ac_libobjs=
 ac_ltlibobjs=
diff -ruNbB binutils-2.17/ld/emulparams/i386pe_posix.sh binutils-2.17.sua/ld/emulparams/i386pe_posix.sh
--- binutils-2.17/ld/emulparams/i386pe_posix.sh	2004-09-28 21:14:28 +0200
+++ binutils-2.17.sua/ld/emulparams/i386pe_posix.sh	2008-04-01 09:03:29 +0200
@@ -8,3 +8,4 @@
 EXECUTABLE_NAME=a.out
 INITIAL_SYMBOL_CHAR=\"_\"
 TARGET_PAGE_SIZE=0x1000
+GENERATE_SHLIB_SCRIPT=1
diff -ruNbB binutils-2.17/ld/emultempl/beos.em binutils-2.17.sua/ld/emultempl/beos.em
--- binutils-2.17/ld/emultempl/beos.em	2005-11-17 01:10:05 +0100
+++ binutils-2.17.sua/ld/emultempl/beos.em	2008-04-01 09:03:29 +0200
@@ -722,7 +722,7 @@
      The sections still have to be sorted, but that has to wait until
      all such sections have been processed by us.  The sorting is done by
      sort_sections.  */
-  lang_add_section (&l->wild_statement.children, s, os);
+  lang_add_section (&l->wild_statement.children, s, os, FALSE);
 
   return TRUE;
 }
diff -ruNbB binutils-2.17/ld/emultempl/elf32.em binutils-2.17.sua/ld/emultempl/elf32.em
--- binutils-2.17/ld/emultempl/elf32.em	2006-06-12 15:05:04 +0200
+++ binutils-2.17.sua/ld/emultempl/elf32.em	2008-04-01 09:03:29 +0200
@@ -1461,7 +1461,7 @@
 	     If the section already exists but does not have any flags
 	     set, then it has been created by the linker, probably as a
 	     result of a --section-start command line switch.  */
-	  lang_add_section (&os->children, s, os);
+	  lang_add_section (&os->children, s, os, FALSE);
 	  return TRUE;
 	}
     }
diff -ruNbB binutils-2.17/ld/emultempl/hppaelf.em binutils-2.17.sua/ld/emultempl/hppaelf.em
--- binutils-2.17/ld/emultempl/hppaelf.em	2005-11-17 01:10:05 +0100
+++ binutils-2.17.sua/ld/emultempl/hppaelf.em	2008-04-01 09:03:29 +0200
@@ -198,7 +198,7 @@
 
   info.input_section = input_section;
   lang_list_init (&info.add);
-  lang_add_section (&info.add, stub_sec, os);
+  lang_add_section (&info.add, stub_sec, os, FALSE);
 
   if (info.add.head == NULL)
     goto err_ret;
diff -ruNbB binutils-2.17/ld/emultempl/mmo.em binutils-2.17.sua/ld/emultempl/mmo.em
--- binutils-2.17/ld/emultempl/mmo.em	2005-11-17 01:10:05 +0100
+++ binutils-2.17.sua/ld/emultempl/mmo.em	2008-04-01 09:03:29 +0200
@@ -63,7 +63,7 @@
      (regardless of whether the linker script lists it as input).  */
   if (os != NULL)
     {
-      lang_add_section (&os->children, s, os);
+      lang_add_section (&os->children, s, os, FALSE);
       return TRUE;
     }
 
diff -ruNbB binutils-2.17/ld/emultempl/pe.em binutils-2.17.sua/ld/emultempl/pe.em
--- binutils-2.17/ld/emultempl/pe.em	2005-11-24 07:02:08 +0100
+++ binutils-2.17.sua/ld/emultempl/pe.em	2008-04-01 09:03:29 +0200
@@ -109,6 +109,30 @@
 #define PE_DEF_FILE_ALIGNMENT		0x00000200
 #endif
 
+static void gld_${EMULATION_NAME}_set_symbols PARAMS ((void));
+static void gld_${EMULATION_NAME}_after_open PARAMS ((void));
+static void gld_${EMULATION_NAME}_before_parse PARAMS ((void));
+static void gld_${EMULATION_NAME}_after_parse PARAMS ((void));
+static void gld_${EMULATION_NAME}_before_allocation PARAMS ((void));
+static bfd_boolean gld_${EMULATION_NAME}_place_orphan
+  PARAMS ((asection *));
+static char *gld_${EMULATION_NAME}_get_script PARAMS ((int *));
+static int gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
+static void gld_${EMULATION_NAME}_finish PARAMS ((void));
+static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
+  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
+static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
+static void set_pe_name PARAMS ((char *, long));
+static void set_pe_subsystem PARAMS ((void));
+static void set_pe_value PARAMS ((char *));
+static void set_pe_stack_heap PARAMS ((char *, char *));
+static void gld_${EMULATION_NAME}_check_needed
+  PARAMS ((lang_input_statement_type *));
+static void gld_${EMULATION_NAME}_stat_needed
+  PARAMS ((lang_input_statement_type *));
+static bfd_boolean gld_${EMULATION_NAME}_search_needed
+  PARAMS ((const char *, const char *));
+static bfd_boolean gld_${EMULATION_NAME}_try_needed PARAMS ((const char *));
 
 static struct internal_extra_pe_aouthdr pe;
 static int dll;
@@ -148,6 +172,11 @@
   lang_default_entry ("${ENTRY}");
 #endif
 #endif
+#ifdef TARGET_IS_i386pe_posix // ????
+  config.has_shared = TRUE;
+#endif
+  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
+
 }
 
 /* PE format extra command line options.  */
@@ -194,6 +223,52 @@
 #define OPTION_LARGE_ADDRESS_AWARE \
 					(OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC + 1)
 
+
+static struct option longopts[] = {
+  /* PE options */
+  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
+  {"dll", no_argument, NULL, OPTION_DLL},
+  {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
+  {"heap", required_argument, NULL, OPTION_HEAP},
+  {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
+  {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
+  {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
+  {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
+  {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
+  {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
+  {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
+  {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
+  {"stack", required_argument, NULL, OPTION_STACK},
+  {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
+  {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
+  {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
+#ifdef DLL_SUPPORT
+  /* getopt allows abbreviations, so we do this to stop it from treating -o
+     as an abbreviation for this option */
+  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
+  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
+  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
+  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
+  {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},	
+  {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
+  {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
+  {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
+  {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
+  {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
+  {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
+  {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
+  {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
+  {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
+  {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
+  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
+  {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
+  {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
+  {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
+#endif
+  {NULL, no_argument, NULL, 0}
+};
+
+
 static void
 gld${EMULATION_NAME}_add_options
   (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
@@ -505,6 +580,160 @@
 }
 
 
+static int
+gld_${EMULATION_NAME}_parse_args(int argc, char **argv)
+{
+  int longind;
+  int optc;
+  int prevoptind = optind;
+  int prevopterr = opterr;
+  int wanterror;
+  static int lastoptind = -1;
+
+  if (lastoptind != optind)
+    opterr = 0;
+  wanterror = opterr;
+
+  lastoptind = optind;
+
+  /* don't allow single-character abbreviations of any of these; too
+     likely to conflict with "real" single character options.  (It
+     really happens with -d.) */
+  optc = getopt_long_only (argc, argv, "-bdfhims", longopts, &longind);
+  opterr = prevopterr;
+
+  switch (optc)
+    {
+    default:
+    case 'b':
+    case 'd':
+    case 'f':
+    case 'h':
+    case 'i':
+    case 'm':
+    case 's':
+      if (wanterror)
+	xexit (1);
+      optind =  prevoptind;
+      return 0;
+
+    case OPTION_BASE_FILE:
+      link_info.base_file = (PTR) fopen (optarg, FOPEN_WB);
+      if (link_info.base_file == NULL)
+	{
+	  /* xgettext:c-format */
+	  fprintf (stderr, _("%s: Can't open base file %s\n"),
+		   program_name, optarg);
+	  xexit (1);
+	}
+      break;
+
+      /* PE options */
+    case OPTION_HEAP:
+      set_pe_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
+      break;
+    case OPTION_STACK:
+      set_pe_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
+      break;
+    case OPTION_SUBSYSTEM:
+      set_pe_subsystem ();
+      break;
+    case OPTION_MAJOR_OS_VERSION:
+      set_pe_value ("__major_os_version__");
+      break;
+    case OPTION_MINOR_OS_VERSION:
+      set_pe_value ("__minor_os_version__");
+      break;
+    case OPTION_MAJOR_SUBSYSTEM_VERSION:
+      set_pe_value ("__major_subsystem_version__");
+      break;
+    case OPTION_MINOR_SUBSYSTEM_VERSION:
+      set_pe_value ("__minor_subsystem_version__");
+      break;
+    case OPTION_MAJOR_IMAGE_VERSION:
+      set_pe_value ("__major_image_version__");
+      break;
+    case OPTION_MINOR_IMAGE_VERSION:
+      set_pe_value ("__minor_image_version__");
+      break;
+    case OPTION_FILE_ALIGNMENT:
+      set_pe_value ("__file_alignment__");
+      break;
+    case OPTION_SECTION_ALIGNMENT:
+      set_pe_value ("__section_alignment__");
+      break;
+    case OPTION_DLL:
+      set_pe_name ("__dll__", 1);
+      break;
+    case OPTION_IMAGE_BASE:
+      set_pe_value ("__image_base__");
+      break;
+    case OPTION_SUPPORT_OLD_CODE:
+      support_old_code = 1;
+      break;
+    case OPTION_THUMB_ENTRY:
+      thumb_entry_symbol = optarg;
+      break;
+#ifdef DLL_SUPPORT
+    case OPTION_OUT_DEF:
+      pe_out_def_filename = xstrdup (optarg);
+      break;
+    case OPTION_EXPORT_ALL:
+      pe_dll_export_everything = 1;
+      break;
+    case OPTION_EXCLUDE_SYMBOLS:
+      pe_dll_add_excludes (optarg, 0);
+      break;
+    case OPTION_EXCLUDE_LIBS:
+      pe_dll_add_excludes (optarg, 1);
+      break;
+    case OPTION_KILL_ATS:
+      pe_dll_kill_ats = 1;
+      break;
+    case OPTION_STDCALL_ALIASES:
+      pe_dll_stdcall_aliases = 1;
+      break;
+    case OPTION_ENABLE_STDCALL_FIXUP:
+      pe_enable_stdcall_fixup = 1;
+      break;
+    case OPTION_DISABLE_STDCALL_FIXUP:
+      pe_enable_stdcall_fixup = 0;
+      break;
+    case OPTION_IMPLIB_FILENAME:
+      pe_implib_filename = xstrdup (optarg);
+      break;
+    case OPTION_WARN_DUPLICATE_EXPORTS:
+      pe_dll_warn_dup_exports = 1;
+      break;
+    case OPTION_IMP_COMPAT:
+      pe_dll_compat_implib = 1;
+      break;
+    case OPTION_ENABLE_AUTO_IMAGE_BASE:
+      pe_enable_auto_image_base = 1;
+      break;
+    case OPTION_DISABLE_AUTO_IMAGE_BASE:
+      pe_enable_auto_image_base = 0;
+      break;
+    case OPTION_DLL_SEARCH_PREFIX:
+      pe_dll_search_prefix = xstrdup( optarg );
+      break;
+    case OPTION_NO_DEFAULT_EXCLUDES:
+      pe_dll_do_default_excludes = 0;
+      break;
+    case OPTION_DLL_ENABLE_AUTO_IMPORT:
+      link_info.pei386_auto_import = 1;
+      break;
+    case OPTION_DLL_DISABLE_AUTO_IMPORT:
+      link_info.pei386_auto_import = 0;
+      break;
+    case OPTION_ENABLE_EXTRA_PE_DEBUG:
+      pe_dll_extra_pe_debug = 1;
+      break;
+#endif
+    }
+  return 1;
+}
+
 static bfd_boolean
 gld${EMULATION_NAME}_handle_option (int optc)
 {
@@ -674,6 +903,161 @@
 }
 #endif
 
+#ifdef __INTERIX
+/* Try to open a dynamic archive.  This is where we know that 
+   dynamic libraries have an extension of .so.  */
+
+static bfd_boolean
+gld_${EMULATION_NAME}_open_dynamic_archive (
+     const char *arch,
+     search_dirs_type *search,
+     lang_input_statement_type *entry)
+{
+  const char *filename;
+  char *string;
+
+  if (! entry->is_archive)
+    return FALSE;
+
+  filename = entry->filename;
+
+  string = (char *) xmalloc (strlen (search->name)
+			     + strlen (filename)
+			     + strlen (arch)
+			     + sizeof "/lib.so");
+
+  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);
+
+  if (! ldfile_try_open_bfd (string, entry))
+    {
+      free (string);
+      return FALSE;
+    }
+
+  entry->filename = string;
+
+  /* We have found a dynamic object to include in the link.  The 
+     backend linker will create a DT_NEEDED entry in the .dynamic
+     section naming this file.  If this file includes a DT_SONAME
+     entry, it will be used.  Otherwise, the linker will just use
+     the name of the file.  For an archive found by searching, like
+     this one, the DT_NEEDED entry should consist of just the name of
+     the file, without the path information used to find it.  Note
+     that we only need to do this if we have a dynamic object; an
+     archive will never be referenced by a DT_NEEDED entry.
+
+     FIXME: This approach--using bfd_coff_set_dt_needed_name--is not
+     very pretty.  I haven't been able to think of anything that is
+     pretty, though.  */
+  if (bfd_check_format (entry->the_bfd, bfd_object)
+      && (entry->the_bfd->flags & DYNAMIC) != 0)
+    {
+      char *needed_name;
+
+      ASSERT (entry->is_archive && entry->search_dirs_flag);
+      needed_name = (char *) xmalloc (strlen (filename)
+				      + strlen (arch)
+				      + sizeof "lib.so");
+      sprintf (needed_name, "lib%s%s.so", filename, arch);
+      bfd_coff_set_dt_needed_name (entry->the_bfd, needed_name);
+    }
+
+  return TRUE;
+}
+#endif
+
+EOF
+if [ "x${host}" = "x${target}" ] ; then
+  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
+cat >>e${EMULATION_NAME}.c <<EOF
+
+/* For a native linker, check the file /etc/ld.so.conf for directories
+   in which we may find shared libraries.  /etc/ld.so.conf is really
+   only meaningful on Linux, but we check it on other systems anyhow.  */
+
+static bfd_boolean gld_${EMULATION_NAME}_check_ld_so_conf PARAMS ((const char *));
+
+static bfd_boolean
+gld_${EMULATION_NAME}_check_ld_so_conf (
+     const char *name)
+{
+  static bfd_boolean initialized;
+  static char *ld_so_conf;
+
+  if (! initialized)
+    {
+      FILE *f;
+      char *fname;
+
+      fname = _prefixInstallPath("/etc/ld.so.conf", NULL, 0);
+      f = fopen (fname, FOPEN_RT);
+      if (f != NULL)
+	{
+	  char *b;
+	  size_t len, alloc;
+	  int c;
+
+	  len = 0;
+	  alloc = 100;
+	  b = (char *) xmalloc (alloc);
+
+	  while ((c = getc (f)) != EOF)
+	    {
+	      if (len + 1 >= alloc)
+		{
+		  alloc *= 2;
+		  b = (char *) xrealloc (b, alloc);
+		}
+	      if (c != ':'
+		  && c != ' '
+		  && c != '\t'
+		  && c != '\n'
+		  && c != ',')
+		{
+		  b[len] = c;
+		  ++len;
+		}
+	      else
+		{
+		  if (len > 0 && b[len - 1] != ':')
+		    {
+		      b[len] = ':';
+		      ++len;
+		    }
+		}
+	    }
+
+	  if (len > 0 && b[len - 1] == ':')
+	    --len;
+
+	  if (len > 0)
+	    b[len] = '\0';
+	  else
+	    {
+	      free (b);
+	      b = NULL;
+	    }
+
+	  fclose (f);
+
+	  ld_so_conf = b;
+	}
+
+      initialized = TRUE;
+    }
+
+  if (ld_so_conf == NULL)
+    return FALSE;
+
+  return gld_${EMULATION_NAME}_search_needed (ld_so_conf, name);
+}
+
+EOF
+  fi
+fi
+cat >>e${EMULATION_NAME}.c <<EOF
+
+
 /* Assign values to the special symbols before the linker script is
    read.  */
 
@@ -958,9 +1342,18 @@
 #endif /* DLL_SUPPORT */
 
 
+/* These variables are required to pass information back and forth
+   between after_open and check_needed and stat_needed.  */
+
+static struct bfd_link_needed_list *global_needed;
+static struct stat global_stat;
+static bfd_boolean global_found;
+
 static void
 gld_${EMULATION_NAME}_after_open (void)
 {
+  struct bfd_link_needed_list *needed, *l;
+
 #ifdef DLL_SUPPORT
   if (pe_dll_extra_pe_debug)
     {
@@ -1245,11 +1638,315 @@
 	  }
       }
   }
+
+  /* We only need to worry about this when doing a final link.  */
+  if (link_info.relocatable || link_info.shared)
+    return;
+
+  /* Get the list of files which appear in DT_NEEDED entries in
+     dynamic objects included in the link (often there will be none).
+     For each such file, we want to track down the corresponding
+     library, and include the symbol table in the link.  This is what
+     the runtime dynamic linker will do.  Tracking the files down here
+     permits one dynamic object to include another without requiring
+     special action by the person doing the link.  Note that the
+     needed list can actually grow while we are stepping through this
+     loop.  */
+  needed = bfd_coff_get_needed_list (output_bfd, &link_info);
+  for (l = needed; l != NULL; l = l->next)
+    {
+      struct bfd_link_needed_list *ll;
+      const char *lib_path;
+      size_t len;
+      search_dirs_type *search;
+
+      /* If we've already seen this file, skip it.  */
+      for (ll = needed; ll != l; ll = ll->next)
+	if (strcmp (ll->name, l->name) == 0)
+	  break;
+      if (ll != l)
+	continue;
+
+      /* See if this file was included in the link explicitly.  */
+      global_needed = l;
+      global_found = FALSE;
+      lang_for_each_input_file (gld_${EMULATION_NAME}_check_needed);
+      if (global_found)
+	continue;
+
+      /* We need to find this file and include the symbol table.  We
+	 want to search for the file in the same way that the dynamic
+	 linker will search.  That means that we want to use
+	 rpath_link, rpath, then the environment variable
+	 LD_LIBRARY_PATH (native only), then the linker script
+	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.  */
+      if (gld_${EMULATION_NAME}_search_needed (command_line.rpath_link,
+					      l->name))
+	continue;
+      if (gld_${EMULATION_NAME}_search_needed (command_line.rpath, l->name))
+	continue;
+      if (command_line.rpath_link == NULL
+	  && command_line.rpath == NULL)
+	{
+	  lib_path = (const char *) getenv ("LD_RUN_PATH");
+	  if (gld_${EMULATION_NAME}_search_needed (lib_path, l->name))
+	    continue;
+	}
+EOF
+if [ "x${host}" = "x${target}" ] ; then
+  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
+cat >>e${EMULATION_NAME}.c <<EOF
+      lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
+      if (gld_${EMULATION_NAME}_search_needed (lib_path, l->name))
+	continue;
+EOF
+  fi
+fi
+cat >>e${EMULATION_NAME}.c <<EOF
+      len = strlen (l->name);
+      for (search = search_head; search != NULL; search = search->next)
+	{
+	  char *filename;
+
+	  if (search->cmdline)
+	    continue;
+	  filename = (char *) xmalloc (strlen (search->name) + len + 2);
+	  sprintf (filename, "%s/%s", search->name, l->name);
+	  if (gld_${EMULATION_NAME}_try_needed (filename))
+	    break;
+	  free (filename);
+	}
+      if (search != NULL)
+	continue;
+EOF
+if [ "x${host}" = "x${target}" ] ; then
+  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
+cat >>e${EMULATION_NAME}.c <<EOF
+      if (gld_${EMULATION_NAME}_check_ld_so_conf (l->name))
+	continue;
+EOF
+  fi
+fi
+cat >>e${EMULATION_NAME}.c <<EOF
+
+      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
+	     l->name, l->by);
+    }
+
 }
 
+/* Search for a needed file in a path.  */
+
+static bfd_boolean
+gld_${EMULATION_NAME}_search_needed (
+     const char *path,
+     const char *name)
+{
+  const char *s;
+  size_t len;
+
+  if (path == NULL || *path == '\0')
+    return FALSE;
+  len = strlen (name);
+  while (1)
+    {
+      char *filename, *sset;
+
+      s = strchr (path, ':');
+      if (s == NULL)
+	s = path + strlen (path);
+
+      filename = (char *) xmalloc (s - path + len + 2);
+      if (s == path)
+	sset = filename;
+      else
+	{
+	  memcpy (filename, path, s - path);
+	  filename[s - path] = '/';
+	  sset = filename + (s - path) + 1;
+	}
+      strcpy (sset, name);
+
+      if (gld_${EMULATION_NAME}_try_needed (filename))
+	return TRUE;
+
+      free (filename);
+
+      if (*s == '\0')
+	break;
+      path = s + 1;
+    }
+
+  return FALSE;	  
+}
+
+/* This function is called for each possible name for a dynamic object
+   named by a DT_NEEDED entry.  */
+
+static bfd_boolean
+gld_${EMULATION_NAME}_try_needed (
+     const char *name)
+{
+  bfd *abfd;
+
+  abfd = bfd_openr (name, bfd_get_target (output_bfd));
+  if (abfd == NULL)
+    return FALSE;
+  if (! bfd_check_format (abfd, bfd_object))
+    {
+      (void) bfd_close (abfd);
+      return FALSE;
+    }
+  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
+    {
+      (void) bfd_close (abfd);
+      return FALSE;
+    }
+
+  /* We've found a dynamic object matching the DT_NEEDED entry.  */
+
+  /* We have already checked that there is no other input file of the
+     same name.  We must now check again that we are not including the
+     same file twice.  We need to do this because on many systems
+     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
+     reference libc.so.1.  If we have already included libc.so, we
+     don't want to include libc.so.1 if they are the same file, and we
+     can only check that using stat.  */
+
+  if (bfd_stat (abfd, &global_stat) != 0)
+    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);
+  global_found = FALSE;
+  lang_for_each_input_file (gld_${EMULATION_NAME}_stat_needed);
+  if (global_found)
+    {
+      /* Return TRUE to indicate that we found the file, even though
+         we aren't going to do anything with it.  */
+      return TRUE;
+    }
+
+  /* Tell the backend that don't want the output file to have a
+     DT_NEEDED entry for this file.  */
+  bfd_coff_set_dt_needed_name (abfd, "");
+
+  /* Add this file into the symbol table.  */
+  if (! bfd_link_add_symbols (abfd, &link_info))
+    einfo ("%F%B: could not read symbols: %E\n", abfd);
+
+  return TRUE;
+}
+
+/* See if an input file matches a DT_NEEDED entry by name.  */
+
+static void
+gld_${EMULATION_NAME}_check_needed ( lang_input_statement_type *s)
+{
+  if (global_found)
+    return;
+
+  if (s->filename != NULL
+      && strcmp (s->filename, global_needed->name) == 0)
+    {
+      global_found = TRUE;
+      return;
+    }
+
+  if (s->the_bfd != NULL)
+    {
+      const char *soname;
+
+      soname = bfd_coff_get_dt_soname (s->the_bfd);
+      if (soname != NULL
+	  && strcmp (soname, global_needed->name) == 0)
+	{
+	  global_found = TRUE;
+	  return;
+	}
+    }
+	  
+  if (s->search_dirs_flag
+      && s->filename != NULL
+      && strchr (global_needed->name, '/') == NULL)
+    {
+      const char *f;
+
+      f = strrchr (s->filename, '/');
+      if (f != NULL
+	  && strcmp (f + 1, global_needed->name) == 0)
+	{
+	  global_found = TRUE;
+	  return;
+	}
+    }
+}
+
+/* See if an input file matches a DT_NEEDED entry by running stat on
+   the file.  */
+
+static void
+gld_${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)
+{
+  struct stat st;
+  const char *suffix;
+  const char *soname;
+  const char *f;
+
+  if (global_found)
+    return;
+  if (s->the_bfd == NULL)
+    return;
+
+  if (bfd_stat (s->the_bfd, &st) != 0)
+    {
+      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
+      return;
+    }
+
+  if (st.st_dev == global_stat.st_dev
+      && st.st_ino == global_stat.st_ino)
+    {
+      global_found = TRUE;
+      return;
+    }
+
+  /* We issue a warning if it looks like we are including two
+     different versions of the same shared library.  For example,
+     there may be a problem if -lc picks up libc.so.6 but some other
+     shared library has a DT_NEEDED entry of libc.so.5.  This is a
+     hueristic test, and it will only work if the name looks like
+     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
+     If we really want to issue warnings about mixing version numbers
+     of shared libraries, we need to find a better way.  */
+
+  if (strchr (global_needed->name, '/') != NULL)
+    return;
+  suffix = strstr (global_needed->name, ".so.");
+  if (suffix == NULL)
+    return;
+  suffix += sizeof ".so." - 1;
+
+  soname = bfd_coff_get_dt_soname (s->the_bfd);
+  if (soname == NULL)
+    soname = s->filename;
+
+  f = strrchr (soname, '/');
+  if (f != NULL)
+    ++f;
+  else
+    f = soname;
+
+  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
+    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
+	   global_needed->name, global_needed->by, f);
+}
+
+
+
 static void
 gld_${EMULATION_NAME}_before_allocation (void)
 {
+  const char *rpath;
+  asection *sinterp;
+
 #ifdef TARGET_IS_ppcpe
   /* Here we rummage through the found bfds to collect toc information.  */
   {
@@ -1290,6 +1987,70 @@
   /* We have seen it all. Allocate it, and carry on.  */
   bfd_arm_pe_allocate_interworking_sections (& link_info);
 #endif /* TARGET_IS_armpe */
+  rpath = command_line.rpath;
+  if (rpath == NULL)
+    rpath = (const char *) getenv ("LD_RUN_PATH");
+
+  /* Let the backend work out the sizes of any sections required
+     by dynamic linking.  */
+  /* Let the backend set up the dynamic sections */
+  if (! bfd_coff_size_dynamic_sections (output_bfd, 
+			command_line.soname, 
+			rpath,
+			command_line.filter_shlib,
+			(const char * const *) command_line.auxiliary_filters,
+			&link_info,
+			&sinterp,
+			lang_elf_version_info /* just use the elf one */
+			 ))
+      einfo ("%P%F: failed to set dynamic section sizes: %E\n");
+
+  /* Let the user override the dynamic linker we are using.  */
+  if (command_line.interpreter != NULL
+      && sinterp != NULL)
+    {
+      sinterp->contents = (bfd_byte *) command_line.interpreter;
+      sinterp->rawsize = strlen (command_line.interpreter) + 1;
+    }
+
+  /* Look for any sections named .gnu.warning.  As a GNU extensions,
+     we treat such sections as containing warning messages.  We print
+     out the warning message, and then zero out the section size so
+     that it does not get copied into the output file.  */
+
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	asection *s;
+	bfd_size_type sz;
+	char *msg;
+	bfd_boolean ret;
+
+	if (is->just_syms_flag)
+	  continue;
+
+	s = bfd_get_section_by_name (is->the_bfd, ".gnu.warning");
+	if (s == NULL)
+	  continue;
+
+	sz = bfd_section_size (is->the_bfd, s);
+	msg = xmalloc ((size_t) sz + 1);
+	if (! bfd_get_section_contents (is->the_bfd, s, msg, (file_ptr) 0, sz))
+	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
+		 is->the_bfd);
+	msg[sz] = '\0';
+	ret = link_info.callbacks->warning (&link_info, msg,
+					    (const char *) NULL,
+					    is->the_bfd, (asection *) NULL,
+					    (bfd_vma) 0);
+	ASSERT (ret);
+	free (msg);
+
+	/* Clobber the section size, so that we don't waste copying the
+	   warning into the output file.  */
+	s->rawsize = 0;
+      }
+   }
 
   before_allocation_default ();
 }
@@ -1504,6 +2265,11 @@
 }
 
 
+
+/* Find the last output section before given output statement.
+   Used by place_orphan.  */
+
+
 /* Place an orphan section.
 
    We use this to put sections in a reasonable place in the file, and
@@ -1548,14 +2314,17 @@
       && (os->bfd_section == NULL
 	  || os->bfd_section->flags == 0
 	  || ((s->flags ^ os->bfd_section->flags)
-	      & (SEC_LOAD | SEC_ALLOC)) == 0))
+	      & (SEC_LOAD | SEC_ALLOC)) == 0)
+      && (!link_info.relocatable || (s->flags & SEC_LINK_ONCE) == 0))
     {
       /* We already have an output section statement with this
 	 name, and its bfd section, if any, has compatible flags.
+	 It also can't be "link once", as those must stay separate
+	 until final link to avoid duplicate symbol errors. 
 	 If the section already exists but does not have any flags set,
 	 then it has been created by the linker, probably as a result of
 	 a --section-start command line switch.  */
-      lang_add_section (&add_child, s, os);
+      lang_add_section (&add_child, s, os, FALSE);
     }
   else
     {
@@ -1583,7 +2352,8 @@
 	};
       static int orphan_init_done = 0;
       struct orphan_save *place;
-      lang_output_section_statement_type *after;
+      char *outsecname;
+      lang_output_section_statement_type *after=NULL;
       etree_type *address;
 
       if (!orphan_init_done)
@@ -1598,6 +2368,13 @@
 	      }
 	  orphan_init_done = 1;
 	}
+      place = NULL;
+      outsecname = xstrdup (secname);
+
+      /* We don't want to try to be fancy with comdats. */
+      if (!link_info.relocatable || (s->flags & SEC_LINK_ONCE) == 0)
+// Deferred indentation fix; indent when final apply is done
+    {
 
       /* Try to put the new output section in a reasonable place based
 	 on the section name and section flags.  */
@@ -1638,6 +2415,7 @@
 	  if (secname == NULL)
 	    einfo ("%F%P: place_orphan failed: %E\n");
 	}
+	}
 
       /* All sections in an executable must be aligned to a page boundary.  */
       address = exp_unop (ALIGN_K, exp_nameop (NAME, "__section_alignment__"));
@@ -1689,6 +2467,8 @@
   return TRUE;
 }
 
+#ifndef __INTERIX
+
 static bfd_boolean
 gld_${EMULATION_NAME}_open_dynamic_archive
   (const char *arch ATTRIBUTE_UNUSED, search_dirs_type *search,
@@ -1778,6 +2558,7 @@
 
   return TRUE;
 }
+#endif
 
 static int
 gld_${EMULATION_NAME}_find_potential_libraries
@@ -1807,6 +2588,8 @@
 sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
 echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
+echo '  ; else if (link_info.shared) return'            >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xs                  >> e${EMULATION_NAME}.c
 echo '  ; else return'					>> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
 echo '; }'						>> e${EMULATION_NAME}.c
@@ -1833,7 +2616,7 @@
   gld_${EMULATION_NAME}_open_dynamic_archive,
   gld_${EMULATION_NAME}_place_orphan,
   gld_${EMULATION_NAME}_set_symbols,
-  NULL, /* parse_args */
+ gld_${EMULATION_NAME}_parse_args,
   gld${EMULATION_NAME}_add_options,
   gld${EMULATION_NAME}_handle_option,
   gld_${EMULATION_NAME}_unrecognized_file,
diff -ruNbB binutils-2.17/ld/emultempl/ppc64elf.em binutils-2.17.sua/ld/emultempl/ppc64elf.em
--- binutils-2.17/ld/emultempl/ppc64elf.em	2005-11-17 01:10:05 +0100
+++ binutils-2.17.sua/ld/emultempl/ppc64elf.em	2008-04-01 09:03:30 +0200
@@ -235,7 +235,7 @@
 
   info.input_section = input_section;
   lang_list_init (&info.add);
-  lang_add_section (&info.add, stub_sec, os);
+  lang_add_section (&info.add, stub_sec, os, FALSE);
 
   if (info.add.head == NULL)
     goto err_ret;
diff -ruNbB binutils-2.17/ld/ldexp.c binutils-2.17.sua/ld/ldexp.c
--- binutils-2.17/ld/ldexp.c	2005-12-07 15:43:54 +0100
+++ binutils-2.17.sua/ld/ldexp.c	2008-04-01 09:03:30 +0200
@@ -524,7 +523,23 @@
 		   || h->type == bfd_link_hash_defweak)
 	    {
 	      if (bfd_is_abs_section (h->u.def.section))
+	      	{
+#if 1
+			/*
+			 * FIXME
+			 * mayank@15th June, 2007
+			 * This is a hack. The section vma comes with the
+			 * image_base always added. This happens because unlike
+			 * previous version (gcc3.3), the first hash lookup
+			 * always returns an image_base entry and this value
+			 * gets added to the vma.
+			 */
+	      		if (strncmp(h->root.string, "__image_base__",14)==0)
+				new_abs (0);
+			else
+#endif
 		new_abs (h->u.def.value);
+	      	}
 	      else
 		{
 		  asection *output_section;
diff -ruNbB binutils-2.17/ld/ldgram.c binutils-2.17.sua/ld/ldgram.c
--- binutils-2.17/ld/ldgram.c	2006-04-16 20:36:46 +0200
+++ binutils-2.17.sua/ld/ldgram.c	2008-04-01 09:03:30 +0200
@@ -1,299 +1,22 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.1"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INT = 258,
-     NAME = 259,
-     LNAME = 260,
-     OREQ = 261,
-     ANDEQ = 262,
-     RSHIFTEQ = 263,
-     LSHIFTEQ = 264,
-     DIVEQ = 265,
-     MULTEQ = 266,
-     MINUSEQ = 267,
-     PLUSEQ = 268,
-     OROR = 269,
-     ANDAND = 270,
-     NE = 271,
-     EQ = 272,
-     GE = 273,
-     LE = 274,
-     RSHIFT = 275,
-     LSHIFT = 276,
-     UNARY = 277,
-     END = 278,
-     ALIGN_K = 279,
-     BLOCK = 280,
-     BIND = 281,
-     QUAD = 282,
-     SQUAD = 283,
-     LONG = 284,
-     SHORT = 285,
-     BYTE = 286,
-     SECTIONS = 287,
-     PHDRS = 288,
-     DATA_SEGMENT_ALIGN = 289,
-     DATA_SEGMENT_RELRO_END = 290,
-     DATA_SEGMENT_END = 291,
-     SORT_BY_NAME = 292,
-     SORT_BY_ALIGNMENT = 293,
-     SIZEOF_HEADERS = 294,
-     OUTPUT_FORMAT = 295,
-     FORCE_COMMON_ALLOCATION = 296,
-     OUTPUT_ARCH = 297,
-     INHIBIT_COMMON_ALLOCATION = 298,
-     SEGMENT_START = 299,
-     INCLUDE = 300,
-     MEMORY = 301,
-     DEFSYMEND = 302,
-     NOLOAD = 303,
-     DSECT = 304,
-     COPY = 305,
-     INFO = 306,
-     OVERLAY = 307,
-     DEFINED = 308,
-     TARGET_K = 309,
-     SEARCH_DIR = 310,
-     MAP = 311,
-     ENTRY = 312,
-     NEXT = 313,
-     SIZEOF = 314,
-     ADDR = 315,
-     LOADADDR = 316,
-     MAX_K = 317,
-     MIN_K = 318,
-     STARTUP = 319,
-     HLL = 320,
-     SYSLIB = 321,
-     FLOAT = 322,
-     NOFLOAT = 323,
-     NOCROSSREFS = 324,
-     ORIGIN = 325,
-     FILL = 326,
-     LENGTH = 327,
-     CREATE_OBJECT_SYMBOLS = 328,
-     INPUT = 329,
-     GROUP = 330,
-     OUTPUT = 331,
-     CONSTRUCTORS = 332,
-     ALIGNMOD = 333,
-     AT = 334,
-     SUBALIGN = 335,
-     PROVIDE = 336,
-     PROVIDE_HIDDEN = 337,
-     AS_NEEDED = 338,
-     CHIP = 339,
-     LIST = 340,
-     SECT = 341,
-     ABSOLUTE = 342,
-     LOAD = 343,
-     NEWLINE = 344,
-     ENDWORD = 345,
-     ORDER = 346,
-     NAMEWORD = 347,
-     ASSERT_K = 348,
-     FORMAT = 349,
-     PUBLIC = 350,
-     BASE = 351,
-     ALIAS = 352,
-     TRUNCATE = 353,
-     REL = 354,
-     INPUT_SCRIPT = 355,
-     INPUT_MRI_SCRIPT = 356,
-     INPUT_DEFSYM = 357,
-     CASE = 358,
-     EXTERN = 359,
-     START = 360,
-     VERS_TAG = 361,
-     VERS_IDENTIFIER = 362,
-     GLOBAL = 363,
-     LOCAL = 364,
-     VERSIONK = 365,
-     INPUT_VERSION_SCRIPT = 366,
-     KEEP = 367,
-     ONLY_IF_RO = 368,
-     ONLY_IF_RW = 369,
-     SPECIAL = 370,
-     EXCLUDE_FILE = 371
-   };
-#endif
-/* Tokens.  */
-#define INT 258
-#define NAME 259
-#define LNAME 260
-#define OREQ 261
-#define ANDEQ 262
-#define RSHIFTEQ 263
-#define LSHIFTEQ 264
-#define DIVEQ 265
-#define MULTEQ 266
-#define MINUSEQ 267
-#define PLUSEQ 268
-#define OROR 269
-#define ANDAND 270
-#define NE 271
-#define EQ 272
-#define GE 273
-#define LE 274
-#define RSHIFT 275
-#define LSHIFT 276
-#define UNARY 277
-#define END 278
-#define ALIGN_K 279
-#define BLOCK 280
-#define BIND 281
-#define QUAD 282
-#define SQUAD 283
-#define LONG 284
-#define SHORT 285
-#define BYTE 286
-#define SECTIONS 287
-#define PHDRS 288
-#define DATA_SEGMENT_ALIGN 289
-#define DATA_SEGMENT_RELRO_END 290
-#define DATA_SEGMENT_END 291
-#define SORT_BY_NAME 292
-#define SORT_BY_ALIGNMENT 293
-#define SIZEOF_HEADERS 294
-#define OUTPUT_FORMAT 295
-#define FORCE_COMMON_ALLOCATION 296
-#define OUTPUT_ARCH 297
-#define INHIBIT_COMMON_ALLOCATION 298
-#define SEGMENT_START 299
-#define INCLUDE 300
-#define MEMORY 301
-#define DEFSYMEND 302
-#define NOLOAD 303
-#define DSECT 304
-#define COPY 305
-#define INFO 306
-#define OVERLAY 307
-#define DEFINED 308
-#define TARGET_K 309
-#define SEARCH_DIR 310
-#define MAP 311
-#define ENTRY 312
-#define NEXT 313
-#define SIZEOF 314
-#define ADDR 315
-#define LOADADDR 316
-#define MAX_K 317
-#define MIN_K 318
-#define STARTUP 319
-#define HLL 320
-#define SYSLIB 321
-#define FLOAT 322
-#define NOFLOAT 323
-#define NOCROSSREFS 324
-#define ORIGIN 325
-#define FILL 326
-#define LENGTH 327
-#define CREATE_OBJECT_SYMBOLS 328
-#define INPUT 329
-#define GROUP 330
-#define OUTPUT 331
-#define CONSTRUCTORS 332
-#define ALIGNMOD 333
-#define AT 334
-#define SUBALIGN 335
-#define PROVIDE 336
-#define PROVIDE_HIDDEN 337
-#define AS_NEEDED 338
-#define CHIP 339
-#define LIST 340
-#define SECT 341
-#define ABSOLUTE 342
-#define LOAD 343
-#define NEWLINE 344
-#define ENDWORD 345
-#define ORDER 346
-#define NAMEWORD 347
-#define ASSERT_K 348
-#define FORMAT 349
-#define PUBLIC 350
-#define BASE 351
-#define ALIAS 352
-#define TRUNCATE 353
-#define REL 354
-#define INPUT_SCRIPT 355
-#define INPUT_MRI_SCRIPT 356
-#define INPUT_DEFSYM 357
-#define CASE 358
-#define EXTERN 359
-#define START 360
-#define VERS_TAG 361
-#define VERS_IDENTIFIER 362
-#define GLOBAL 363
-#define LOCAL 364
-#define VERSIONK 365
-#define INPUT_VERSION_SCRIPT 366
-#define KEEP 367
-#define ONLY_IF_RO 368
-#define ONLY_IF_RW 369
-#define SPECIAL 370
-#define EXCLUDE_FILE 371
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 22 "ldgram.y"
-
+#ifndef lint
+/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
+static char yyrcsid[]
+#if __GNUC__ >= 2
+  __attribute__ ((unused))
+#endif /* __GNUC__ >= 2 */
+  = "$Interix: skeleton.c,v 1.26 $";
+#endif
+#include <stdlib.h>
+#define YYBYACC 1
+#define YYMAJOR 1
+#define YYMINOR 9
+#define YYLEX yylex()
+#define YYEMPTY -1
+#define yyclearin (yychar=(YYEMPTY))
+#define yyerrok (yyerrflag=0)
+#define YYRECOVERING() (yyerrflag!=0)
+#define YYPREFIX "yy"
+#line 23 "ldgram.y"
 /*
 
  */
@@ -335,29 +58,10 @@
 static int error_index;
 #define PUSH_ERROR(x) if (error_index < ERROR_NAME_MAX) error_names[error_index] = x; error_index++;
 #define POP_ERROR()   error_index--;
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
 #line 65 "ldgram.y"
-typedef union YYSTYPE {
+#ifndef YYSTYPE_DEFINED
+#define YYSTYPE_DEFINED
+typedef union {
   bfd_vma integer;
   struct big_int
     {
@@ -385,3208 +89,2887 @@
   struct bfd_elf_version_expr *versyms;
   struct bfd_elf_version_tree *versnode;
 } YYSTYPE;
-/* Line 196 of yacc.c.  */
-#line 390 "ldgram.c"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 219 of yacc.c.  */
-#line 402 "ldgram.c"
-
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
+#endif /* YYSTYPE_DEFINED */
+#line 94 "ldgram.c"
+#define INT 257
+#define NAME 258
+#define LNAME 259
+#define PLUSEQ 260
+#define MINUSEQ 261
+#define MULTEQ 262
+#define DIVEQ 263
+#define LSHIFTEQ 264
+#define RSHIFTEQ 265
+#define ANDEQ 266
+#define OREQ 267
+#define OROR 268
+#define ANDAND 269
+#define EQ 270
+#define NE 271
+#define LE 272
+#define GE 273
+#define LSHIFT 274
+#define RSHIFT 275
+#define UNARY 276
+#define END 277
+#define ALIGN_K 278
+#define BLOCK 279
+#define BIND 280
+#define QUAD 281
+#define SQUAD 282
+#define LONG 283
+#define SHORT 284
+#define BYTE 285
+#define SECTIONS 286
+#define PHDRS 287
+#define DATA_SEGMENT_ALIGN 288
+#define DATA_SEGMENT_RELRO_END 289
+#define DATA_SEGMENT_END 290
+#define SORT_BY_NAME 291
+#define SORT_BY_ALIGNMENT 292
+#define SIZEOF_HEADERS 293
+#define OUTPUT_FORMAT 294
+#define FORCE_COMMON_ALLOCATION 295
+#define OUTPUT_ARCH 296
+#define INHIBIT_COMMON_ALLOCATION 297
+#define SEGMENT_START 298
+#define INCLUDE 299
+#define MEMORY 300
+#define DEFSYMEND 301
+#define NOLOAD 302
+#define DSECT 303
+#define COPY 304
+#define INFO 305
+#define OVERLAY 306
+#define DEFINED 307
+#define TARGET_K 308
+#define SEARCH_DIR 309
+#define MAP 310
+#define ENTRY 311
+#define NEXT 312
+#define SIZEOF 313
+#define ADDR 314
+#define LOADADDR 315
+#define MAX_K 316
+#define MIN_K 317
+#define STARTUP 318
+#define HLL 319
+#define SYSLIB 320
+#define FLOAT 321
+#define NOFLOAT 322
+#define NOCROSSREFS 323
+#define ORIGIN 324
+#define FILL 325
+#define LENGTH 326
+#define CREATE_OBJECT_SYMBOLS 327
+#define INPUT 328
+#define GROUP 329
+#define OUTPUT 330
+#define CONSTRUCTORS 331
+#define ALIGNMOD 332
+#define AT 333
+#define SUBALIGN 334
+#define PROVIDE 335
+#define PROVIDE_HIDDEN 336
+#define AS_NEEDED 337
+#define CHIP 338
+#define LIST 339
+#define SECT 340
+#define ABSOLUTE 341
+#define LOAD 342
+#define NEWLINE 343
+#define ENDWORD 344
+#define ORDER 345
+#define NAMEWORD 346
+#define ASSERT_K 347
+#define FORMAT 348
+#define PUBLIC 349
+#define BASE 350
+#define ALIAS 351
+#define TRUNCATE 352
+#define REL 353
+#define INPUT_SCRIPT 354
+#define INPUT_MRI_SCRIPT 355
+#define INPUT_DEFSYM 356
+#define CASE 357
+#define EXTERN 358
+#define START 359
+#define VERS_TAG 360
+#define VERS_IDENTIFIER 361
+#define GLOBAL 362
+#define LOCAL 363
+#define VERSIONK 364
+#define INPUT_VERSION_SCRIPT 365
+#define KEEP 366
+#define ONLY_IF_RO 367
+#define ONLY_IF_RW 368
+#define SPECIAL 369
+#define EXCLUDE_FILE 370
+#define YYERRCODE 256
+#if defined(__cplusplus) || defined(__STDC__)
+const short yylhs[] =
+#else
+short yylhs[] =
 #endif
-#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
-# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-# define YYSIZE_T size_t
+	{                                        -1,
+    0,    0,    0,    0,   28,   36,   35,   38,   33,   37,
+   37,   39,   39,   39,   39,   39,   39,   39,   39,   39,
+   39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
+   39,   39,   39,   39,   39,   39,   39,   44,   39,   39,
+   39,   40,   40,   40,   42,   42,   41,   41,   15,   15,
+   15,   43,   43,   43,   46,   32,   45,   45,   47,   47,
+   47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+   47,   47,   47,   47,   47,   47,   47,   58,   47,   47,
+   59,   47,   47,   47,   57,   57,   57,   57,   57,   57,
+   60,   57,   61,   57,   62,   57,   49,   63,   63,   63,
+   55,   55,   67,   55,   17,   17,   17,   18,   18,   18,
+   18,   18,   18,   18,   18,   18,   12,   12,   13,   13,
+   69,   69,   69,   70,   71,   70,   72,   72,   72,   72,
+   72,   72,   72,   72,   73,   73,   74,   74,   19,   19,
+   19,   19,   19,   11,   10,   10,   24,   24,   24,   24,
+   24,   24,   24,   24,   66,   66,   65,   65,   65,   65,
+   68,   68,   48,   76,   76,   76,   77,   75,   78,   79,
+   26,   26,   80,   80,   81,   81,   51,   52,   52,   82,
+   82,   53,   83,   83,   54,   54,   21,   21,   21,   84,
+    3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,   16,   16,    4,    4,
+    9,    9,    8,    8,   27,   27,   27,   27,   85,   86,
+   87,   88,   89,   64,   90,   91,   93,   94,   95,   64,
+   96,   97,   64,   98,   98,   98,   98,   98,   25,   25,
+   25,    2,    2,    2,    2,    7,    7,   23,   23,   14,
+   14,   22,   22,   92,   99,  100,  101,   92,   50,  102,
+  102,  104,  105,  103,    5,   20,   20,   20,    6,    6,
+  107,   34,  108,   56,  106,  106,  109,  109,  109,   31,
+   31,   30,   30,   30,   30,   30,   29,   29,   29,   29,
+  110,   29,  112,   29,   29,   29,   29,   29,   29,   29,
+  111,  111,
+};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yylen[] =
+#else
+short yylen[] =
 #endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
+	{                                         2,
+    2,    2,    2,    2,    1,    0,    4,    0,    2,    3,
+    0,    2,    4,    1,    1,    2,    1,    4,    4,    3,
+    2,    4,    3,    4,    4,    4,    4,    4,    2,    2,
+    2,    4,    4,    2,    2,    2,    2,    0,    5,    2,
+    0,    3,    2,    0,    1,    3,    1,    3,    0,    1,
+    3,    1,    2,    3,    0,    2,    2,    0,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    4,    4,
+    4,    4,    8,    4,    1,    1,    4,    0,    5,    4,
+    0,    5,    4,    4,    1,    3,    2,    1,    3,    2,
+    0,    5,    0,    7,    0,    6,    4,    2,    2,    0,
+    4,    2,    0,    7,    1,    1,    1,    1,    5,    4,
+    4,    7,    7,    7,    7,    8,    2,    1,    3,    1,
+    1,    3,    4,    1,    0,    5,    2,    1,    1,    1,
+    4,    1,    4,    4,    2,    1,    0,    1,    1,    1,
+    1,    1,    1,    1,    2,    0,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    3,    3,    6,    6,
+    1,    0,    5,    2,    3,    0,    0,    7,    3,    3,
+    0,    3,    1,    2,    1,    2,    4,    4,    3,    3,
+    1,    4,    3,    0,    1,    1,    0,    2,    3,    0,
+    2,    2,    3,    4,    2,    2,    2,    3,    3,    3,
+    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+    3,    3,    3,    5,    3,    3,    4,    1,    1,    4,
+    4,    4,    4,    4,    6,    6,    6,    4,    6,    4,
+    1,    6,    6,    6,    4,    4,    3,    0,    4,    0,
+    4,    0,    4,    0,    1,    1,    1,    0,    0,    0,
+    0,    0,    0,   19,    0,    0,    0,    0,    0,   18,
+    0,    0,    7,    1,    1,    1,    1,    1,    3,    0,
+    2,    3,    2,    6,   10,    2,    1,    0,    1,    2,
+    0,    0,    3,    0,    0,    0,    0,   11,    4,    0,
+    2,    0,    0,    6,    1,    0,    3,    5,    0,    3,
+    0,    2,    0,    5,    1,    2,    4,    5,    6,    1,
+    2,    0,    2,    4,    4,    8,    1,    1,    3,    3,
+    0,    9,    0,    7,    1,    3,    1,    3,    1,    3,
+    0,    1,
+};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yydefred[] =
+#else
+short yydefred[] =
 #endif
-
-#ifndef YY_
-# if YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(msgid) dgettext ("bison-runtime", msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(msgid) msgid
-# endif
+	{                                      0,
+   55,    8,    6,  301,    0,    1,   58,    2,   11,    4,
+    0,    3,    0,    0,    0,    0,    0,    0,    0,  305,
+    0,    0,    0,    0,   75,    0,   76,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  185,  186,    0,    0,
+   78,    0,    0,    0,  103,    0,   68,   57,   59,   60,
+   61,   62,   63,   64,   65,   66,   67,    0,    0,   14,
+    0,    0,    0,    0,   15,    0,    0,    0,   17,   44,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  318,    0,  317,    0,    0,    0,    0,    0,  306,
+  147,  148,  149,  150,  190,  151,  152,  153,  154,  190,
+  100,  290,    0,    0,    5,   81,    0,    0,    0,    0,
+    0,    0,    0,  184,    0,    0,    0,    0,    0,    0,
+    0,    0,  156,  155,  102,    0,    0,   38,    0,  218,
+  231,    0,    0,    0,    0,    0,    0,    0,    0,  219,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   47,    0,   45,    0,
+    0,   31,   21,    0,    0,    0,   35,   50,    0,   52,
+    0,   40,   10,    0,    0,    0,    0,    0,    0,    0,
+  157,    0,  158,    0,    0,    0,    0,   58,  167,  166,
+    0,    0,    0,    0,    0,  179,  181,    0,    0,    0,
+    0,   85,   88,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   11,    0,    0,  196,  192,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  195,  197,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   43,    0,    0,    0,    0,    0,
+    0,   53,    0,  323,  325,  327,    0,    0,  320,    0,
+  319,  326,  328,  307,    0,    0,    0,   97,  255,  261,
+   99,   98,  292,  289,  291,    0,   72,   74,    0,    0,
+    0,   69,   70,   80,  101,  177,  161,  178,    0,  182,
+    0,    0,  188,   83,   91,   87,   90,    0,    0,   77,
+    0,   71,  190,  190,    0,   84,    0,    0,    0,    0,
+    0,    0,  193,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  198,  199,  200,    0,
+    0,    0,   48,   46,   42,    0,    0,   33,   32,   51,
+   54,    0,    0,    0,    0,  310,  308,    0,    0,    0,
+    0,    0,    0,   82,    0,    0,  163,    0,  164,  180,
+  183,  189,    0,   95,   86,   89,    0,   79,    0,    0,
+    0,  304,   39,    0,  224,  230,    0,    0,  228,    0,
+  217,  194,  220,  221,  222,    0,    0,  235,  236,  223,
+    0,    0,    0,    0,  321,  311,  309,    0,    0,    0,
+    0,    0,  277,    0,    0,  262,    0,    0,    0,  175,
+    0,    0,  173,    0,  165,    0,    0,   93,  159,  160,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  264,  265,  266,  267,  268,  271,    0,
+    0,    0,    0,    0,    0,  273,  276,  279,    0,    0,
+    0,    0,  293,    0,  176,  172,  174,    0,    0,   92,
+    0,    0,  104,  225,  226,  227,  229,  232,  233,  234,
+  324,    0,    0,  269,    0,  272,    0,    0,    0,    0,
+  100,    0,    0,    0,    0,   73,  190,    0,   96,    0,
+    0,    0,    0,    0,    0,    0,  250,  256,    0,    0,
+  297,    0,  294,  169,    0,  168,   94,  322,    0,    0,
+  239,    0,    0,    0,    0,  263,  300,    0,  190,    0,
+  274,  241,    0,  245,  246,  247,    0,  257,  298,  170,
+    0,  243,  251,  284,    0,    0,    0,    0,    0,  107,
+  106,  139,  140,  141,  142,  143,    0,    0,    0,  128,
+  130,    0,    0,  129,    0,  108,    0,    0,    0,  124,
+  132,  136,    0,    0,  285,  258,  275,    0,    0,  190,
+  125,    0,  105,    0,    0,  120,    0,  190,  127,  135,
+  252,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  144,    0,    0,    0,  118,    0,  122,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  131,    0,  110,
+    0,    0,  111,  134,    0,    0,    0,  117,  119,  123,
+  133,    0,    0,  280,    0,  282,    0,    0,    0,    0,
+    0,  126,  109,  282,  286,    0,    0,    0,    0,    0,
+    0,    0,    0,  282,  237,  190,    0,  259,  113,  112,
+    0,  114,  115,  253,    0,  145,  283,    0,  116,    0,
+  287,  260,  254,    0,  288,
+};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yydgoto[] =
+#else
+short yydgoto[] =
 #endif
-
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if defined (__STDC__) || defined (__cplusplus)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     define YYINCLUDED_STDLIB_H
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
-#  endif
-#  ifdef __cplusplus
-extern "C" {
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifdef __cplusplus
-}
-#  endif
-# endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
-
-
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  short int yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (0)
-
+	{                                       5,
+  220,  441,  632,  485,  448,  523,  445,  537,  519,  688,
+  633,  635,  615,  645,  169,  666,  596,  597,  598,  493,
+  201,  677,  489,  100,  442,  396,  567,  106,   87,   88,
+  388,    6,    8,   12,   10,   11,   15,    9,   80,  161,
+  158,  160,  171,  215,   14,    7,   48,   49,   50,   51,
+   52,   53,   54,   55,   56,   57,  205,  117,  188,  403,
+  502,  457,  184,  292,   58,  125,  121,  639,  600,  601,
+  634,  602,  603,  604,  190,  301,  300,  499,  546,  452,
+  453,  198,  199,  182,  389,  554,  576,  642,  700,  390,
+  555,  577,  574,  623,  698,  391,  490,  480,  622,  684,
+  704,  185,  295,  392,  525,   19,   13,   59,   20,  473,
+  471,  382,
+};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yysindex[] =
+#else
+short yysindex[] =
 #endif
-
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
+	{                                     44,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+ -195,    0, -104, 1716, 3004,   30, -221,   51, -104,    0,
+  709,   55,   81,   77,    0,   96,    0, -101,   89,  175,
+  178,  194,  198,  202,  222,  226,    0,    0,  243,  247,
+    0,  250,  268,  281,    0,  287,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   18, -147,    0,
+  -14, -101,   26, 1598,    0,   74,   83,   88,    0,    0,
+  102,  104,  105, 1598,  114,  118,  133,  137,  138,   59,
+ 1598,    0,  148,    0,  353,  366,  367,  302, -221,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  170,  172,    0,    0,  173,  185, -101, -101,
+  186, -101,  -27,    0,  188, -135,  413, -101,  197,  199,
+  420,  137,    0,    0,    0,  342,   61,    0,   72,    0,
+    0, 1598, 1598, 1598,  427,  431,  435,  437,  446,    0,
+  447,  449,  458,  460,  464,  465,  466,  477,  478,  480,
+  482,  484, 1598, 1598, 2024, 1239,    0,  428,    0,  490,
+  -15,    0,    0, 1311, 2958,  491,    0,    0,  494,    0,
+  -11,    0,    0, 2958,  370,  208,  208,  275,  481,  416,
+    0, 1598,    0,  485,  -81,   20,  501,    0,    0,    0,
+  506,  507,  510,  511,  515,    0,    0,  106,  107,   16,
+  520,    0,    0,  518,  -23, -135,  524,  516,  521, 1598,
+   34, -104, 1598, 1598,    0, 1598, 1598,    0,    0, 2035,
+ 1598, 1598, 1598, 1598, 1598,  309,  314, 1598,  318,  323,
+  326, 1598, 1598,  330,  331, 1598, 1598,    0,    0, 1598,
+ 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598,
+ 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598, 1598,
+ 1598, 2958,  336,  337,    0,  338, 1598, 1598, 2958,  -89,
+  339,    0,  340,    0,    0,    0,  540,  542,    0,  344,
+    0,    0,    0,    0,  -35, 2958,  709,    0,    0,    0,
+    0,    0,    0,    0,    0,  347,    0,    0, 1660,  566,
+  -17,    0,    0,    0,    0,    0,    0,    0, -101,    0,
+ -101,  188,    0,    0,    0,    0,    0,  567, -100,    0,
+  182,    0,    0,    0, 2062,    0,  -97, 2958, 2958, 2976,
+ 2958, 2958,    0, 1785, 2074, 2102, 2129, 2140,  564,  568,
+ 2167,  570,  571,  580, 2194, 2322,  581,  583, 2385, 2412,
+ 2439, 3016, 3027, 3142, 1015, 1340, 1388, 1388,  177,  177,
+  177,  177,  517,  517,   78,   78,    0,    0,    0, 2958,
+ 2958, 2958,    0,    0,    0, 2958, 2958,    0,    0,    0,
+    0,  208,  291,  275,  508,    0,    0,  -34, 1450, 1527,
+ 1450, 1598,  586,    0,    6,  574,    0,  173,    0,    0,
+    0,    0, -135,    0,    0,    0,  599,    0,  600,  601,
+  388,    0,    0, 1598,    0,    0, 1598, 1598,    0, 1598,
+    0,    0,    0,    0,    0, 1598, 1598,    0,    0,    0,
+  392, 1598,  596,  603,    0,    0,    0, 1165,  617, 2451,
+  349,  605,    0, 2479,  352,    0, 2958, -220,  412,    0,
+  414,  -18,    0,  359,    0,  369, -135,    0,    0,    0,
+  636, 2506, 2517, 2571, 2582, 2699, 2764,  643, 2958,  275,
+  560,  208,  208,    0,    0,    0,    0,    0,    0,  646,
+ 1598,  132,  631,  653,  417,    0,    0,    0,  349,  573,
+  654,  657,    0,  658,    0,    0,    0,  637,  656,    0,
+  401, -135,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  644,  596,    0, 2775,    0, 1598,  661,  368,  368,
+    0, 1598, -220, 1598,  648,    0,    0,  379,    0,  432,
+  275,  587,  -30, 2823, 1598,  675,    0,    0,  541, 2834,
+    0, 2863,    0,    0,  655,    0,    0,    0,  685,  670,
+    0, 2892, 1598,   49,  606,    0,    0, -220,    0, 1598,
+    0,    0, 2903,    0,    0,    0,  610,    0,    0,    0,
+ 2947,    0,    0,    0,  694, 1022,  -57,  677,  709,    0,
+    0,    0,    0,    0,    0,    0,  697,  699,  700,    0,
+    0,  701,  702,    0,   -6,    0,  707,  710,   18,    0,
+    0,    0, 1022,  628,    0,    0,    0,  -31,  204,    0,
+    0,   48,    0,  717,    9,    0,   -6,    0,    0,    0,
+    0,  635,  703,  722,  723,  725,  727,  730,  732,  733,
+  734,    0,  736,  -33,   13,    0,   31,    0,   -6,  164,
+  737,  703, 1022,  523,  441,   48,   48,    0,   48,    0,
+   48,   48,    0,    0,    0,  743,   48,    0,    0,    0,
+    0,  441,  662,    0,  728,    0,  751,  753,   47,  754,
+  761,    0,    0,    0,    0,  545,   -2,  763,  764,   48,
+  766,  772,   -2,    0,    0,    0,  557,    0,    0,    0,
+  775,    0,    0,    0,   -2,    0,    0,  656,    0,  656,
+    0,    0,    0,  656,    0,};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yyrindex[] =
 #else
-   typedef short int yysigned_char;
+short yyrindex[] =
 #endif
-
-/* YYFINAL -- State number of the termination state. */
-#define YYFINAL  14
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   1716
-
-/* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  140
-/* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  114
-/* YYNRULES -- Number of rules. */
-#define YYNRULES  333
-/* YYNRULES -- Number of states. */
-#define YYNSTATES  707
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   371
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,   138,     2,     2,     2,    34,    21,     2,
-      37,   135,    32,    30,   133,    31,     2,    33,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    16,   134,
-      24,     6,    25,    15,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,   136,     2,   137,    20,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    53,    19,    54,   139,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     7,     8,     9,    10,    11,    12,    13,    14,    17,
-      18,    22,    23,    26,    27,    28,    29,    35,    36,    38,
-      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
-      49,    50,    51,    52,    55,    56,    57,    58,    59,    60,
-      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
-      71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
-      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
-      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
-     101,   102,   103,   104,   105,   106,   107,   108,   109,   110,
-     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
-     121,   122,   123,   124,   125,   126,   127,   128,   129,   130,
-     131,   132
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const unsigned short int yyprhs[] =
-{
-       0,     0,     3,     6,     9,    12,    15,    17,    18,    23,
-      24,    27,    31,    32,    35,    40,    42,    44,    47,    49,
-      54,    59,    63,    66,    71,    75,    80,    85,    90,    95,
-     100,   103,   106,   109,   114,   119,   122,   125,   128,   131,
-     132,   138,   141,   142,   146,   149,   150,   152,   156,   158,
-     162,   163,   165,   169,   171,   174,   178,   179,   182,   185,
-     186,   188,   190,   192,   194,   196,   198,   200,   202,   204,
-     206,   211,   216,   221,   226,   235,   240,   242,   244,   249,
-     250,   256,   261,   262,   268,   273,   278,   280,   284,   287,
-     289,   293,   296,   297,   303,   304,   312,   313,   320,   325,
-     328,   331,   332,   337,   340,   341,   349,   351,   353,   355,
-     357,   363,   368,   373,   381,   389,   397,   405,   414,   417,
-     419,   423,   425,   427,   431,   436,   438,   439,   445,   448,
-     450,   452,   454,   459,   461,   466,   471,   474,   476,   477,
-     479,   481,   483,   485,   487,   489,   491,   494,   495,   497,
-     499,   501,   503,   505,   507,   509,   511,   513,   515,   519,
-     523,   530,   537,   539,   540,   546,   549,   553,   554,   555,
-     563,   567,   571,   572,   576,   578,   581,   583,   586,   591,
-     596,   600,   604,   606,   611,   615,   616,   618,   620,   621,
-     624,   628,   629,   632,   635,   639,   644,   647,   650,   653,
-     657,   661,   665,   669,   673,   677,   681,   685,   689,   693,
-     697,   701,   705,   709,   713,   717,   723,   727,   731,   736,
-     738,   740,   745,   750,   755,   760,   765,   772,   779,   786,
-     791,   798,   803,   805,   812,   819,   826,   831,   836,   840,
-     841,   846,   847,   852,   853,   858,   859,   861,   863,   865,
-     866,   867,   868,   869,   870,   871,   891,   892,   893,   894,
-     895,   896,   915,   916,   917,   925,   927,   929,   931,   933,
-     935,   939,   940,   943,   947,   950,   957,   968,   971,   973,
-     974,   976,   979,   980,   981,   985,   986,   987,   988,   989,
-    1001,  1006,  1007,  1010,  1011,  1012,  1019,  1021,  1022,  1026,
-    1032,  1033,  1037,  1038,  1041,  1042,  1048,  1050,  1053,  1058,
-    1064,  1071,  1073,  1076,  1077,  1080,  1085,  1090,  1099,  1101,
-    1103,  1107,  1111,  1112,  1122,  1123,  1131,  1133,  1137,  1139,
-    1143,  1145,  1149,  1150
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const short int yyrhs[] =
-{
-     141,     0,    -1,   116,   155,    -1,   117,   145,    -1,   127,
-     242,    -1,   118,   143,    -1,     4,    -1,    -1,   144,     4,
-       6,   204,    -1,    -1,   146,   147,    -1,   147,   148,   105,
-      -1,    -1,   100,   204,    -1,   100,   204,   133,   204,    -1,
-       4,    -1,   101,    -1,   107,   150,    -1,   106,    -1,   111,
-       4,     6,   204,    -1,   111,     4,   133,   204,    -1,   111,
-       4,   204,    -1,   110,     4,    -1,   102,     4,   133,   204,
-      -1,   102,     4,   204,    -1,   102,     4,     6,   204,    -1,
-      38,     4,     6,   204,    -1,    38,     4,   133,   204,    -1,
-      94,     4,     6,   204,    -1,    94,     4,   133,   204,    -1,
-     103,   152,    -1,   104,   151,    -1,   108,     4,    -1,   113,
-       4,   133,     4,    -1,   113,     4,   133,     3,    -1,   112,
-     204,    -1,   114,     3,    -1,   119,   153,    -1,   120,   154,
-      -1,    -1,    61,   142,   149,   147,    36,    -1,   121,     4,
-      -1,    -1,   150,   133,     4,    -1,   150,     4,    -1,    -1,
-       4,    -1,   151,   133,     4,    -1,     4,    -1,   152,   133,
-       4,    -1,    -1,     4,    -1,   153,   133,     4,    -1,     4,
-      -1,   154,     4,    -1,   154,   133,     4,    -1,    -1,   156,
-     157,    -1,   157,   158,    -1,    -1,   186,    -1,   165,    -1,
-     234,    -1,   195,    -1,   196,    -1,   198,    -1,   200,    -1,
-     167,    -1,   244,    -1,   134,    -1,    70,    37,     4,   135,
-      -1,    71,    37,   142,   135,    -1,    92,    37,   142,   135,
-      -1,    56,    37,     4,   135,    -1,    56,    37,     4,   133,
-       4,   133,     4,   135,    -1,    58,    37,     4,   135,    -1,
-      57,    -1,    59,    -1,    90,    37,   161,   135,    -1,    -1,
-      91,   159,    37,   161,   135,    -1,    72,    37,   142,   135,
-      -1,    -1,    61,   142,   160,   157,    36,    -1,    85,    37,
-     201,   135,    -1,   120,    37,   154,   135,    -1,     4,    -1,
-     161,   133,     4,    -1,   161,     4,    -1,     5,    -1,   161,
-     133,     5,    -1,   161,     5,    -1,    -1,    99,    37,   162,
-     161,   135,    -1,    -1,   161,   133,    99,    37,   163,   161,
-     135,    -1,    -1,   161,    99,    37,   164,   161,   135,    -1,
-      46,    53,   166,    54,    -1,   166,   210,    -1,   166,   167,
-      -1,    -1,    73,    37,     4,   135,    -1,   184,   183,    -1,
-      -1,   109,   168,    37,   204,   133,     4,   135,    -1,     4,
-      -1,    32,    -1,    15,    -1,   169,    -1,   132,    37,   171,
-     135,   169,    -1,    51,    37,   169,   135,    -1,    52,    37,
-     169,   135,    -1,    51,    37,    52,    37,   169,   135,   135,
-      -1,    51,    37,    51,    37,   169,   135,   135,    -1,    52,
-      37,    51,    37,   169,   135,   135,    -1,    52,    37,    52,
-      37,   169,   135,   135,    -1,    51,    37,   132,    37,   171,
-     135,   169,   135,    -1,   171,   169,    -1,   169,    -1,   172,
-     185,   170,    -1,   170,    -1,     4,    -1,   136,   172,   137,
-      -1,   170,    37,   172,   135,    -1,   173,    -1,    -1,   128,
-      37,   175,   173,   135,    -1,   184,   183,    -1,    89,    -1,
-     134,    -1,    93,    -1,    51,    37,    93,   135,    -1,   174,
-      -1,   179,    37,   202,   135,    -1,    87,    37,   180,   135,
-      -1,   177,   176,    -1,   176,    -1,    -1,   177,    -1,    41,
-      -1,    42,    -1,    43,    -1,    44,    -1,    45,    -1,   202,
-      -1,     6,   180,    -1,    -1,    14,    -1,    13,    -1,    12,
-      -1,    11,    -1,    10,    -1,     9,    -1,     8,    -1,     7,
-      -1,   134,    -1,   133,    -1,     4,     6,   202,    -1,     4,
-     182,   202,    -1,    97,    37,     4,     6,   202,   135,    -1,
-      98,    37,     4,     6,   202,   135,    -1,   133,    -1,    -1,
-      62,    53,   188,   187,    54,    -1,   187,   188,    -1,   187,
-     133,   188,    -1,    -1,    -1,     4,   189,   192,    16,   190,
-     185,   191,    -1,    86,     6,   202,    -1,    88,     6,   202,
-      -1,    -1,    37,   193,   135,    -1,   194,    -1,   193,   194,
-      -1,     4,    -1,   138,     4,    -1,    80,    37,   142,   135,
-      -1,    81,    37,   197,   135,    -1,    81,    37,   135,    -1,
-     197,   185,   142,    -1,   142,    -1,    82,    37,   199,   135,
-      -1,   199,   185,   142,    -1,    -1,    83,    -1,    84,    -1,
-      -1,     4,   201,    -1,     4,   133,   201,    -1,    -1,   203,
-     204,    -1,    31,   204,    -1,    37,   204,   135,    -1,    74,
-      37,   204,   135,    -1,   138,   204,    -1,    30,   204,    -1,
-     139,   204,    -1,   204,    32,   204,    -1,   204,    33,   204,
-      -1,   204,    34,   204,    -1,   204,    30,   204,    -1,   204,
-      31,   204,    -1,   204,    29,   204,    -1,   204,    28,   204,
-      -1,   204,    23,   204,    -1,   204,    22,   204,    -1,   204,
-      27,   204,    -1,   204,    26,   204,    -1,   204,    24,   204,
-      -1,   204,    25,   204,    -1,   204,    21,   204,    -1,   204,
-      20,   204,    -1,   204,    19,   204,    -1,   204,    15,   204,
-      16,   204,    -1,   204,    18,   204,    -1,   204,    17,   204,
-      -1,    69,    37,     4,   135,    -1,     3,    -1,    55,    -1,
-      75,    37,     4,   135,    -1,    76,    37,     4,   135,    -1,
-      77,    37,     4,   135,    -1,   103,    37,   204,   135,    -1,
-      38,    37,   204,   135,    -1,    38,    37,   204,   133,   204,
-     135,    -1,    48,    37,   204,   133,   204,   135,    -1,    49,
-      37,   204,   133,   204,   135,    -1,    50,    37,   204,   135,
-      -1,    60,    37,     4,   133,   204,   135,    -1,    39,    37,
-     204,   135,    -1,     4,    -1,    78,    37,   204,   133,   204,
-     135,    -1,    79,    37,   204,   133,   204,   135,    -1,   109,
-      37,   204,   133,     4,   135,    -1,    86,    37,     4,   135,
-      -1,    88,    37,     4,   135,    -1,    95,    25,     4,    -1,
-      -1,    95,    37,   204,   135,    -1,    -1,    38,    37,   204,
-     135,    -1,    -1,    96,    37,   204,   135,    -1,    -1,   129,
-      -1,   130,    -1,   131,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,     4,   211,   225,   206,   207,   208,   212,   209,    53,
-     213,   178,    54,   214,   228,   205,   229,   181,   215,   185,
-      -1,    -1,    -1,    -1,    -1,    -1,    68,   216,   226,   227,
-     206,   208,   217,    53,   218,   230,    54,   219,   228,   205,
-     229,   181,   220,   185,    -1,    -1,    -1,    91,   221,   225,
-     222,    53,   166,    54,    -1,    64,    -1,    65,    -1,    66,
-      -1,    67,    -1,    68,    -1,    37,   223,   135,    -1,    -1,
-      37,   135,    -1,   204,   224,    16,    -1,   224,    16,    -1,
-      40,    37,   204,   135,   224,    16,    -1,    40,    37,   204,
-     135,    39,    37,   204,   135,   224,    16,    -1,   204,    16,
-      -1,    16,    -1,    -1,    85,    -1,    25,     4,    -1,    -1,
-      -1,   229,    16,     4,    -1,    -1,    -1,    -1,    -1,   230,
-       4,   231,    53,   178,    54,   232,   229,   181,   233,   185,
-      -1,    47,    53,   235,    54,    -1,    -1,   235,   236,    -1,
-      -1,    -1,     4,   237,   239,   240,   238,   134,    -1,   204,
-      -1,    -1,     4,   241,   240,    -1,    95,    37,   204,   135,
-     240,    -1,    -1,    37,   204,   135,    -1,    -1,   243,   246,
-      -1,    -1,   245,   126,    53,   246,    54,    -1,   247,    -1,
-     246,   247,    -1,    53,   249,    54,   134,    -1,   122,    53,
-     249,    54,   134,    -1,   122,    53,   249,    54,   248,   134,
-      -1,   122,    -1,   248,   122,    -1,    -1,   250,   134,    -1,
-     124,    16,   250,   134,    -1,   125,    16,   250,   134,    -1,
-     124,    16,   250,   134,   125,    16,   250,   134,    -1,   123,
-      -1,     4,    -1,   250,   134,   123,    -1,   250,   134,     4,
-      -1,    -1,   250,   134,   120,     4,    53,   251,   250,   253,
-      54,    -1,    -1,   120,     4,    53,   252,   250,   253,    54,
-      -1,   124,    -1,   250,   134,   124,    -1,   125,    -1,   250,
-     134,   125,    -1,   120,    -1,   250,   134,   120,    -1,    -1,
-     134,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short int yyrline[] =
-{
-       0,   162,   162,   163,   164,   165,   169,   173,   173,   183,
-     183,   196,   197,   201,   202,   203,   206,   209,   210,   211,
-     213,   215,   217,   219,   221,   223,   225,   227,   229,   231,
-     233,   234,   235,   237,   239,   241,   243,   245,   246,   248,
-     247,   251,   253,   257,   258,   259,   263,   265,   269,   271,
-     276,   277,   278,   282,   284,   286,   291,   291,   302,   303,
-     309,   310,   311,   312,   313,   314,   315,   316,   317,   318,
-     319,   321,   323,   325,   328,   330,   332,   334,   336,   338,
-     337,   341,   344,   343,   347,   351,   355,   358,   361,   364,
-     367,   370,   374,   373,   378,   377,   382,   381,   388,   392,
-     393,   394,   398,   400,   401,   401,   409,   413,   417,   424,
-     430,   436,   442,   448,   454,   460,   466,   472,   481,   490,
-     501,   510,   521,   529,   533,   540,   542,   541,   548,   549,
-     553,   554,   559,   564,   565,   570,   577,   578,   581,   583,
-     587,   589,   591,   593,   595,   600,   607,   609,   613,   615,
-     617,   619,   621,   623,   625,   627,   632,   632,   637,   641,
-     649,   653,   661,   661,   665,   669,   670,   671,   676,   675,
-     683,   691,   699,   700,   704,   705,   709,   711,   716,   721,
-     722,   727,   729,   735,   737,   739,   743,   745,   751,   754,
-     763,   774,   774,   780,   782,   784,   786,   788,   790,   793,
-     795,   797,   799,   801,   803,   805,   807,   809,   811,   813,
-     815,   817,   819,   821,   823,   825,   827,   829,   831,   833,
-     835,   838,   840,   842,   844,   846,   848,   850,   852,   854,
-     856,   865,   867,   869,   871,   873,   875,   877,   883,   884,
-     888,   889,   893,   894,   898,   899,   903,   904,   905,   906,
-     909,   913,   916,   922,   924,   909,   931,   933,   935,   940,
-     942,   930,   952,   954,   952,   962,   963,   964,   965,   966,
-     970,   971,   972,   976,   977,   982,   983,   988,   989,   994,
-     995,  1000,  1002,  1007,  1010,  1023,  1027,  1032,  1034,  1025,
-    1042,  1045,  1047,  1051,  1052,  1051,  1061,  1106,  1109,  1121,
-    1130,  1133,  1142,  1142,  1156,  1156,  1166,  1167,  1171,  1175,
-    1179,  1186,  1190,  1198,  1201,  1205,  1209,  1213,  1220,  1224,
-    1228,  1232,  1237,  1236,  1250,  1249,  1259,  1263,  1267,  1271,
-    1275,  1279,  1285,  1287
-};
+	{                                      0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    4,   12,    0,  692,    0,  818,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  -36,    0,    0,    0,
+    0,    0,  -19,    0,  760,  765,    0,    0,  692,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  781,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  486,    0,    0,  492,    0,  493,
+  495,    0,    0,    0,  503,    0,    0,    0,  505,    0,
+  522,    0,    0,  823,    0,    0,    0,  708,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  102,  102,  781,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  525,    0,    0,    0,    0,    0,    0,  526,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  -16,
+    0,    0,    0,    0,    0, 1467, 1376,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  461,  776,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  781,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  528,  529,  530,
+  531,  532,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  991,  673,  922,  889,  840,   41,  801,  450,  585,
+  686,  768,  257,  345,    7,  210,    0,    0,    0,  536,
+  539,  543,    0,    0,    0,  544,  547,    0,    0,    0,
+    0,    0,  712,  719,    0,    0,    0,    0,  791,    0,
+  791,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  726,  802,    0,    0,    0,    0,    0,  791,
+   80,    0,    0,    0,   15,    0,  -42,  804,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   86,  741,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  300,    0,    0,    0,  -40,    0,
+  -37,    0,    0,    0,    0,    0,    0,    0,  559,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  726,    0,    0,    0,    0,    0,   11,  744,
+    0,    0,  804,    0,    0,    0,    0,    0,    0,    0,
+  758,    0,  791,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  771,    0,    0,    0,  804,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  791,  777,    0,    0, 1079,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  779,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  167,    0,    0,    0,    0,    0,
+    0,    0,  329,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  167,
+    0,  329,  777,    0,  453,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  192,    0,    0,    0,    0,    0,
+    0,  453,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  244,    0,    0,    0,
+    0,    0,  244,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  -13,    0,    0,  820,    0,  820,
+    0,    0,    0,  -45,    0,};
+#if defined(__cplusplus) || defined(__STDC__)
+const short yygindex[] =
+#else
+short yygindex[] =
 #endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "INT", "NAME", "LNAME", "'='", "OREQ",
-  "ANDEQ", "RSHIFTEQ", "LSHIFTEQ", "DIVEQ", "MULTEQ", "MINUSEQ", "PLUSEQ",
-  "'?'", "':'", "OROR", "ANDAND", "'|'", "'^'", "'&'", "NE", "EQ", "'<'",
-  "'>'", "GE", "LE", "RSHIFT", "LSHIFT", "'+'", "'-'", "'*'", "'/'", "'%'",
-  "UNARY", "END", "'('", "ALIGN_K", "BLOCK", "BIND", "QUAD", "SQUAD",
-  "LONG", "SHORT", "BYTE", "SECTIONS", "PHDRS", "DATA_SEGMENT_ALIGN",
-  "DATA_SEGMENT_RELRO_END", "DATA_SEGMENT_END", "SORT_BY_NAME",
-  "SORT_BY_ALIGNMENT", "'{'", "'}'", "SIZEOF_HEADERS", "OUTPUT_FORMAT",
-  "FORCE_COMMON_ALLOCATION", "OUTPUT_ARCH", "INHIBIT_COMMON_ALLOCATION",
-  "SEGMENT_START", "INCLUDE", "MEMORY", "DEFSYMEND", "NOLOAD", "DSECT",
-  "COPY", "INFO", "OVERLAY", "DEFINED", "TARGET_K", "SEARCH_DIR", "MAP",
-  "ENTRY", "NEXT", "SIZEOF", "ADDR", "LOADADDR", "MAX_K", "MIN_K",
-  "STARTUP", "HLL", "SYSLIB", "FLOAT", "NOFLOAT", "NOCROSSREFS", "ORIGIN",
-  "FILL", "LENGTH", "CREATE_OBJECT_SYMBOLS", "INPUT", "GROUP", "OUTPUT",
-  "CONSTRUCTORS", "ALIGNMOD", "AT", "SUBALIGN", "PROVIDE",
-  "PROVIDE_HIDDEN", "AS_NEEDED", "CHIP", "LIST", "SECT", "ABSOLUTE",
-  "LOAD", "NEWLINE", "ENDWORD", "ORDER", "NAMEWORD", "ASSERT_K", "FORMAT",
-  "PUBLIC", "BASE", "ALIAS", "TRUNCATE", "REL", "INPUT_SCRIPT",
-  "INPUT_MRI_SCRIPT", "INPUT_DEFSYM", "CASE", "EXTERN", "START",
-  "VERS_TAG", "VERS_IDENTIFIER", "GLOBAL", "LOCAL", "VERSIONK",
-  "INPUT_VERSION_SCRIPT", "KEEP", "ONLY_IF_RO", "ONLY_IF_RW", "SPECIAL",
-  "EXCLUDE_FILE", "','", "';'", "')'", "'['", "']'", "'!'", "'~'",
-  "$accept", "file", "filename", "defsym_expr", "@1", "mri_script_file",
-  "@2", "mri_script_lines", "mri_script_command", "@3", "ordernamelist",
-  "mri_load_name_list", "mri_abs_name_list", "casesymlist",
-  "extern_name_list", "script_file", "@4", "ifile_list", "ifile_p1", "@5",
-  "@6", "input_list", "@7", "@8", "@9", "sections", "sec_or_group_p1",
-  "statement_anywhere", "@10", "wildcard_name", "wildcard_spec",
-  "exclude_name_list", "file_NAME_list", "input_section_spec_no_keep",
-  "input_section_spec", "@11", "statement", "statement_list",
-  "statement_list_opt", "length", "fill_exp", "fill_opt", "assign_op",
-  "end", "assignment", "opt_comma", "memory", "memory_spec_list",
-  "memory_spec", "@12", "origin_spec", "length_spec", "attributes_opt",
-  "attributes_list", "attributes_string", "startup", "high_level_library",
-  "high_level_library_NAME_list", "low_level_library",
-  "low_level_library_NAME_list", "floating_point_support",
-  "nocrossref_list", "mustbe_exp", "@13", "exp", "memspec_at_opt",
-  "opt_at", "opt_align", "opt_subalign", "sect_constraint", "section",
-  "@14", "@15", "@16", "@17", "@18", "@19", "@20", "@21", "@22", "@23",
-  "@24", "@25", "type", "atype", "opt_exp_with_type",
-  "opt_exp_without_type", "opt_nocrossrefs", "memspec_opt", "phdr_opt",
-  "overlay_section", "@26", "@27", "@28", "phdrs", "phdr_list", "phdr",
-  "@29", "@30", "phdr_type", "phdr_qualifiers", "phdr_val",
-  "version_script_file", "@31", "version", "@32", "vers_nodes",
-  "vers_node", "verdep", "vers_tag", "vers_defns", "@33", "@34",
-  "opt_semicolon", 0
+	{                                      0,
+  -61,  459,  -95,  408,    0,    0,    0,  380,    0, -576,
+  215,  256,  289,  265,    0,  246, 1064, -521,    0, -474,
+ -166, -545,    0,    0, -405,    0,    0,  642,  -79,  821,
+    0,    0,    0,    0,    0,    0,  698,    0,    0,    0,
+    0,    0,  787,    0,  724,    0,    0,    0,    0,    0,
+    0,    0,    0,    0, -178,    0, -164,    0,    0,    0,
+    0,    0,  394,    0, -489,  317,    0, -197,  283,    0,
+    0,  316,    0,  280, -255,    0,    0,    0,    0,    0,
+  472,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  715,    0,    0,   -3,    0,
+  422,    0,
 };
+#define YYTABLESIZE 3417
+#if defined(__cplusplus) || defined(__STDC__)
+const short yytable[] =
+#else
+short yytable[] =
 #endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const unsigned short int yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,    61,   261,   262,   263,
-     264,   265,   266,   267,   268,    63,    58,   269,   270,   124,
-      94,    38,   271,   272,    60,    62,   273,   274,   275,   276,
-      43,    45,    42,    47,    37,   277,   278,    40,   279,   280,
-     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
-     291,   292,   293,   123,   125,   294,   295,   296,   297,   298,
-     299,   300,   301,   302,   303,   304,   305,   306,   307,   308,
-     309,   310,   311,   312,   313,   314,   315,   316,   317,   318,
-     319,   320,   321,   322,   323,   324,   325,   326,   327,   328,
-     329,   330,   331,   332,   333,   334,   335,   336,   337,   338,
-     339,   340,   341,   342,   343,   344,   345,   346,   347,   348,
-     349,   350,   351,   352,   353,   354,   355,   356,   357,   358,
-     359,   360,   361,   362,   363,   364,   365,   366,   367,   368,
-     369,   370,   371,    44,    59,    41,    91,    93,    33,   126
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
-{
-       0,   140,   141,   141,   141,   141,   142,   144,   143,   146,
-     145,   147,   147,   148,   148,   148,   148,   148,   148,   148,
-     148,   148,   148,   148,   148,   148,   148,   148,   148,   148,
-     148,   148,   148,   148,   148,   148,   148,   148,   148,   149,
-     148,   148,   148,   150,   150,   150,   151,   151,   152,   152,
-     153,   153,   153,   154,   154,   154,   156,   155,   157,   157,
-     158,   158,   158,   158,   158,   158,   158,   158,   158,   158,
-     158,   158,   158,   158,   158,   158,   158,   158,   158,   159,
-     158,   158,   160,   158,   158,   158,   161,   161,   161,   161,
-     161,   161,   162,   161,   163,   161,   164,   161,   165,   166,
-     166,   166,   167,   167,   168,   167,   169,   169,   169,   170,
-     170,   170,   170,   170,   170,   170,   170,   170,   171,   171,
-     172,   172,   173,   173,   173,   174,   175,   174,   176,   176,
-     176,   176,   176,   176,   176,   176,   177,   177,   178,   178,
-     179,   179,   179,   179,   179,   180,   181,   181,   182,   182,
-     182,   182,   182,   182,   182,   182,   183,   183,   184,   184,
-     184,   184,   185,   185,   186,   187,   187,   187,   189,   188,
-     190,   191,   192,   192,   193,   193,   194,   194,   195,   196,
-     196,   197,   197,   198,   199,   199,   200,   200,   201,   201,
-     201,   203,   202,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,   204,   204,   204,   204,   205,   205,
-     206,   206,   207,   207,   208,   208,   209,   209,   209,   209,
-     211,   212,   213,   214,   215,   210,   216,   217,   218,   219,
-     220,   210,   221,   222,   210,   223,   223,   223,   223,   223,
-     224,   224,   224,   225,   225,   225,   225,   226,   226,   227,
-     227,   228,   228,   229,   229,   230,   231,   232,   233,   230,
-     234,   235,   235,   237,   238,   236,   239,   240,   240,   240,
-     241,   241,   243,   242,   245,   244,   246,   246,   247,   247,
-     247,   248,   248,   249,   249,   249,   249,   249,   250,   250,
-     250,   250,   251,   250,   252,   250,   250,   250,   250,   250,
-     250,   250,   253,   253
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
-{
-       0,     2,     2,     2,     2,     2,     1,     0,     4,     0,
-       2,     3,     0,     2,     4,     1,     1,     2,     1,     4,
-       4,     3,     2,     4,     3,     4,     4,     4,     4,     4,
-       2,     2,     2,     4,     4,     2,     2,     2,     2,     0,
-       5,     2,     0,     3,     2,     0,     1,     3,     1,     3,
-       0,     1,     3,     1,     2,     3,     0,     2,     2,     0,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       4,     4,     4,     4,     8,     4,     1,     1,     4,     0,
-       5,     4,     0,     5,     4,     4,     1,     3,     2,     1,
-       3,     2,     0,     5,     0,     7,     0,     6,     4,     2,
-       2,     0,     4,     2,     0,     7,     1,     1,     1,     1,
-       5,     4,     4,     7,     7,     7,     7,     8,     2,     1,
-       3,     1,     1,     3,     4,     1,     0,     5,     2,     1,
-       1,     1,     4,     1,     4,     4,     2,     1,     0,     1,
-       1,     1,     1,     1,     1,     1,     2,     0,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     1,     3,     3,
-       6,     6,     1,     0,     5,     2,     3,     0,     0,     7,
-       3,     3,     0,     3,     1,     2,     1,     2,     4,     4,
-       3,     3,     1,     4,     3,     0,     1,     1,     0,     2,
-       3,     0,     2,     2,     3,     4,     2,     2,     2,     3,
-       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
-       3,     3,     3,     3,     3,     5,     3,     3,     4,     1,
-       1,     4,     4,     4,     4,     4,     6,     6,     6,     4,
-       6,     4,     1,     6,     6,     6,     4,     4,     3,     0,
-       4,     0,     4,     0,     4,     0,     1,     1,     1,     0,
-       0,     0,     0,     0,     0,    19,     0,     0,     0,     0,
-       0,    18,     0,     0,     7,     1,     1,     1,     1,     1,
-       3,     0,     2,     3,     2,     6,    10,     2,     1,     0,
-       1,     2,     0,     0,     3,     0,     0,     0,     0,    11,
-       4,     0,     2,     0,     0,     6,     1,     0,     3,     5,
-       0,     3,     0,     2,     0,     5,     1,     2,     4,     5,
-       6,     1,     2,     0,     2,     4,     4,     8,     1,     1,
-       3,     3,     0,     9,     0,     7,     1,     3,     1,     3,
-       1,     3,     0,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const unsigned short int yydefact[] =
-{
-       0,    56,     9,     7,   302,     0,     2,    59,     3,    12,
-       5,     0,     4,     0,     1,    57,    10,     0,   313,     0,
-     303,   306,     0,     0,     0,     0,    76,     0,    77,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,   186,   187,
-       0,     0,    79,     0,     0,     0,   104,     0,    69,    58,
-      61,    67,     0,    60,    63,    64,    65,    66,    62,    68,
-       0,    15,     0,     0,     0,     0,    16,     0,     0,     0,
-      18,    45,     0,     0,     0,     0,     0,     0,    50,     0,
-       0,     0,     0,   319,   330,   318,   326,   328,     0,     0,
-     313,   307,   191,   155,   154,   153,   152,   151,   150,   149,
-     148,   191,   101,   291,     0,     0,     6,    82,     0,     0,
-       0,     0,     0,     0,     0,   185,   188,     0,     0,     0,
-       0,     0,     0,     0,   157,   156,   103,     0,     0,    39,
-       0,   219,   232,     0,     0,     0,     0,     0,     0,     0,
-       0,   220,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    13,     0,    48,    30,
-      46,    31,    17,    32,    22,     0,    35,     0,    36,    51,
-      37,    53,    38,    41,    11,     8,     0,     0,     0,     0,
-     314,     0,   158,     0,   159,     0,     0,     0,     0,    59,
-     168,   167,     0,     0,     0,     0,     0,   180,   182,   163,
-     163,   188,     0,    86,    89,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    12,     0,     0,   197,
-     193,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,   196,
-     198,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,    24,     0,     0,    44,     0,     0,     0,
-      21,     0,     0,    54,     0,   324,   326,   328,     0,     0,
-     308,   321,   331,   320,   327,   329,     0,   192,   250,    98,
-     256,   262,   100,    99,   293,   290,   292,     0,    73,    75,
-     304,   172,     0,    70,    71,    81,   102,   178,   162,   179,
-       0,   183,     0,   188,   189,    84,    92,    88,    91,     0,
-       0,    78,     0,    72,   191,   191,     0,    85,     0,    26,
-      27,    42,    28,    29,   194,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,   217,   216,   214,   213,   212,   207,   206,
-     210,   211,   209,   208,   205,   204,   202,   203,   199,   200,
-     201,    14,    25,    23,    49,    47,    43,    19,    20,    34,
-      33,    52,    55,     0,   315,   316,     0,   311,   309,     0,
-     271,     0,   271,     0,     0,    83,     0,     0,   164,     0,
-     165,   181,   184,   190,     0,    96,    87,    90,     0,    80,
-       0,     0,     0,   305,    40,     0,   225,   231,     0,     0,
-     229,     0,   218,   195,   221,   222,   223,     0,     0,   236,
-     237,   224,     0,     0,   332,   329,   322,   312,   310,     0,
-       0,   271,     0,   241,   278,     0,   279,   263,   296,   297,
-       0,   176,     0,     0,   174,     0,   166,     0,     0,    94,
-     160,   161,     0,     0,     0,     0,     0,     0,     0,     0,
-     215,   333,     0,     0,     0,   265,   266,   267,   268,   269,
-     272,     0,     0,     0,     0,   274,     0,   243,   277,   280,
-     241,     0,   300,     0,   294,     0,   177,   173,   175,     0,
-     163,    93,     0,     0,   105,   226,   227,   228,   230,   233,
-     234,   235,   325,     0,   332,   270,     0,   273,     0,     0,
-     245,   245,   101,     0,   297,     0,     0,    74,   191,     0,
-      97,     0,   317,     0,   271,     0,     0,     0,   251,   257,
-       0,     0,   298,     0,   295,   170,     0,   169,    95,   323,
-       0,     0,   240,     0,     0,   249,     0,   264,   301,   297,
-     191,     0,   275,   242,     0,   246,   247,   248,     0,   258,
-     299,   171,     0,   244,   252,   285,   271,   138,     0,     0,
-     122,   108,   107,   140,   141,   142,   143,   144,     0,     0,
-       0,   129,   131,     0,     0,   130,     0,   109,     0,   125,
-     133,   137,   139,     0,     0,     0,   286,   259,   276,     0,
-       0,   191,   126,     0,   106,     0,   121,   163,     0,   136,
-     253,   191,   128,     0,   282,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,   145,     0,   119,     0,     0,   123,
-       0,   163,   282,     0,   138,     0,   239,     0,     0,   132,
-       0,   111,     0,     0,   112,   135,   106,     0,     0,   118,
-     120,   124,   239,   134,     0,   281,     0,   283,     0,     0,
-       0,     0,     0,   127,   110,   283,   287,     0,   147,     0,
-       0,     0,     0,     0,   147,   283,   238,   191,     0,   260,
-     114,   113,     0,   115,   116,   254,   147,   146,   284,   163,
-     117,   163,   288,   261,   255,   163,   289
-};
-
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short int yydefgoto[] =
-{
-      -1,     5,   107,    10,    11,     8,     9,    16,    81,   216,
-     162,   161,   159,   170,   172,     6,     7,    15,    49,   118,
-     189,   206,   404,   503,   458,    50,   185,    51,   122,   597,
-     598,   637,   617,   599,   600,   635,   601,   602,   603,   604,
-     633,   689,   101,   126,    52,   640,    53,   302,   191,   301,
-     500,   547,   397,   453,   454,    54,    55,   199,    56,   200,
-      57,   202,   634,   183,   221,   667,   487,   520,   538,   568,
-     293,   390,   555,   577,   642,   701,   391,   556,   575,   624,
-     699,   392,   491,   481,   442,   443,   446,   490,   646,   678,
-     578,   623,   685,   705,    58,   186,   296,   393,   526,   449,
-     494,   524,    12,    13,    59,    60,    20,    21,   389,    88,
-      89,   474,   383,   472
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -601
-static const short int yypact[] =
-{
-     110,  -601,  -601,  -601,  -601,    51,  -601,  -601,  -601,  -601,
-    -601,    14,  -601,    -9,  -601,   696,  1513,    59,    97,   -21,
-      -9,  -601,   860,    36,    44,    92,  -601,   103,  -601,   144,
-     120,   141,   164,   168,   179,   181,   187,   198,  -601,  -601,
-     212,   223,  -601,   255,   258,   261,  -601,   262,  -601,  -601,
-    -601,  -601,    76,  -601,  -601,  -601,  -601,  -601,  -601,  -601,
-     174,  -601,   232,   144,   297,   589,  -601,   301,   302,   305,
-    -601,  -601,   306,   309,   310,   589,   311,   313,   314,   316,
-     317,   221,   589,  -601,   328,  -601,   320,   324,   279,   205,
-      97,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,
-    -601,  -601,  -601,  -601,   337,   338,  -601,  -601,   344,   345,
-     144,   144,   346,   144,    35,  -601,   348,    26,   321,   144,
-     350,   359,   327,   316,  -601,  -601,  -601,   319,     9,  -601,
-      41,  -601,  -601,   589,   589,   589,   339,   340,   347,   355,
-     364,  -601,   365,   366,   367,   374,   375,   376,   381,   384,
-     385,   387,   394,   395,   589,   589,  1322,   331,  -601,   249,
-    -601,   250,    17,  -601,  -601,   445,  1682,   254,  -601,  -601,
-     263,  -601,    18,  -601,  -601,  1682,   380,   199,   199,   304,
-     265,   390,  -601,   589,  -601,   369,    46,   -90,   300,  -601,
-    -601,  -601,   312,   315,   318,   330,   336,  -601,  -601,   119,
-     131,    32,   342,  -601,  -601,   402,    12,    26,   353,   435,
-     439,   589,    69,    -9,   589,   589,  -601,   589,   589,  -601,
-    -601,   905,   589,   589,   589,   589,   589,   442,   448,   589,
-     450,   454,   455,   589,   589,   468,   469,   589,   589,  -601,
-    -601,   589,   589,   589,   589,   589,   589,   589,   589,   589,
-     589,   589,   589,   589,   589,   589,   589,   589,   589,   589,
-     589,   589,   589,  1682,   475,   477,  -601,   481,   589,   589,
-    1682,   226,   485,  -601,   486,  -601,  -601,  -601,   357,   368,
-    -601,  -601,   492,  -601,  -601,  -601,   -48,  1682,   860,  -601,
-    -601,  -601,  -601,  -601,  -601,  -601,  -601,   500,  -601,  -601,
-     767,   471,    10,  -601,  -601,  -601,  -601,  -601,  -601,  -601,
-     144,  -601,   144,   348,  -601,  -601,  -601,  -601,  -601,   472,
-      78,  -601,    24,  -601,  -601,  -601,  1342,  -601,   -12,  1682,
-    1682,  1535,  1682,  1682,  -601,   885,   925,  1362,  1382,   945,
-     373,   377,   965,   378,   382,   383,  1439,  1459,   391,   392,
-    1004,  1479,  1642,   982,  1121,  1259,  1397,   707,   677,   677,
-     573,   573,   573,   573,   210,   210,   247,   247,  -601,  -601,
-    -601,  1682,  1682,  1682,  -601,  -601,  -601,  1682,  1682,  -601,
-    -601,  -601,  -601,   199,   274,   265,   457,  -601,  -601,   -46,
-      30,   512,    30,   589,   397,  -601,     8,   495,  -601,   344,
-    -601,  -601,  -601,  -601,    26,  -601,  -601,  -601,   488,  -601,
-     399,   400,   528,  -601,  -601,   589,  -601,  -601,   589,   589,
-    -601,   589,  -601,  -601,  -601,  -601,  -601,   589,   589,  -601,
-    -601,  -601,   534,   589,   405,   525,  -601,  -601,  -601,   208,
-     507,  1501,   529,   451,  -601,  1662,   462,  -601,  1682,    19,
-     548,  -601,   549,     6,  -601,   470,  -601,   115,    26,  -601,
-    -601,  -601,   420,  1024,  1044,  1064,  1084,  1104,  1143,   422,
-    1682,   265,   504,   199,   199,  -601,  -601,  -601,  -601,  -601,
-    -601,   424,   589,   362,   547,  -601,   531,   532,  -601,  -601,
-     451,   513,   536,   539,  -601,   434,  -601,  -601,  -601,   565,
-     449,  -601,   126,    26,  -601,  -601,  -601,  -601,  -601,  -601,
-    -601,  -601,  -601,   460,   405,  -601,  1163,  -601,   589,   558,
-     503,   503,  -601,   589,    19,   589,   476,  -601,  -601,   508,
-    -601,   132,   265,   555,    87,  1183,   589,   574,  -601,  -601,
-     389,  1203,  -601,  1223,  -601,  -601,   606,  -601,  -601,  -601,
-     576,   598,  -601,  1243,   589,   159,   563,  -601,  -601,    19,
-    -601,   589,  -601,  -601,  1282,  -601,  -601,  -601,   564,  -601,
-    -601,  -601,  1302,  -601,  -601,  -601,   581,   628,    48,   607,
-     675,  -601,  -601,  -601,  -601,  -601,  -601,  -601,   585,   587,
-     588,  -601,  -601,   592,   593,  -601,   219,  -601,   594,  -601,
-    -601,  -601,   628,   579,   597,    76,  -601,  -601,  -601,   323,
-     363,  -601,  -601,    62,  -601,   599,  -601,    -5,   219,  -601,
-    -601,  -601,  -601,   582,   615,   604,   605,   510,   609,   517,
-     610,   611,   518,   519,  -601,    83,  -601,    23,   293,  -601,
-     219,   158,   615,   520,   628,   652,   562,    62,    62,  -601,
-      62,  -601,    62,    62,  -601,  -601,   524,   526,    62,  -601,
-    -601,  -601,   562,  -601,   608,  -601,   649,  -601,   541,   543,
-      31,   556,   559,  -601,  -601,  -601,  -601,   686,    42,   560,
-     561,    62,   578,   583,    42,  -601,  -601,  -601,   689,  -601,
-    -601,  -601,   584,  -601,  -601,  -601,    42,  -601,  -601,   449,
-    -601,   449,  -601,  -601,  -601,   449,  -601
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const short int yypgoto[] =
-{
-    -601,  -601,   -57,  -601,  -601,  -601,  -601,   483,  -601,  -601,
-    -601,  -601,  -601,  -601,   591,  -601,  -601,   527,  -601,  -601,
-    -601,  -196,  -601,  -601,  -601,  -601,   175,  -180,  -601,   -73,
-    -559,    70,   104,    88,  -601,  -601,   122,  -601,   100,  -601,
-      58,  -600,  -601,   142,  -553,  -198,  -601,  -601,  -277,  -601,
-    -601,  -601,  -601,  -601,   295,  -601,  -601,  -601,  -601,  -601,
-    -601,  -175,   -92,  -601,   -62,    84,   259,  -601,   229,  -601,
-    -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,
-    -601,  -601,  -601,  -601,  -422,   371,  -601,  -601,   109,  -558,
-    -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,  -601,
-    -484,  -601,  -601,  -601,  -601,  -601,   546,   -16,  -601,   671,
-    -170,  -601,  -601,   251
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -305
-static const short int yytable[] =
-{
-     182,   310,   312,   156,    91,   292,   129,   278,   279,   184,
-     451,   322,   451,   166,   190,   214,   317,   318,    17,   484,
-     175,   266,   273,   492,   605,   400,   314,   614,   317,   318,
-     203,   204,    90,   131,   132,   614,   201,   616,   581,   106,
-     542,    18,   413,   297,    18,   298,   581,   217,   687,   605,
-     294,    14,   606,   193,   194,   582,   196,   198,   688,   616,
-     133,   134,   208,   582,   398,    82,   614,   439,   136,   137,
-     440,   219,   220,   273,   387,   570,   437,   581,   138,   139,
-     140,   660,   406,   407,   695,   141,   388,   656,   438,   102,
-     142,   605,   239,   240,   582,   263,   702,   103,   581,   143,
-     295,    83,   607,   270,   144,   145,   146,   147,   148,   149,
-      19,   319,   551,    19,   493,   582,   150,   684,   151,   317,
-     318,   287,   456,   319,   483,   205,   550,   696,   308,   104,
-     317,   318,   639,   152,   615,   589,   317,   318,   403,   153,
-     105,   497,   215,   399,   452,   320,   452,   321,   106,   326,
-     267,   274,   329,   330,   579,   332,   333,   320,   658,   409,
-     335,   336,   337,   338,   339,   313,   681,   342,   154,   155,
-     197,   346,   347,   108,   218,   350,   351,   408,   109,   352,
+	{                                     181,
+  309,  311,  155,   56,  183,  291,  201,   49,  581,  482,
+  581,    9,  165,  196,  451,   90,  295,  320,   17,  174,
+  319,  299,  496,  387,  437,   17,  398,  412,  266,  580,
+  146,  580,  273,  313,  483,  581,   82,  491,  451,  329,
+  205,  321,  330,  294,  201,  399,  201,  201,  541,  201,
+  201,  201,  307,  657,  581,  687,  580,  595,  686,  312,
+  297,  123,   16,  296,  201,  201,  201,  606,  201,  201,
+  218,  219,  581,  616,  326,  580,  124,  273,  205,  162,
+  205,  205,  240,  569,  205,  214,  599,  680,  581,  581,
+   81,  238,  239,  580,  262,  616,  277,  278,  205,  205,
+  201,  638,  269,  205,  214,  329,  694,  397,  330,  580,
+  580,  146,  492,  599,  258,  217,  103,  659,  701,  256,
+  286,  213,  202,  203,  257,  214,  214,  550,  683,  214,
+  201,  201,  216,  244,  205,  104,   83,  278,  695,   84,
+   85,   86,  455,  214,  214,  402,  308,  310,  325,  307,
+  307,  328,  329,  599,  331,  332,  105,  405,  406,  334,
+  335,  336,  337,  338,  205,  205,  341,  378,  379,  578,
+  345,  346,  479,   89,  349,  350,  293,  101,  351,  352,
      353,   354,   355,   356,   357,   358,   359,   360,   361,   362,
      363,   364,   365,   366,   367,   368,   369,   370,   371,   372,
-     373,   110,   274,    83,   327,   111,   377,   378,   457,   124,
-     125,   131,   132,   434,   319,   594,   112,    84,   113,   596,
-      85,    86,    87,   614,   114,   319,     1,     2,     3,   379,
-     380,   319,   410,   411,   581,   115,   128,     4,   133,   134,
-     255,   256,   257,   258,   259,   135,   136,   137,   320,   116,
-     501,   582,   308,   401,   309,   402,   138,   139,   140,   320,
-     117,   530,   502,   141,   308,   320,   311,   548,   142,   281,
-     615,   589,   475,   476,   477,   478,   479,   143,   281,   257,
-     258,   259,   144,   145,   146,   147,   148,   149,   565,   566,
-     567,   308,   119,   661,   150,   120,   151,   614,   121,   123,
-     127,   130,   529,   513,   514,   157,   158,   531,   581,   160,
-     163,   152,    91,   164,   165,   167,   168,   153,   169,    84,
-     171,   173,    85,   276,   277,   582,   174,   614,   441,   445,
-     441,   448,   176,   179,   131,   132,   177,   261,   581,   180,
-     178,   187,   188,   480,   625,   626,   154,   155,   190,   192,
-     195,   594,   201,   463,   209,   582,   464,   465,   207,   466,
-     292,   133,   134,   210,   211,   467,   468,   614,   135,   136,
-     137,   470,   213,   288,   625,   626,   222,   223,   581,   138,
-     139,   140,   264,   265,   224,   282,   141,   271,   283,   284,
-     285,   142,   225,   288,   282,   582,   272,   283,   284,   435,
-     143,   226,   227,   228,   229,   144,   145,   146,   147,   148,
-     149,   230,   231,   232,   630,   631,   627,   150,   233,   151,
-     516,   234,   235,   289,   236,   628,   475,   476,   477,   478,
-     479,   237,   238,   275,   152,   299,   545,   290,   280,   316,
-     153,   324,    34,   557,   286,   325,   340,   303,   131,   132,
-     304,   268,   341,   305,   343,   628,   535,   290,   344,   345,
-     291,   541,    34,   543,   262,   306,    44,    45,   571,   154,
-     155,   307,   348,   349,   553,   133,   134,   315,    46,   374,
-     291,   375,   135,   136,   137,   376,    44,    45,   323,   381,
-     382,   384,   564,   138,   139,   140,   386,   480,    46,   572,
-     141,   703,   385,   704,   394,   142,   421,   706,   396,   405,
-     436,   455,   422,   424,   143,   131,   132,   425,   426,   144,
-     145,   146,   147,   148,   149,   459,   429,   430,   444,   643,
-     450,   150,   462,   151,   460,   461,   629,   632,   469,   471,
-     636,   473,   133,   134,   482,   485,   486,   489,   152,   135,
-     136,   137,   495,   496,   153,   504,   499,   511,   512,   515,
-     138,   139,   140,   517,   659,   629,   522,   141,   518,   527,
-     519,   528,   142,   523,   668,   669,   525,   636,   269,   671,
-     672,   143,   308,   154,   155,   674,   144,   145,   146,   147,
-     148,   149,   131,   132,   532,   536,   546,   659,   150,   537,
-     151,   253,   254,   255,   256,   257,   258,   259,   692,   549,
-     544,   554,   560,   561,   562,   152,   569,   574,   483,   133,
-     134,   153,   609,   608,   610,   611,   135,   136,   137,   612,
-     613,   618,   580,   620,   621,   644,   638,   138,   139,   140,
-     645,   647,   648,   581,   141,   649,   650,   652,   653,   142,
-     154,   155,   651,   654,   655,   663,   665,   666,   143,  -122,
-     582,   673,   676,   144,   145,   146,   147,   148,   149,   583,
-     584,   585,   586,   587,   677,   150,   679,   151,   680,   588,
-     589,    92,    93,    94,    95,    96,    97,    98,    99,   100,
-     686,   682,   152,   698,   683,   690,   691,   540,   153,   331,
-      22,   249,   250,   251,   252,   253,   254,   255,   256,   257,
-     258,   259,  -106,   693,   212,   590,   300,   591,   694,   700,
-     670,   592,   641,   657,   619,    44,    45,   154,   155,   247,
-     248,   249,   250,   251,   252,   253,   254,   255,   256,   257,
-     258,   259,    23,    24,   664,   697,   675,   622,   498,   521,
-     539,   662,    25,    26,    27,    28,   593,    29,    30,   328,
-     594,   181,   595,   447,   596,   533,    31,    32,    33,    34,
-       0,    22,     0,     0,     0,     0,    35,    36,    37,    38,
-      39,    40,     0,     0,     0,     0,    41,    42,    43,     0,
-       0,     0,     0,    44,    45,     0,     0,     0,     0,     0,
-       0,     0,     0,   395,     0,    46,     0,     0,     0,     0,
-       0,     0,     0,    23,    24,     0,    47,     0,     0,     0,
-       0,     0,  -304,    25,    26,    27,    28,     0,    29,    30,
-      48,     0,     0,     0,     0,     0,     0,    31,    32,    33,
-      34,     0,     0,     0,     0,     0,     0,    35,    36,    37,
-      38,    39,    40,     0,     0,     0,     0,    41,    42,    43,
-       0,     0,     0,     0,    44,    45,    92,    93,    94,    95,
-      96,    97,    98,    99,   100,     0,    46,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    47,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     241,    48,   242,   243,   244,   245,   246,   247,   248,   249,
-     250,   251,   252,   253,   254,   255,   256,   257,   258,   259,
-     241,     0,   242,   243,   244,   245,   246,   247,   248,   249,
-     250,   251,   252,   253,   254,   255,   256,   257,   258,   259,
-     241,     0,   242,   243,   244,   245,   246,   247,   248,   249,
-     250,   251,   252,   253,   254,   255,   256,   257,   258,   259,
-     241,     0,   242,   243,   244,   245,   246,   247,   248,   249,
-     250,   251,   252,   253,   254,   255,   256,   257,   258,   259,
-     241,     0,   242,   243,   244,   245,   246,   247,   248,   249,
-     250,   251,   252,   253,   254,   255,   256,   257,   258,   259,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,     0,   415,   241,
-     416,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   241,
-     334,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   241,
-     417,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   241,
-     420,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   241,
-     423,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   241,
-       0,   242,   243,   244,   245,   246,   247,   248,   249,   250,
-     251,   252,   253,   254,   255,   256,   257,   258,   259,   431,
-     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,
-     254,   255,   256,   257,   258,   259,     0,     0,   241,   505,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   241,   506,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   241,   507,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   241,   508,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   241,   509,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   241,     0,
-     242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
-     252,   253,   254,   255,   256,   257,   258,   259,   510,   245,
-     246,   247,   248,   249,   250,   251,   252,   253,   254,   255,
-     256,   257,   258,   259,     0,     0,     0,   241,   534,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,   552,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,   558,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,   559,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,   563,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,     0,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   573,   246,   247,
-     248,   249,   250,   251,   252,   253,   254,   255,   256,   257,
-     258,   259,     0,     0,     0,     0,     0,   576,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,   241,   260,   242,   243,   244,   245,
-     246,   247,   248,   249,   250,   251,   252,   253,   254,   255,
-     256,   257,   258,   259,   241,   412,   242,   243,   244,   245,
-     246,   247,   248,   249,   250,   251,   252,   253,   254,   255,
-     256,   257,   258,   259,   241,   418,   242,   243,   244,   245,
-     246,   247,   248,   249,   250,   251,   252,   253,   254,   255,
-     256,   257,   258,   259,     0,   419,   241,    61,   242,   243,
-     244,   245,   246,   247,   248,   249,   250,   251,   252,   253,
-     254,   255,   256,   257,   258,   259,     0,     0,   483,    61,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,    62,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,   414,   427,    62,    63,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,   428,     0,     0,     0,    63,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    64,     0,     0,
-       0,     0,   432,    65,    66,    67,    68,    69,   -42,    70,
-      71,    72,     0,    73,    74,    75,    76,    77,     0,    64,
-       0,     0,    78,    79,    80,    65,    66,    67,    68,    69,
-       0,    70,    71,    72,     0,    73,    74,    75,    76,    77,
-       0,     0,     0,     0,    78,    79,    80,   241,   433,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,   488,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259,   241,     0,   242,
-     243,   244,   245,   246,   247,   248,   249,   250,   251,   252,
-     253,   254,   255,   256,   257,   258,   259
+  605,  204,  240,  102,  660,  376,  377,  307,  162,  202,
+  214,  107,  162,  258,  108,  295,  126,  109,  256,  254,
+  299,  255,  408,  257,  655,  319,  613,  409,  410,  162,
+  105,  105,  121,  110,  316,  317,  407,  111,  456,  450,
+  189,  112,  265,  127,  146,  581,  272,  202,  549,  202,
+  202,  613,  202,  202,  202,   18,  203,  614,  588,  624,
+  625,  113,   18,  450,  201,  114,  580,  202,  202,  202,
+  613,  202,  202,  200,  201,  201,  201,  201,  201,  201,
+  201,  201,  115,  129,  614,  588,  116,  146,  613,  118,
+  295,  272,  501,  240,  203,  299,  203,  203,  205,  626,
+  203,  528,  433,  202,  613,  613,   49,  119,  205,  205,
+  205,  205,  201,  318,  203,  203,  203,  201,  203,  203,
+  120,  624,  625,   90,  386,  436,  122,  440,  444,  440,
+  447,  156,  201,  202,  202,  201,  593,  530,  627,  201,
+  157,  201,  201,  214,  204,  159,  205,  278,  278,  201,
+  203,  205,  462,  201,   41,  463,  464,  240,  465,  162,
+  291,  163,  164,  593,  466,  467,  205,  303,  146,  205,
+  469,  166,  281,  205,  167,  205,  205,  244,  244,  244,
+  203,  203,  204,  205,  204,  204,  281,  205,  204,  281,
+  168,  214,  512,  513,  170,  172,  214,    1,    2,    3,
+  627,  173,  204,  204,  204,  175,  204,  204,    4,  500,
+  176,  214,  319,  240,  214,  564,  565,  566,  214,  515,
+  214,  214,  242,  177,  162,  178,  179,  186,  214,  187,
+  189,  544,  214,  474,  475,  476,  477,  478,  204,  316,
+  317,  529,  191,  194,  319,  200,  240,  240,  240,  209,
+  252,  253,  206,  281,  208,  534,  209,  162,  162,  210,
+  540,  613,  542,  570,  212,   82,  221,  202,  204,  204,
+  222,  263,  547,  552,  223,  319,  224,  202,  202,  202,
+  202,  202,  202,  202,  202,  225,  226,  209,  227,  209,
+  209,  563,  274,  209,  629,  630,  238,  228,  571,  229,
+  702,  146,  703,  230,  231,  232,  705,  209,  209,  209,
+  238,  209,  209,  238,  203,  202,  233,  234,  318,  235,
+  202,  236,  641,  237,  203,  203,  203,  203,  203,  203,
+  203,  203,  279,  264,  270,  202,  162,  271,  202,  284,
+  285,  298,  202,  209,  202,  202,  302,  303,  279,  146,
+  304,  305,  202,  258,  146,  306,  202,  315,  256,  254,
+  314,  255,  203,  257,  322,   83,  339,  203,   84,  275,
+  276,  340,  146,  209,  209,  342,  323,  238,  146,  146,
+  343,  324,  203,  344,  210,  203,  281,  347,  348,  203,
+  146,  203,  203,  373,  374,  375,  380,  381,  383,  203,
+  384,  385,  204,  203,  393,  395,  404,  420,  421,  288,
+  423,  424,  204,  204,  204,  204,  204,  204,  204,  204,
+  425,  428,  210,  429,  210,  210,  316,  317,  210,  449,
+  435,  454,  280,  242,  281,  281,  282,  283,  458,  281,
+  459,  460,  210,  210,  210,  461,  210,  210,  280,  468,
+  204,  281,  282,  434,  470,  204,  481,  281,  316,  317,
+  472,  281,  486,  281,  281,  556,  242,  242,  242,  494,
+  204,  495,  215,  204,  488,  281,  503,  204,  210,  204,
+  204,  484,  498,  510,  511,  207,  514,  204,  516,  316,
+  317,  204,  517,  522,  518,  521,  524,  527,  526,  307,
+  535,  536,  531,  128,  545,  318,  543,  209,  210,  210,
+  238,  548,  215,  215,  553,  559,  215,  209,  209,  209,
+  209,  209,  209,  207,  560,  207,  207,  561,  568,  207,
+  215,  215,  573,  482,  607,  215,  608,  318,  609,  610,
+  611,  612,  287,  207,  207,  207,  617,  207,  207,  618,
+  192,  193,  621,  195,  197,  209,  637,  643,  238,  207,
+  209,  646,  647,  238,  644,  648,  649,  208,  318,   95,
+  650,  651,  652,  665,  653,  209,  654,  661,  209,  207,
+  664,  238,  209,  672,  209,  209,  675,  238,  238,  676,
+  289,  678,  209,  679,  681,   33,  209,  215,  287,  238,
+  206,  682,  685,  689,  690,  208,  692,  208,  208,  207,
+  207,  208,  693,  290,  697,  699,  312,  302,  325,   43,
+   44,  187,    7,  327,  303,  208,  208,  208,   12,  208,
+  208,   45,  313,  171,   29,   30,  314,   16,  206,  211,
+  206,  206,  210,  315,  206,   34,  289,   36,  270,  446,
+  331,   33,  210,  210,  210,  210,  210,  210,  206,  206,
+  328,  208,  296,  206,   37,  332,  244,   23,   20,  290,
+   25,   26,   41,   27,   28,   43,   44,  211,   13,  211,
+  211,   24,  316,  211,  162,   22,   18,   45,  212,   19,
+  210,  208,  208,  248,  206,  210,  520,  211,  211,  538,
+  696,  137,  211,  138,  669,  640,  662,  674,  211,  180,
+  210,  299,  330,  210,  539,  619,  656,  210,  620,  210,
+  210,  213,  663,  497,  206,  206,  327,  210,  212,  212,
+  215,  210,  212,  211,  532,    0,    0,    0,    0,    0,
+  215,  215,    0,  207,  162,    0,  212,  212,    0,    0,
+  400,  212,  401,  207,  207,  207,  207,  207,  207,    0,
+    0,  213,  213,  211,  211,  213,    0,    0,   91,   92,
+   93,   94,   96,   97,   98,   99,    0,    0,  215,  213,
+  213,    0,  212,  215,  213,    0,    0,    0,    0,    0,
+  216,  207,    0,    0,    0,    0,  207,    0,  215,    0,
+    0,  215,    0,    0,    0,  215,    0,  215,  215,    0,
+    0,  207,  212,  212,  207,  215,    0,    0,  207,  215,
+  207,  207,    0,    0,    0,  208,    0,    0,  207,    0,
+  216,  216,  207,    0,  216,  208,  208,  208,  208,  208,
+  208,    0,    0,    0,    0,  213,  213,    0,  216,  216,
+    0,  258,  245,  216,    0,    0,  256,  254,  206,  255,
+    0,  257,    0,  581,    0,    0,    0,    0,  206,  206,
+  206,  206,    0,  208,  248,    0,  249,  162,  208,    0,
+  594,    0,    0,    0,  580,    0,    0,    0,    0,    0,
+    0,    0,    0,  208,    0,    0,  208,  211,    0,    0,
+  208,    0,  208,  208,    0,    0,  206,  211,  211,    0,
+  208,  206,  595,    0,  208,  216,    0,    0,  105,    0,
+  121,    0,    0,    0,    0,  162,  206,    0,    0,  206,
+  162,    0,    0,  206,    0,  206,  206,  121,    0,    0,
+    0,  121,    0,  206,    0,  211,  212,  206,  162,    0,
+  211,    0,    0,    0,  162,  162,  212,  212,    0,    0,
+    0,    0,    0,    0,    0,  211,  162,    0,  211,  121,
+    0,    0,  211,    0,  211,  211,    0,    0,    0,  213,
+    0,    0,  211,    0,    0,    0,  211,    0,    0,  213,
+  213,    0,    0,    0,  212,    0,    0,  153,    0,  212,
+    0,    0,    0,  121,  134,  479,    0,  132,    0,  133,
+    0,    0,    0,    0,  212,    0,    0,  212,    0,    0,
+    0,  212,    0,  212,  212,    0,    0,  213,    0,    0,
+    0,  212,  213,    0,    0,  212,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  213,  216,    0,
+  213,    0,    0,    0,  213,    0,  213,  213,  216,    0,
+    0,    0,    0,    0,  213,    0,    0,    0,  213,    0,
+    0,  153,    0,    0,    0,    0,    0,    0,  134,  579,
+    0,  132,  261,  133,  246,  247,  250,  251,  252,  253,
+  154,    0,    0,    0,    0,    0,  216,    0,    0,  260,
+    0,  216,  582,  583,  584,  585,  586,    0,    0,    0,
+    0,    0,  587,  588,    0,    0,  216,    0,    0,  216,
+    0,    0,    0,  216,    0,  216,  216,    0,    0,    0,
+    0,    0,    0,  216,    0,    0,  121,  216,    0,    0,
+    0,    0,    0,  153,    0,    0,  589,    0,  590,    0,
+  134,    0,  591,  132,  268,  133,   43,   44,    0,  121,
+  121,  121,  121,  121,  154,    0,    0,    0,    0,  121,
+  121,  267,    0,    0,    0,    0,  258,    0,    0,    0,
+    0,  256,  254,    0,  255,    0,  257,  592,    0,    0,
+    0,  593,    0,    0,    0,    0,    0,    0,    0,  248,
+    0,  249,    0,  121,    0,  121,    0,    0,  249,  121,
+    0,    0,    0,  121,  121,  249,    0,    0,  249,    0,
+  249,  130,  131,    0,  258,    0,    0,    0,    0,  256,
+  254,    0,  255,  249,  257,    0,  154,    0,    0,    0,
+    0,    0,  135,  136,  121,    0,    0,  248,  121,  249,
+    0,    0,  137,  138,  139,    0,    0,  140,    0,    0,
+    0,    0,  141,    0,    0,    0,  474,  475,  476,  477,
+  478,  142,    0,    0,    0,    0,  143,  144,  145,  146,
+  147,  148,  153,    0,    0,    0,    0,    0,  149,  438,
+  150,    0,  132,    0,  133,  130,  131,    0,    0,    0,
+    0,  249,    0,    0,    0,  151,    0,  191,    0,    0,
+  191,  152,    0,    0,    0,    0,  135,  136,    0,    0,
+    0,    0,    0,    0,    0,  191,  137,  138,  139,    0,
+    0,  140,    0,    0,    0,    0,  141,    0,    0,    0,
+    0,    0,    0,    0,    0,  142,    0,    0,    0,    0,
+  143,  144,  145,  146,  147,  148,    0,    0,    0,  153,
+    0,    0,  149,    0,  150,    0,  134,  130,  131,  132,
+    0,  133,    0,    0,    0,  154,    0,    0,    0,  151,
+    0,    0,    0,    0,  443,  152,    0,    0,  135,  136,
+    0,  191,    0,    0,    0,    0,    0,    0,  137,  138,
+  139,    0,    0,  140,    0,    0,    0,    0,  141,  246,
+  247,  250,  251,  252,  253,    0,    0,  142,    0,    0,
+    0,    0,  143,  144,  145,  146,  147,  148,    0,    0,
+  153,    0,  249,  249,  149,    0,  150,  134,    0,    0,
+  132,    0,  133,    0,    0,    0,    0,    0,    0,    0,
+    0,  151,  154,  249,  249,  249,    0,  152,    0,  250,
+  251,  252,  253,  249,  249,  249,    0,    0,  249,    0,
+    0,  628,  631,  249,    0,  636,    0,    0,    0,    0,
+    0,    0,  249,    0,    0,    0,    0,  249,  249,  249,
+  249,  249,  249,    0,    0,    0,    0,    0,  658,  249,
+  628,  249,    0,    0,    0,    0,  130,  131,    0,  667,
+  668,    0,  636,    0,  670,  671,  249,    0,   47,    0,
+  673,    0,  249,  154,  191,    0,    0,  135,  136,  439,
+    0,    0,  658,    0,    0,    0,    0,  137,  138,  139,
+    0,    0,  140,  691,    0,    0,    0,  141,    0,    0,
+    0,    0,    0,    0,    0,    0,  142,    0,    0,    0,
+    0,  143,  144,  145,  146,  147,  148,    0,    0,    0,
+    0,    0,  191,  149,   47,  150,    0,  191,    0,    0,
+    0,    0,    0,  130,  131,    0,    0,    0,    0,    0,
+  151,    0,  191,    0,    0,  191,  152,    0,    0,    0,
+    0,  191,  191,    0,  135,  136,    0,    0,    0,    0,
+    0,    0,    0,  191,  137,  138,  139,    0,    0,  140,
+    0,  258,  245,    0,  141,  415,  256,  254,  414,  255,
+    0,  257,    0,  142,    0,    0,    0,    0,  143,  144,
+  145,  146,  147,  148,  248,    0,  249,  240,    0,    0,
+  149,    0,  150,    0,  130,  131,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  151,    0,    0,
+    0,    0,    0,  152,    0,  135,  136,    0,  244,    0,
+    0,    0,    0,    0,    0,  137,  138,  139,    0,    0,
+  140,    0,    0,    0,    0,  141,    0,    0,    0,    0,
+    0,    0,    0,    0,  142,    0,    0,    0,  243,  143,
+  144,  145,  146,  147,  148,    0,    0,   21,    0,    0,
+    0,  149,    0,  150,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  394,    0,  151,    0,
+    0,    0,    0,    0,  152,   22,   23,    0,    0,    0,
+    0,    0,    0,   24,   25,   26,   27,    0,   28,   29,
+    0,    0,    0,    0,    0,    0,    0,   30,   31,   32,
+   33,    0,    0,   21,    0,    0,    0,   34,   35,   36,
+   37,   38,   39,    0,    0,    0,    0,   40,   41,   42,
+    0,    0,    0,    0,   43,   44,    0,    0,    0,    0,
+    0,   22,   23,    0,    0,    0,   45,    0,    0,   24,
+   25,   26,   27,    0,   28,   29,    0,   46,    0,    0,
+    0,    0,    0,   30,   31,   32,   33,    0,    0,    0,
+    0,    0,    0,   34,   35,   36,   37,   38,   39,    0,
+    0,    0,    0,   40,   41,   42,    0,    0,    0,    0,
+   43,   44,  241,  242,  246,  247,  250,  251,  252,  253,
+  258,  245,   45,    0,    0,  256,  254,  259,  255,    0,
+  257,  258,  245,   46,    0,  333,  256,  254,    0,  255,
+    0,  257,    0,  248,    0,  249,  240,    0,    0,    0,
+    0,    0,    0,    0,  248,    0,  249,  240,  258,  245,
+    0,    0,    0,  256,  254,  411,  255,    0,  257,    0,
+  258,  245,    0,    0,  416,  256,  254,  244,  255,    0,
+  257,  248,    0,  249,  240,    0,    0,    0,  244,    0,
+    0,    0,    0,  248,    0,  249,  240,    0,  258,  245,
+    0,    0,    0,  256,  254,  417,  255,  243,  257,    0,
+    0,    0,    0,    0,    0,  244,    0,    0,  243,    0,
+    0,  248,    0,  249,  240,  258,  245,  244,    0,    0,
+  256,  254,  418,  255,    0,  257,  258,  245,    0,    0,
+  419,  256,  254,    0,  255,  243,  257,    0,  248,    0,
+  249,  240,    0,    0,    0,  244,    0,  243,    0,  248,
+    0,  249,  240,  258,  245,    0,    0,  422,  256,  254,
+    0,  255,    0,  257,    0,    0,    0,    0,    0,    0,
+    0,    0,  244,    0,    0,  243,  248,    0,  249,  240,
+  258,  245,    0,  244,    0,  256,  254,  426,  255,    0,
+  257,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  243,  248,    0,  249,  240,    0,    0,    0,
+  244,    0,    0,  243,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  244,    0,    0,
+  243,  241,  242,  246,  247,  250,  251,  252,  253,    0,
+    0,    0,  241,  242,  246,  247,  250,  251,  252,  253,
+    0,    0,    0,    0,    0,    0,    0,  243,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  241,
+  242,  246,  247,  250,  251,  252,  253,    0,    0,    0,
+    0,  241,  242,  246,  247,  250,  251,  252,  253,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  258,  245,
+    0,    0,    0,  256,  254,  427,  255,    0,  257,  241,
+  242,  246,  247,  250,  251,  252,  253,    0,    0,    0,
+    0,  248,    0,  249,  240,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  241,  242,  246,  247,
+  250,  251,  252,  253,    0,    0,    0,  241,  242,  246,
+  247,  250,  251,  252,  253,  244,    0,    0,    0,    0,
+    0,  258,  245,    0,    0,  430,  256,  254,    0,  255,
+    0,  257,    0,    0,  241,  242,  246,  247,  250,  251,
+  252,  253,    0,    0,  248,  243,  249,  240,  258,  245,
+    0,    0,    0,  256,  254,  431,  255,    0,  257,    0,
+    0,  241,  242,  246,  247,  250,  251,  252,  253,    0,
+    0,  248,    0,  249,  240,  258,  245,    0,  244,    0,
+  256,  254,    0,  255,    0,  257,    0,  258,  245,    0,
+  482,    0,  256,  254,    0,  255,  432,  257,  248,    0,
+  249,  240,    0,    0,    0,  244,    0,    0,  243,    0,
+  248,    0,  249,  240,    0,  258,  245,    0,    0,    0,
+  256,  254,    0,  255,    0,  257,    0,    0,    0,    0,
+    0,    0,  244,    0,    0,  243,  487,    0,  248,    0,
+  249,  240,  258,  245,  244,    0,  504,  256,  254,    0,
+  255,    0,  257,  258,  245,    0,    0,  505,  256,  254,
+    0,  255,  243,  257,    0,  248,    0,  249,  240,    0,
+    0,    0,  244,    0,  243,    0,  248,    0,  249,  240,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  241,
+  242,  246,  247,  250,  251,  252,  253,    0,    0,  244,
+    0,    0,  243,    0,    0,    0,    0,  258,  245,    0,
+  244,  506,  256,  254,    0,  255,    0,  257,  258,  245,
+    0,    0,  507,  256,  254,    0,  255,    0,  257,  243,
+  248,    0,  249,  240,    0,    0,    0,    0,    0,    0,
+  243,  248,    0,  249,  240,    0,    0,    0,    0,    0,
+    0,    0,  241,  242,  246,  247,  250,  251,  252,  253,
+    0,    0,    0,    0,  244,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  244,    0,    0,    0,  241,
+  242,  246,  247,  250,  251,  252,  253,    0,    0,    0,
+    0,    0,    0,    0,  243,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  243,  241,  242,  246,  247,
+  250,  251,  252,  253,    0,    0,    0,    0,  241,  242,
+  246,  247,  250,  251,  252,  253,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  258,  245,    0,    0,  508,
+  256,  254,    0,  255,    0,  257,  241,  242,  246,  247,
+  250,  251,  252,  253,    0,    0,    0,    0,  248,    0,
+  249,  240,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  241,  242,  246,  247,  250,  251,  252,
+  253,    0,    0,    0,  241,  242,  246,  247,  250,  251,
+  252,  253,  244,    0,    0,    0,    0,    0,    0,    0,
+  258,  245,    0,    0,  509,  256,  254,    0,  255,    0,
+  257,  258,  245,    0,    0,  533,  256,  254,    0,  255,
+    0,  257,  243,  248,    0,  249,  240,    0,    0,    0,
+    0,    0,    0,    0,  248,    0,  249,  240,  241,  242,
+  246,  247,  250,  251,  252,  253,    0,    0,    0,  241,
+  242,  246,  247,  250,  251,  252,  253,  244,    0,  258,
+  245,    0,    0,  551,  256,  254,    0,  255,  244,  257,
+  258,  245,    0,    0,  557,  256,  254,    0,  255,    0,
+  257,    0,  248,    0,  249,  240,    0,  243,    0,    0,
+    0,    0,    0,  248,    0,  249,  240,    0,  243,  258,
+  245,    0,    0,  558,  256,  254,    0,  255,    0,  257,
+    0,    0,    0,    0,    0,    0,  244,    0,    0,    0,
+    0,    0,  248,    0,  249,  240,    0,  244,  258,  245,
+    0,    0,  562,  256,  254,    0,  255,    0,  257,  258,
+  245,    0,    0,  572,  256,  254,  243,  255,    0,  257,
+    0,  248,    0,  249,  240,    0,  244,  243,    0,    0,
+    0,    0,  248,    0,  249,  240,  241,  242,  246,  247,
+  250,  251,  252,  253,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  258,  245,  244,  243,  575,  256,  254,
+    0,  255,    0,  257,  258,  245,  244,    0,    0,  256,
+  254,    0,  255,    0,  257,    0,  248,    0,  249,  240,
+    0,    0,    0,    0,    0,  243,    0,  248,    0,  249,
+  240,    0,    0,    0,    0,    0,  243,    0,    0,    0,
+    0,  241,  242,  246,  247,  250,  251,  252,  253,    0,
+  244,    0,  241,  242,  246,  247,  250,  251,  252,  253,
+    0,  244,  258,  245,    0,    0,    0,  256,  254,    0,
+  255,    0,  257,  258,  245,    0,    0,    0,  256,  254,
+  243,  255,    0,  257,    0,  248,    0,  249,    0,    0,
+    0,  243,    0,    0,    0,    0,  248,    0,  249,    0,
+  241,  242,  246,  247,  250,  251,  252,  253,    0,    0,
+    0,  241,  242,  246,  247,  250,  251,  252,  253,  244,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  244,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  241,  242,  246,  247,  250,  251,  252,  253,    0,  243,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  243,    0,    0,    0,    0,    0,    0,    0,    0,  241,
+  242,  246,  247,  250,  251,  252,  253,    0,    0,    0,
+  241,  242,  246,  247,  250,  251,  252,  253,  258,  245,
+    0,    0,    0,  256,  254,    0,  255,    0,  257,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  248,    0,  249,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  241,  242,  246,  247,  250,  251,
+  252,  253,    0,    0,    0,  241,  242,  246,  247,  250,
+  251,  252,  253,   60,    0,  244,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  413,   61,    0,    0,    0,    0,    0,    0,
+    0,   60,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   62,    0,    0,    0,    0,    0,
+    0,   61,    0,    0,  242,  246,  247,  250,  251,  252,
+  253,    0,    0,    0,    0,    0,  246,  247,  250,  251,
+  252,  253,   62,    0,    0,    0,    0,   63,    0,    0,
+    0,    0,    0,   64,   65,   66,   67,   68,    0,   69,
+   70,   71,    0,   72,   73,   74,   75,   76,    0,    0,
+    0,    0,   77,   78,   79,   63,    0,    0,    0,    0,
+    0,   64,   65,   66,   67,   68,    0,   69,   70,   71,
+    0,   72,   73,   74,   75,   76,    0,    0,    0,    0,
+   77,   78,   79,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  246,  247,  250,  251,  252,  253,
 };
-
-static const short int yycheck[] =
-{
-      92,   199,   200,    65,    20,   185,    63,   177,   178,   101,
-       4,   207,     4,    75,     4,     6,     4,     5,     4,   441,
-      82,     4,     4,     4,   577,   302,   201,     4,     4,     5,
-       4,     5,    53,     3,     4,     4,     4,   596,    15,     4,
-     524,    53,    54,   133,    53,   135,    15,     6,     6,   602,
-       4,     0,     4,   110,   111,    32,   113,   114,    16,   618,
-      30,    31,   119,    32,    54,     6,     4,    37,    38,    39,
-      40,   133,   134,     4,   122,   559,   122,    15,    48,    49,
-      50,   640,     4,     5,   684,    55,   134,     4,   134,    53,
-      60,   644,   154,   155,    32,   157,   696,    53,    15,    69,
-      54,     4,    54,   165,    74,    75,    76,    77,    78,    79,
-     122,    99,   534,   122,    95,    32,    86,   675,    88,     4,
-       5,   183,   399,    99,    37,    99,    39,   685,   133,    37,
-       4,     5,   137,   103,    51,    52,     4,     5,   313,   109,
-      37,   135,   133,   133,   138,   133,   138,   135,     4,   211,
-     133,   133,   214,   215,   576,   217,   218,   133,   135,   135,
-     222,   223,   224,   225,   226,   133,   135,   229,   138,   139,
-     135,   233,   234,    53,   133,   237,   238,    99,    37,   241,
+#if defined(__cplusplus) || defined(__STDC__)
+const short yycheck[] =
+#else
+short yycheck[] =
+#endif
+	{                                      95,
+  198,  199,   64,    0,  100,  184,    0,   44,   42,   40,
+   42,    0,   74,   41,   33,   19,   59,   41,  123,   81,
+   44,   59,   41,   59,   59,  123,   44,  125,   44,   63,
+   44,   63,   44,  200,  440,   42,  258,  258,   33,   59,
+    0,  206,   59,  125,   38,  301,   40,   41,  523,   43,
+   44,   45,   44,   41,   42,   58,   63,   91,   61,   44,
+   41,   44,  258,   44,   58,   59,   60,  125,   62,   63,
+  132,  133,   42,  595,   41,   63,   59,   44,   38,  125,
+   40,   41,  123,  558,   44,    0,  576,   41,   42,   42,
+   61,  153,  154,   63,  156,  617,  176,  177,   58,   59,
+   94,   93,  164,   63,   44,  125,  683,  125,  125,   63,
+   63,  125,  333,  603,   37,   44,   40,  639,  695,   42,
+  182,   61,  258,  259,   47,   40,   41,  533,  674,   44,
+  124,  125,   61,  123,   94,   40,  358,  123,  684,  361,
+  362,  363,  398,   58,   59,  312,   41,   41,  210,   44,
+   44,  213,  214,  643,  216,  217,  258,  258,  259,  221,
+  222,  223,  224,  225,  124,  125,  228,  257,  258,  575,
+  232,  233,   41,  123,  236,  237,  258,  123,  240,  241,
      242,   243,   244,   245,   246,   247,   248,   249,   250,   251,
      252,   253,   254,   255,   256,   257,   258,   259,   260,   261,
-     262,    37,   133,     4,   135,    37,   268,   269,   404,   133,
-     134,     3,     4,   383,    99,   132,    37,   120,    37,   136,
-     123,   124,   125,     4,    37,    99,   116,   117,   118,     3,
-       4,    99,   324,   325,    15,    37,     4,   127,    30,    31,
-      30,    31,    32,    33,    34,    37,    38,    39,   133,    37,
-     135,    32,   133,   310,   135,   312,    48,    49,    50,   133,
-      37,   135,   458,    55,   133,   133,   135,   135,    60,     4,
-      51,    52,    64,    65,    66,    67,    68,    69,     4,    32,
-      33,    34,    74,    75,    76,    77,    78,    79,   129,   130,
-     131,   133,    37,   135,    86,    37,    88,     4,    37,    37,
-     126,     4,   500,   473,   474,     4,     4,   503,    15,     4,
-       4,   103,   328,     4,     4,     4,     3,   109,     4,   120,
-       4,     4,   123,   124,   125,    32,   105,     4,   390,   391,
-     392,   393,     4,    54,     3,     4,    16,     6,    15,   134,
-      16,     4,     4,   135,    51,    52,   138,   139,     4,     4,
-       4,   132,     4,   415,     4,    32,   418,   419,    37,   421,
-     540,    30,    31,     4,    37,   427,   428,     4,    37,    38,
-      39,   433,    53,     4,    51,    52,    37,    37,    15,    48,
-      49,    50,   133,   133,    37,   120,    55,   133,   123,   124,
-     125,    60,    37,     4,   120,    32,   133,   123,   124,   125,
-      69,    37,    37,    37,    37,    74,    75,    76,    77,    78,
-      79,    37,    37,    37,    51,    52,    93,    86,    37,    88,
-     482,    37,    37,    54,    37,   132,    64,    65,    66,    67,
-      68,    37,    37,    53,   103,   135,   528,    68,   134,    37,
-     109,     6,    73,    54,    54,     6,     4,   135,     3,     4,
-     135,     6,     4,   135,     4,   132,   518,    68,     4,     4,
-      91,   523,    73,   525,   133,   135,    97,    98,   560,   138,
-     139,   135,     4,     4,   536,    30,    31,   135,   109,     4,
-      91,     4,    37,    38,    39,     4,    97,    98,   135,     4,
-       4,   134,   554,    48,    49,    50,     4,   135,   109,   561,
-      55,   699,   134,   701,     4,    60,   133,   705,    37,    37,
-      53,    16,   135,   135,    69,     3,     4,   135,   135,    74,
-      75,    76,    77,    78,    79,    37,   135,   135,    16,   621,
-     133,    86,     4,    88,   135,   135,   609,   610,     4,   134,
-     613,    16,    30,    31,    37,    16,    95,    85,   103,    37,
-      38,    39,     4,     4,   109,   135,    86,   135,    54,   135,
-      48,    49,    50,    16,   637,   638,    53,    55,    37,   135,
-      38,     6,    60,    37,   647,   648,    37,   650,   133,   652,
-     653,    69,   133,   138,   139,   658,    74,    75,    76,    77,
-      78,    79,     3,     4,   134,    37,    88,   670,    86,    96,
-      88,    28,    29,    30,    31,    32,    33,    34,   681,    54,
-     134,    37,     6,    37,    16,   103,    53,    53,    37,    30,
-      31,   109,    37,    16,    37,    37,    37,    38,    39,    37,
-      37,    37,     4,    54,    37,    53,    37,    48,    49,    50,
-      25,    37,    37,    15,    55,   135,    37,    37,    37,    60,
-     138,   139,   135,   135,   135,   135,     4,    95,    69,   135,
-      32,   135,    54,    74,    75,    76,    77,    78,    79,    41,
-      42,    43,    44,    45,    25,    86,   135,    88,   135,    51,
-      52,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-       4,   135,   103,     4,   135,   135,   135,   522,   109,   216,
-       4,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    37,   135,   123,    87,   189,    89,   135,   135,
-     650,    93,   618,   635,   602,    97,    98,   138,   139,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    46,    47,   644,   687,   662,   605,   453,   490,
-     521,   642,    56,    57,    58,    59,   128,    61,    62,   213,
-     132,    90,   134,   392,   136,   514,    70,    71,    72,    73,
-      -1,     4,    -1,    -1,    -1,    -1,    80,    81,    82,    83,
-      84,    85,    -1,    -1,    -1,    -1,    90,    91,    92,    -1,
-      -1,    -1,    -1,    97,    98,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    36,    -1,   109,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    46,    47,    -1,   120,    -1,    -1,    -1,
-      -1,    -1,   126,    56,    57,    58,    59,    -1,    61,    62,
-     134,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,    72,
-      73,    -1,    -1,    -1,    -1,    -1,    -1,    80,    81,    82,
-      83,    84,    85,    -1,    -1,    -1,    -1,    90,    91,    92,
-      -1,    -1,    -1,    -1,    97,    98,     6,     7,     8,     9,
-      10,    11,    12,    13,    14,    -1,   109,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,   120,    -1,    -1,
+  258,  337,  123,  123,   41,  267,  268,   44,   42,    0,
+  125,  123,  258,   37,   40,  258,  364,   40,   42,   43,
+  258,   45,   41,   47,  258,   44,  258,  323,  324,   63,
+  258,   40,   41,   40,  258,  259,  337,   40,  403,  258,
+  258,   40,  258,  258,  258,   42,  258,   38,  279,   40,
+   41,  258,   43,   44,   45,  360,    0,  291,  292,  291,
+  292,   40,  360,  258,  258,   40,   63,   58,   59,   60,
+  258,   62,   63,  258,  268,  269,  270,  271,  272,  273,
+  274,  275,   40,  258,  291,  292,   40,   44,  258,   40,
+  333,  258,  457,  334,   38,  333,   40,   41,  258,  331,
+   44,  499,  382,   94,  258,  258,  343,   40,  268,  269,
+  270,  271,  306,  337,   58,   59,   60,  311,   62,   63,
+   40,  291,  292,  327,  360,  360,   40,  389,  390,  391,
+  392,  258,  326,  124,  125,  329,  370,  502,  370,  333,
+  258,  335,  336,  258,    0,  258,  306,  333,  334,  343,
+   94,  311,  414,  347,  343,  417,  418,  278,  420,  258,
+  539,  258,  258,  370,  426,  427,  326,  364,  125,  329,
+  432,  258,   44,  333,  257,  335,  336,  367,  368,  369,
+  124,  125,   38,  343,   40,   41,   58,  347,   44,   61,
+  258,  306,  472,  473,  258,  258,  311,  354,  355,  356,
+  370,  343,   58,   59,   60,  258,   62,   63,  365,   41,
+   58,  326,   44,  334,  329,  367,  368,  369,  333,  481,
+  335,  336,  123,   58,  258,   59,  125,  258,  343,  258,
+  258,  527,  347,  302,  303,  304,  305,  306,   94,  258,
+  259,   41,  258,  258,   44,  258,  367,  368,  369,    0,
+  274,  275,   40,  125,  258,  517,  258,  291,  292,   40,
+  522,  258,  524,  559,  123,  258,   40,  258,  124,  125,
+   40,   44,   41,  535,   40,   44,   40,  268,  269,  270,
+  271,  272,  273,  274,  275,   40,   40,   38,   40,   40,
+   41,  553,  123,   44,  291,  292,   44,   40,  560,   40,
+  698,  258,  700,   40,   40,   40,  704,   58,   59,   60,
+   58,   62,   63,   61,  258,  306,   40,   40,  337,   40,
+  311,   40,  618,   40,  268,  269,  270,  271,  272,  273,
+  274,  275,  258,   44,   44,  326,  370,   44,  329,   59,
+  125,   41,  333,   94,  335,  336,   41,   41,  258,  306,
+   41,   41,  343,   37,  311,   41,  347,   40,   42,   43,
+   41,   45,  306,   47,   41,  358,  258,  311,  361,  362,
+  363,  258,  329,  124,  125,  258,   61,  125,  335,  336,
+  258,   61,  326,  258,    0,  329,  258,  258,  258,  333,
+  347,  335,  336,  258,  258,  258,  258,  258,   59,  343,
+   59,  258,  258,  347,  258,   40,   40,   44,   41,  125,
+   41,   41,  268,  269,  270,  271,  272,  273,  274,  275,
+   41,   41,   38,   41,   40,   41,  258,  259,   44,   44,
+  123,   58,  358,  334,  306,  361,  362,  363,   40,  311,
+   41,   41,   58,   59,   60,  258,   62,   63,  358,  258,
+  306,  361,  362,  363,   59,  311,   40,  329,  258,  259,
+   58,  333,   58,  335,  336,  125,  367,  368,  369,  258,
+  326,  258,    0,  329,  323,  347,   41,  333,   94,  335,
+  336,  333,  324,   41,  125,    0,   41,  343,   58,  258,
+  259,  347,   40,   40,  278,  123,   40,   61,   41,   44,
+   40,  334,   59,   62,  326,  337,   59,  258,  124,  125,
+  258,  125,   40,   41,   40,   61,   44,  268,  269,  270,
+  271,  272,  273,   38,   40,   40,   41,   58,  123,   44,
+   58,   59,  123,   40,   58,   63,   40,  337,   40,   40,
+   40,   40,  258,   58,   59,   60,   40,   62,   63,   40,
+  109,  110,  125,  112,  113,  306,   40,  123,  306,  118,
+  311,   40,   40,  311,   62,   41,   40,    0,  337,   61,
+   41,   40,   40,  333,   41,  326,   41,   41,  329,   94,
+  258,  329,  333,   41,  335,  336,  125,  335,  336,   62,
+  306,   41,  343,   41,   41,  311,  347,  125,  258,  347,
+    0,   41,  258,   41,   41,   38,   41,   40,   41,  124,
+  125,   44,   41,  329,  258,   41,  125,    0,   59,  335,
+  336,   41,    0,   59,  364,   58,   59,   60,  343,   62,
+   63,  347,  125,   58,  343,  343,  125,  343,   38,    0,
+   40,   41,  258,  125,   44,  343,  306,  343,   58,  391,
+  125,  311,  268,  269,  270,  271,  272,  273,   58,   59,
+   59,   94,   59,   63,  343,  125,  123,  343,  343,  329,
+  343,  343,  343,  343,  343,  335,  336,   38,  343,   40,
+   41,  343,  125,   44,  326,  343,  343,  347,    0,  343,
+  306,  124,  125,  123,   94,  311,  489,   58,   59,  520,
+  686,  125,   63,  125,  649,  617,  642,  662,  122,   89,
+  326,  188,  215,  329,  521,  599,  634,  333,  603,  335,
+  336,    0,  643,  452,  124,  125,  212,  343,   40,   41,
+  258,  347,   44,   94,  513,   -1,   -1,   -1,   -1,   -1,
+  268,  269,   -1,  258,  125,   -1,   58,   59,   -1,   -1,
+  309,   63,  311,  268,  269,  270,  271,  272,  273,   -1,
+   -1,   40,   41,  124,  125,   44,   -1,   -1,  260,  261,
+  262,  263,  264,  265,  266,  267,   -1,   -1,  306,   58,
+   59,   -1,   94,  311,   63,   -1,   -1,   -1,   -1,   -1,
+    0,  306,   -1,   -1,   -1,   -1,  311,   -1,  326,   -1,
+   -1,  329,   -1,   -1,   -1,  333,   -1,  335,  336,   -1,
+   -1,  326,  124,  125,  329,  343,   -1,   -1,  333,  347,
+  335,  336,   -1,   -1,   -1,  258,   -1,   -1,  343,   -1,
+   40,   41,  347,   -1,   44,  268,  269,  270,  271,  272,
+  273,   -1,   -1,   -1,   -1,  124,  125,   -1,   58,   59,
+   -1,   37,   38,   63,   -1,   -1,   42,   43,  258,   45,
+   -1,   47,   -1,   42,   -1,   -1,   -1,   -1,  268,  269,
+  270,  271,   -1,  306,   60,   -1,   62,  258,  311,   -1,
+   59,   -1,   -1,   -1,   63,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  326,   -1,   -1,  329,  258,   -1,   -1,
+  333,   -1,  335,  336,   -1,   -1,  306,  268,  269,   -1,
+  343,  311,   91,   -1,  347,  125,   -1,   -1,   40,   -1,
+   42,   -1,   -1,   -1,   -1,  306,  326,   -1,   -1,  329,
+  311,   -1,   -1,  333,   -1,  335,  336,   59,   -1,   -1,
+   -1,   63,   -1,  343,   -1,  306,  258,  347,  329,   -1,
+  311,   -1,   -1,   -1,  335,  336,  268,  269,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  326,  347,   -1,  329,   91,
+   -1,   -1,  333,   -1,  335,  336,   -1,   -1,   -1,  258,
+   -1,   -1,  343,   -1,   -1,   -1,  347,   -1,   -1,  268,
+  269,   -1,   -1,   -1,  306,   -1,   -1,   33,   -1,  311,
+   -1,   -1,   -1,  125,   40,   41,   -1,   43,   -1,   45,
+   -1,   -1,   -1,   -1,  326,   -1,   -1,  329,   -1,   -1,
+   -1,  333,   -1,  335,  336,   -1,   -1,  306,   -1,   -1,
+   -1,  343,  311,   -1,   -1,  347,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  326,  258,   -1,
+  329,   -1,   -1,   -1,  333,   -1,  335,  336,  268,   -1,
+   -1,   -1,   -1,   -1,  343,   -1,   -1,   -1,  347,   -1,
+   -1,   33,   -1,   -1,   -1,   -1,   -1,   -1,   40,  258,
+   -1,   43,   44,   45,  270,  271,  272,  273,  274,  275,
+  126,   -1,   -1,   -1,   -1,   -1,  306,   -1,   -1,   61,
+   -1,  311,  281,  282,  283,  284,  285,   -1,   -1,   -1,
+   -1,   -1,  291,  292,   -1,   -1,  326,   -1,   -1,  329,
+   -1,   -1,   -1,  333,   -1,  335,  336,   -1,   -1,   -1,
+   -1,   -1,   -1,  343,   -1,   -1,  258,  347,   -1,   -1,
+   -1,   -1,   -1,   33,   -1,   -1,  325,   -1,  327,   -1,
+   40,   -1,  331,   43,   44,   45,  335,  336,   -1,  281,
+  282,  283,  284,  285,  126,   -1,   -1,   -1,   -1,  291,
+  292,   61,   -1,   -1,   -1,   -1,   37,   -1,   -1,   -1,
+   -1,   42,   43,   -1,   45,   -1,   47,  366,   -1,   -1,
+   -1,  370,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,
+   -1,   62,   -1,  325,   -1,  327,   -1,   -1,   33,  331,
+   -1,   -1,   -1,  335,  336,   40,   -1,   -1,   43,   -1,
+   45,  257,  258,   -1,   37,   -1,   -1,   -1,   -1,   42,
+   43,   -1,   45,   58,   47,   -1,  126,   -1,   -1,   -1,
+   -1,   -1,  278,  279,  366,   -1,   -1,   60,  370,   62,
+   -1,   -1,  288,  289,  290,   -1,   -1,  293,   -1,   -1,
+   -1,   -1,  298,   -1,   -1,   -1,  302,  303,  304,  305,
+  306,  307,   -1,   -1,   -1,   -1,  312,  313,  314,  315,
+  316,  317,   33,   -1,   -1,   -1,   -1,   -1,  324,   40,
+  326,   -1,   43,   -1,   45,  257,  258,   -1,   -1,   -1,
+   -1,  126,   -1,   -1,   -1,  341,   -1,   41,   -1,   -1,
+   44,  347,   -1,   -1,   -1,   -1,  278,  279,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   59,  288,  289,  290,   -1,
+   -1,  293,   -1,   -1,   -1,   -1,  298,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  307,   -1,   -1,   -1,   -1,
+  312,  313,  314,  315,  316,  317,   -1,   -1,   -1,   33,
+   -1,   -1,  324,   -1,  326,   -1,   40,  257,  258,   43,
+   -1,   45,   -1,   -1,   -1,  126,   -1,   -1,   -1,  341,
+   -1,   -1,   -1,   -1,   58,  347,   -1,   -1,  278,  279,
+   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,
+  290,   -1,   -1,  293,   -1,   -1,   -1,   -1,  298,  270,
+  271,  272,  273,  274,  275,   -1,   -1,  307,   -1,   -1,
+   -1,   -1,  312,  313,  314,  315,  316,  317,   -1,   -1,
+   33,   -1,  257,  258,  324,   -1,  326,   40,   -1,   -1,
+   43,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  341,  126,  278,  279,  280,   -1,  347,   -1,  272,
+  273,  274,  275,  288,  289,  290,   -1,   -1,  293,   -1,
+   -1,  608,  609,  298,   -1,  612,   -1,   -1,   -1,   -1,
+   -1,   -1,  307,   -1,   -1,   -1,   -1,  312,  313,  314,
+  315,  316,  317,   -1,   -1,   -1,   -1,   -1,  635,  324,
+  637,  326,   -1,   -1,   -1,   -1,  257,  258,   -1,  646,
+  647,   -1,  649,   -1,  651,  652,  341,   -1,   59,   -1,
+  657,   -1,  347,  126,  258,   -1,   -1,  278,  279,  280,
+   -1,   -1,  669,   -1,   -1,   -1,   -1,  288,  289,  290,
+   -1,   -1,  293,  680,   -1,   -1,   -1,  298,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  307,   -1,   -1,   -1,
+   -1,  312,  313,  314,  315,  316,  317,   -1,   -1,   -1,
+   -1,   -1,  306,  324,   59,  326,   -1,  311,   -1,   -1,
+   -1,   -1,   -1,  257,  258,   -1,   -1,   -1,   -1,   -1,
+  341,   -1,  326,   -1,   -1,  329,  347,   -1,   -1,   -1,
+   -1,  335,  336,   -1,  278,  279,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  347,  288,  289,  290,   -1,   -1,  293,
+   -1,   37,   38,   -1,  298,   41,   42,   43,   44,   45,
+   -1,   47,   -1,  307,   -1,   -1,   -1,   -1,  312,  313,
+  314,  315,  316,  317,   60,   -1,   62,   63,   -1,   -1,
+  324,   -1,  326,   -1,  257,  258,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  341,   -1,   -1,
+   -1,   -1,   -1,  347,   -1,  278,  279,   -1,   94,   -1,
+   -1,   -1,   -1,   -1,   -1,  288,  289,  290,   -1,   -1,
+  293,   -1,   -1,   -1,   -1,  298,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  307,   -1,   -1,   -1,  124,  312,
+  313,  314,  315,  316,  317,   -1,   -1,  258,   -1,   -1,
+   -1,  324,   -1,  326,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  277,   -1,  341,   -1,
+   -1,   -1,   -1,   -1,  347,  286,  287,   -1,   -1,   -1,
+   -1,   -1,   -1,  294,  295,  296,  297,   -1,  299,  300,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  308,  309,  310,
+  311,   -1,   -1,  258,   -1,   -1,   -1,  318,  319,  320,
+  321,  322,  323,   -1,   -1,   -1,   -1,  328,  329,  330,
+   -1,   -1,   -1,   -1,  335,  336,   -1,   -1,   -1,   -1,
+   -1,  286,  287,   -1,   -1,   -1,  347,   -1,   -1,  294,
+  295,  296,  297,   -1,  299,  300,   -1,  358,   -1,   -1,
+   -1,   -1,   -1,  308,  309,  310,  311,   -1,   -1,   -1,
+   -1,   -1,   -1,  318,  319,  320,  321,  322,  323,   -1,
+   -1,   -1,   -1,  328,  329,  330,   -1,   -1,   -1,   -1,
+  335,  336,  268,  269,  270,  271,  272,  273,  274,  275,
+   37,   38,  347,   -1,   -1,   42,   43,   44,   45,   -1,
+   47,   37,   38,  358,   -1,   41,   42,   43,   -1,   45,
+   -1,   47,   -1,   60,   -1,   62,   63,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   60,   -1,   62,   63,   37,   38,
+   -1,   -1,   -1,   42,   43,   44,   45,   -1,   47,   -1,
+   37,   38,   -1,   -1,   41,   42,   43,   94,   45,   -1,
+   47,   60,   -1,   62,   63,   -1,   -1,   -1,   94,   -1,
+   -1,   -1,   -1,   60,   -1,   62,   63,   -1,   37,   38,
+   -1,   -1,   -1,   42,   43,   44,   45,  124,   47,   -1,
+   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,  124,   -1,
+   -1,   60,   -1,   62,   63,   37,   38,   94,   -1,   -1,
+   42,   43,   44,   45,   -1,   47,   37,   38,   -1,   -1,
+   41,   42,   43,   -1,   45,  124,   47,   -1,   60,   -1,
+   62,   63,   -1,   -1,   -1,   94,   -1,  124,   -1,   60,
+   -1,   62,   63,   37,   38,   -1,   -1,   41,   42,   43,
+   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   94,   -1,   -1,  124,   60,   -1,   62,   63,
+   37,   38,   -1,   94,   -1,   42,   43,   44,   45,   -1,
+   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  124,   60,   -1,   62,   63,   -1,   -1,   -1,
+   94,   -1,   -1,  124,   -1,   -1,   -1,   -1,   -1,   -1,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      15,   134,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    -1,   133,    15,
-     135,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
-     135,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
-     135,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
-     135,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
-     135,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    15,
-      -1,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,   135,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    -1,    -1,    15,   135,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   135,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   135,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   135,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,   135,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,    15,    -1,
-      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-      27,    28,    29,    30,    31,    32,    33,    34,   135,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    -1,    -1,    -1,    15,   135,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,   135,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,   135,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,   135,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,   135,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,    -1,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,   135,    21,    22,
-      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    -1,    -1,    -1,    -1,    -1,   135,    -1,    -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,
+  124,  268,  269,  270,  271,  272,  273,  274,  275,   -1,
+   -1,   -1,  268,  269,  270,  271,  272,  273,  274,  275,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  124,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  268,
+  269,  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,
+   -1,  268,  269,  270,  271,  272,  273,  274,  275,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   37,   38,
+   -1,   -1,   -1,   42,   43,   44,   45,   -1,   47,  268,
+  269,  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,
+   -1,   60,   -1,   62,   63,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  268,  269,  270,  271,
+  272,  273,  274,  275,   -1,   -1,   -1,  268,  269,  270,
+  271,  272,  273,  274,  275,   94,   -1,   -1,   -1,   -1,
+   -1,   37,   38,   -1,   -1,   41,   42,   43,   -1,   45,
+   -1,   47,   -1,   -1,  268,  269,  270,  271,  272,  273,
+  274,  275,   -1,   -1,   60,  124,   62,   63,   37,   38,
+   -1,   -1,   -1,   42,   43,   44,   45,   -1,   47,   -1,
+   -1,  268,  269,  270,  271,  272,  273,  274,  275,   -1,
+   -1,   60,   -1,   62,   63,   37,   38,   -1,   94,   -1,
+   42,   43,   -1,   45,   -1,   47,   -1,   37,   38,   -1,
+   40,   -1,   42,   43,   -1,   45,   58,   47,   60,   -1,
+   62,   63,   -1,   -1,   -1,   94,   -1,   -1,  124,   -1,
+   60,   -1,   62,   63,   -1,   37,   38,   -1,   -1,   -1,
+   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,
+   -1,   -1,   94,   -1,   -1,  124,   58,   -1,   60,   -1,
+   62,   63,   37,   38,   94,   -1,   41,   42,   43,   -1,
+   45,   -1,   47,   37,   38,   -1,   -1,   41,   42,   43,
+   -1,   45,  124,   47,   -1,   60,   -1,   62,   63,   -1,
+   -1,   -1,   94,   -1,  124,   -1,   60,   -1,   62,   63,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  268,
+  269,  270,  271,  272,  273,  274,  275,   -1,   -1,   94,
+   -1,   -1,  124,   -1,   -1,   -1,   -1,   37,   38,   -1,
+   94,   41,   42,   43,   -1,   45,   -1,   47,   37,   38,
+   -1,   -1,   41,   42,   43,   -1,   45,   -1,   47,  124,
+   60,   -1,   62,   63,   -1,   -1,   -1,   -1,   -1,   -1,
+  124,   60,   -1,   62,   63,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  268,  269,  270,  271,  272,  273,  274,  275,
+   -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,  268,
+  269,  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  124,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  124,  268,  269,  270,  271,
+  272,  273,  274,  275,   -1,   -1,   -1,   -1,  268,  269,
+  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   37,   38,   -1,   -1,   41,
+   42,   43,   -1,   45,   -1,   47,  268,  269,  270,  271,
+  272,  273,  274,  275,   -1,   -1,   -1,   -1,   60,   -1,
+   62,   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  268,  269,  270,  271,  272,  273,  274,
+  275,   -1,   -1,   -1,  268,  269,  270,  271,  272,  273,
+  274,  275,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   37,   38,   -1,   -1,   41,   42,   43,   -1,   45,   -1,
+   47,   37,   38,   -1,   -1,   41,   42,   43,   -1,   45,
+   -1,   47,  124,   60,   -1,   62,   63,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   60,   -1,   62,   63,  268,  269,
+  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,  268,
+  269,  270,  271,  272,  273,  274,  275,   94,   -1,   37,
+   38,   -1,   -1,   41,   42,   43,   -1,   45,   94,   47,
+   37,   38,   -1,   -1,   41,   42,   43,   -1,   45,   -1,
+   47,   -1,   60,   -1,   62,   63,   -1,  124,   -1,   -1,
+   -1,   -1,   -1,   60,   -1,   62,   63,   -1,  124,   37,
+   38,   -1,   -1,   41,   42,   43,   -1,   45,   -1,   47,
+   -1,   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,
+   -1,   -1,   60,   -1,   62,   63,   -1,   94,   37,   38,
+   -1,   -1,   41,   42,   43,   -1,   45,   -1,   47,   37,
+   38,   -1,   -1,   41,   42,   43,  124,   45,   -1,   47,
+   -1,   60,   -1,   62,   63,   -1,   94,  124,   -1,   -1,
+   -1,   -1,   60,   -1,   62,   63,  268,  269,  270,  271,
+  272,  273,  274,  275,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   37,   38,   94,  124,   41,   42,   43,
+   -1,   45,   -1,   47,   37,   38,   94,   -1,   -1,   42,
+   43,   -1,   45,   -1,   47,   -1,   60,   -1,   62,   63,
+   -1,   -1,   -1,   -1,   -1,  124,   -1,   60,   -1,   62,
+   63,   -1,   -1,   -1,   -1,   -1,  124,   -1,   -1,   -1,
+   -1,  268,  269,  270,  271,  272,  273,  274,  275,   -1,
+   94,   -1,  268,  269,  270,  271,  272,  273,  274,  275,
+   -1,   94,   37,   38,   -1,   -1,   -1,   42,   43,   -1,
+   45,   -1,   47,   37,   38,   -1,   -1,   -1,   42,   43,
+  124,   45,   -1,   47,   -1,   60,   -1,   62,   -1,   -1,
+   -1,  124,   -1,   -1,   -1,   -1,   60,   -1,   62,   -1,
+  268,  269,  270,  271,  272,  273,  274,  275,   -1,   -1,
+   -1,  268,  269,  270,  271,  272,  273,  274,  275,   94,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    15,   133,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,   133,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    15,   133,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    33,    34,    -1,   133,    15,     4,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    -1,    -1,    37,     4,
+   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  268,  269,  270,  271,  272,  273,  274,  275,   -1,  124,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    38,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+  124,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  268,
+  269,  270,  271,  272,  273,  274,  275,   -1,   -1,   -1,
+  268,  269,  270,  271,  272,  273,  274,  275,   37,   38,
+   -1,   -1,   -1,   42,   43,   -1,   45,   -1,   47,   -1,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    36,   133,    38,    61,    -1,    -1,    -1,    -1,    -1,
+   -1,   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  268,  269,  270,  271,  272,  273,
+  274,  275,   -1,   -1,   -1,  268,  269,  270,  271,  272,
+  273,  274,  275,  258,   -1,   94,   -1,   -1,   -1,   -1,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,   133,    -1,    -1,    -1,    61,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    94,    -1,    -1,
-      -1,    -1,   133,   100,   101,   102,   103,   104,   105,   106,
-     107,   108,    -1,   110,   111,   112,   113,   114,    -1,    94,
-      -1,    -1,   119,   120,   121,   100,   101,   102,   103,   104,
-      -1,   106,   107,   108,    -1,   110,   111,   112,   113,   114,
-      -1,    -1,    -1,    -1,   119,   120,   121,    15,    16,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,    16,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34,    15,    -1,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    33,    34
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
-{
-       0,   116,   117,   118,   127,   141,   155,   156,   145,   146,
-     143,   144,   242,   243,     0,   157,   147,     4,    53,   122,
-     246,   247,     4,    46,    47,    56,    57,    58,    59,    61,
-      62,    70,    71,    72,    73,    80,    81,    82,    83,    84,
-      85,    90,    91,    92,    97,    98,   109,   120,   134,   158,
-     165,   167,   184,   186,   195,   196,   198,   200,   234,   244,
-     245,     4,    38,    61,    94,   100,   101,   102,   103,   104,
-     106,   107,   108,   110,   111,   112,   113,   114,   119,   120,
-     121,   148,     6,     4,   120,   123,   124,   125,   249,   250,
-      53,   247,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,   182,    53,    53,    37,    37,     4,   142,    53,    37,
-      37,    37,    37,    37,    37,    37,    37,    37,   159,    37,
-      37,    37,   168,    37,   133,   134,   183,   126,     4,   142,
-       4,     3,     4,    30,    31,    37,    38,    39,    48,    49,
-      50,    55,    60,    69,    74,    75,    76,    77,    78,    79,
-      86,    88,   103,   109,   138,   139,   204,     4,     4,   152,
-       4,   151,   150,     4,     4,     4,   204,     4,     3,     4,
-     153,     4,   154,     4,   105,   204,     4,    16,    16,    54,
-     134,   249,   202,   203,   202,   166,   235,     4,     4,   160,
-       4,   188,     4,   142,   142,     4,   142,   135,   142,   197,
-     199,     4,   201,     4,     5,    99,   161,    37,   142,     4,
-       4,    37,   154,    53,     6,   133,   149,     6,   133,   204,
-     204,   204,    37,    37,    37,    37,    37,    37,    37,    37,
-      37,    37,    37,    37,    37,    37,    37,    37,    37,   204,
-     204,    15,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-     133,     6,   133,   204,   133,   133,     4,   133,     6,   133,
-     204,   133,   133,     4,   133,    53,   124,   125,   250,   250,
-     134,     4,   120,   123,   124,   125,    54,   204,     4,    54,
-      68,    91,   167,   210,     4,    54,   236,   133,   135,   135,
-     157,   189,   187,   135,   135,   135,   135,   135,   133,   135,
-     185,   135,   185,   133,   201,   135,    37,     4,     5,    99,
-     133,   135,   161,   135,     6,     6,   204,   135,   246,   204,
-     204,   147,   204,   204,   135,   204,   204,   204,   204,   204,
-       4,     4,   204,     4,     4,     4,   204,   204,     4,     4,
-     204,   204,   204,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,   204,   204,   204,   204,   204,   204,
-     204,   204,   204,   204,     4,     4,     4,   204,   204,     3,
-       4,     4,     4,   252,   134,   134,     4,   122,   134,   248,
-     211,   216,   221,   237,     4,    36,    37,   192,    54,   133,
-     188,   142,   142,   201,   162,    37,     4,     5,    99,   135,
-     202,   202,   133,    54,    36,   133,   135,   135,   133,   133,
-     135,   133,   135,   135,   135,   135,   135,   133,   133,   135,
-     135,   135,   133,    16,   250,   125,    53,   122,   134,    37,
-      40,   204,   224,   225,    16,   204,   226,   225,   204,   239,
-     133,     4,   138,   193,   194,    16,   188,   161,   164,    37,
-     135,   135,     4,   204,   204,   204,   204,   204,   204,     4,
-     204,   134,   253,    16,   251,    64,    65,    66,    67,    68,
-     135,   223,    37,    37,   224,    16,    95,   206,    16,    85,
-     227,   222,     4,    95,   240,     4,     4,   135,   194,    86,
-     190,   135,   161,   163,   135,   135,   135,   135,   135,   135,
-     135,   135,    54,   250,   250,   135,   204,    16,    37,    38,
-     207,   206,    53,    37,   241,    37,   238,   135,     6,   185,
-     135,   161,   134,   253,   135,   204,    37,    96,   208,   208,
-     166,   204,   240,   204,   134,   202,    88,   191,   135,    54,
-      39,   224,   135,   204,    37,   212,   217,    54,   135,   135,
-       6,    37,    16,   135,   204,   129,   130,   131,   209,    53,
-     240,   202,   204,   135,    53,   218,   135,   213,   230,   224,
-       4,    15,    32,    41,    42,    43,    44,    45,    51,    52,
-      87,    89,    93,   128,   132,   134,   136,   169,   170,   173,
-     174,   176,   177,   178,   179,   184,     4,    54,    16,    37,
-      37,    37,    37,    37,     4,    51,   170,   172,    37,   176,
-      54,    37,   183,   231,   219,    51,    52,    93,   132,   169,
-      51,    52,   169,   180,   202,   175,   169,   171,    37,   137,
-     185,   172,   214,   202,    53,    25,   228,    37,    37,   135,
-      37,   135,    37,    37,   135,   135,     4,   173,   135,   169,
-     170,   135,   228,   135,   178,     4,    95,   205,   169,   169,
-     171,   169,   169,   135,   169,   205,    54,    25,   229,   135,
-     135,   135,   135,   135,   229,   232,     4,     6,    16,   181,
-     135,   135,   169,   135,   135,   181,   229,   180,     4,   220,
-     135,   215,   181,   185,   185,   233,   185
+   -1,   -1,  277,  278,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  258,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  299,   -1,   -1,   -1,   -1,   -1,
+   -1,  278,   -1,   -1,  269,  270,  271,  272,  273,  274,
+  275,   -1,   -1,   -1,   -1,   -1,  270,  271,  272,  273,
+  274,  275,  299,   -1,   -1,   -1,   -1,  332,   -1,   -1,
+   -1,   -1,   -1,  338,  339,  340,  341,  342,   -1,  344,
+  345,  346,   -1,  348,  349,  350,  351,  352,   -1,   -1,
+   -1,   -1,  357,  358,  359,  332,   -1,   -1,   -1,   -1,
+   -1,  338,  339,  340,  341,  342,   -1,  344,  345,  346,
+   -1,  348,  349,  350,  351,  352,   -1,   -1,   -1,   -1,
+  357,  358,  359,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  270,  271,  272,  273,  274,  275,
 };
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (0)
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (N)								\
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (0)
-#endif
-
-
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-              (Loc).first_line, (Loc).first_column,	\
-              (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
+#define YYFINAL 5
+#ifndef YYDEBUG
+#define YYDEBUG 0
 #endif
-
-/* Enable debugging if requested.  */
+#define YYMAXTOKEN 370
 #if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (0)
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr,					\
-                  Type, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_stack_print (short int *bottom, short int *top)
+#if defined(__cplusplus) || defined(__STDC__)
+const char * const yyname[] =
 #else
-static void
-yy_stack_print (bottom, top)
-    short int *bottom;
-    short int *top;
+char *yyname[] =
 #endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yy_reduce_print (int yyrule)
+	{
+"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+"'!'",0,0,0,"'%'","'&'",0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,0,0,
+0,0,0,0,0,"':'","';'","'<'","'='","'>'","'?'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"INT","NAME",
+"LNAME","PLUSEQ","MINUSEQ","MULTEQ","DIVEQ","LSHIFTEQ","RSHIFTEQ","ANDEQ",
+"OREQ","OROR","ANDAND","EQ","NE","LE","GE","LSHIFT","RSHIFT","UNARY","END",
+"ALIGN_K","BLOCK","BIND","QUAD","SQUAD","LONG","SHORT","BYTE","SECTIONS",
+"PHDRS","DATA_SEGMENT_ALIGN","DATA_SEGMENT_RELRO_END","DATA_SEGMENT_END",
+"SORT_BY_NAME","SORT_BY_ALIGNMENT","SIZEOF_HEADERS","OUTPUT_FORMAT",
+"FORCE_COMMON_ALLOCATION","OUTPUT_ARCH","INHIBIT_COMMON_ALLOCATION",
+"SEGMENT_START","INCLUDE","MEMORY","DEFSYMEND","NOLOAD","DSECT","COPY","INFO",
+"OVERLAY","DEFINED","TARGET_K","SEARCH_DIR","MAP","ENTRY","NEXT","SIZEOF",
+"ADDR","LOADADDR","MAX_K","MIN_K","STARTUP","HLL","SYSLIB","FLOAT","NOFLOAT",
+"NOCROSSREFS","ORIGIN","FILL","LENGTH","CREATE_OBJECT_SYMBOLS","INPUT","GROUP",
+"OUTPUT","CONSTRUCTORS","ALIGNMOD","AT","SUBALIGN","PROVIDE","PROVIDE_HIDDEN",
+"AS_NEEDED","CHIP","LIST","SECT","ABSOLUTE","LOAD","NEWLINE","ENDWORD","ORDER",
+"NAMEWORD","ASSERT_K","FORMAT","PUBLIC","BASE","ALIAS","TRUNCATE","REL",
+"INPUT_SCRIPT","INPUT_MRI_SCRIPT","INPUT_DEFSYM","CASE","EXTERN","START",
+"VERS_TAG","VERS_IDENTIFIER","GLOBAL","LOCAL","VERSIONK","INPUT_VERSION_SCRIPT",
+"KEEP","ONLY_IF_RO","ONLY_IF_RW","SPECIAL","EXCLUDE_FILE",
+};
+#if defined(__cplusplus) || defined(__STDC__)
+const char * const yyrule[] =
 #else
-static void
-yy_reduce_print (yyrule)
-    int yyrule;
-#endif
-{
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
+char *yyrule[] =
 #endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
+	{"$accept : file",
+"file : INPUT_SCRIPT script_file",
+"file : INPUT_MRI_SCRIPT mri_script_file",
+"file : INPUT_VERSION_SCRIPT version_script_file",
+"file : INPUT_DEFSYM defsym_expr",
+"filename : NAME",
+"$$1 :",
+"defsym_expr : $$1 NAME '=' exp",
+"$$2 :",
+"mri_script_file : $$2 mri_script_lines",
+"mri_script_lines : mri_script_lines mri_script_command NEWLINE",
+"mri_script_lines :",
+"mri_script_command : CHIP exp",
+"mri_script_command : CHIP exp ',' exp",
+"mri_script_command : NAME",
+"mri_script_command : LIST",
+"mri_script_command : ORDER ordernamelist",
+"mri_script_command : ENDWORD",
+"mri_script_command : PUBLIC NAME '=' exp",
+"mri_script_command : PUBLIC NAME ',' exp",
+"mri_script_command : PUBLIC NAME exp",
+"mri_script_command : FORMAT NAME",
+"mri_script_command : SECT NAME ',' exp",
+"mri_script_command : SECT NAME exp",
+"mri_script_command : SECT NAME '=' exp",
+"mri_script_command : ALIGN_K NAME '=' exp",
+"mri_script_command : ALIGN_K NAME ',' exp",
+"mri_script_command : ALIGNMOD NAME '=' exp",
+"mri_script_command : ALIGNMOD NAME ',' exp",
+"mri_script_command : ABSOLUTE mri_abs_name_list",
+"mri_script_command : LOAD mri_load_name_list",
+"mri_script_command : NAMEWORD NAME",
+"mri_script_command : ALIAS NAME ',' NAME",
+"mri_script_command : ALIAS NAME ',' INT",
+"mri_script_command : BASE exp",
+"mri_script_command : TRUNCATE INT",
+"mri_script_command : CASE casesymlist",
+"mri_script_command : EXTERN extern_name_list",
+"$$3 :",
+"mri_script_command : INCLUDE filename $$3 mri_script_lines END",
+"mri_script_command : START NAME",
+"mri_script_command :",
+"ordernamelist : ordernamelist ',' NAME",
+"ordernamelist : ordernamelist NAME",
+"ordernamelist :",
+"mri_load_name_list : NAME",
+"mri_load_name_list : mri_load_name_list ',' NAME",
+"mri_abs_name_list : NAME",
+"mri_abs_name_list : mri_abs_name_list ',' NAME",
+"casesymlist :",
+"casesymlist : NAME",
+"casesymlist : casesymlist ',' NAME",
+"extern_name_list : NAME",
+"extern_name_list : extern_name_list NAME",
+"extern_name_list : extern_name_list ',' NAME",
+"$$4 :",
+"script_file : $$4 ifile_list",
+"ifile_list : ifile_list ifile_p1",
+"ifile_list :",
+"ifile_p1 : memory",
+"ifile_p1 : sections",
+"ifile_p1 : phdrs",
+"ifile_p1 : startup",
+"ifile_p1 : high_level_library",
+"ifile_p1 : low_level_library",
+"ifile_p1 : floating_point_support",
+"ifile_p1 : statement_anywhere",
+"ifile_p1 : version",
+"ifile_p1 : ';'",
+"ifile_p1 : TARGET_K '(' NAME ')'",
+"ifile_p1 : SEARCH_DIR '(' filename ')'",
+"ifile_p1 : OUTPUT '(' filename ')'",
+"ifile_p1 : OUTPUT_FORMAT '(' NAME ')'",
+"ifile_p1 : OUTPUT_FORMAT '(' NAME ',' NAME ',' NAME ')'",
+"ifile_p1 : OUTPUT_ARCH '(' NAME ')'",
+"ifile_p1 : FORCE_COMMON_ALLOCATION",
+"ifile_p1 : INHIBIT_COMMON_ALLOCATION",
+"ifile_p1 : INPUT '(' input_list ')'",
+"$$5 :",
+"ifile_p1 : GROUP $$5 '(' input_list ')'",
+"ifile_p1 : MAP '(' filename ')'",
+"$$6 :",
+"ifile_p1 : INCLUDE filename $$6 ifile_list END",
+"ifile_p1 : NOCROSSREFS '(' nocrossref_list ')'",
+"ifile_p1 : EXTERN '(' extern_name_list ')'",
+"input_list : NAME",
+"input_list : input_list ',' NAME",
+"input_list : input_list NAME",
+"input_list : LNAME",
+"input_list : input_list ',' LNAME",
+"input_list : input_list LNAME",
+"$$7 :",
+"input_list : AS_NEEDED '(' $$7 input_list ')'",
+"$$8 :",
+"input_list : input_list ',' AS_NEEDED '(' $$8 input_list ')'",
+"$$9 :",
+"input_list : input_list AS_NEEDED '(' $$9 input_list ')'",
+"sections : SECTIONS '{' sec_or_group_p1 '}'",
+"sec_or_group_p1 : sec_or_group_p1 section",
+"sec_or_group_p1 : sec_or_group_p1 statement_anywhere",
+"sec_or_group_p1 :",
+"statement_anywhere : ENTRY '(' NAME ')'",
+"statement_anywhere : assignment end",
+"$$10 :",
+"statement_anywhere : ASSERT_K $$10 '(' exp ',' NAME ')'",
+"wildcard_name : NAME",
+"wildcard_name : '*'",
+"wildcard_name : '?'",
+"wildcard_spec : wildcard_name",
+"wildcard_spec : EXCLUDE_FILE '(' exclude_name_list ')' wildcard_name",
+"wildcard_spec : SORT_BY_NAME '(' wildcard_name ')'",
+"wildcard_spec : SORT_BY_ALIGNMENT '(' wildcard_name ')'",
+"wildcard_spec : SORT_BY_NAME '(' SORT_BY_ALIGNMENT '(' wildcard_name ')' ')'",
+"wildcard_spec : SORT_BY_NAME '(' SORT_BY_NAME '(' wildcard_name ')' ')'",
+"wildcard_spec : SORT_BY_ALIGNMENT '(' SORT_BY_NAME '(' wildcard_name ')' ')'",
+"wildcard_spec : SORT_BY_ALIGNMENT '(' SORT_BY_ALIGNMENT '(' wildcard_name ')' ')'",
+"wildcard_spec : SORT_BY_NAME '(' EXCLUDE_FILE '(' exclude_name_list ')' wildcard_name ')'",
+"exclude_name_list : exclude_name_list wildcard_name",
+"exclude_name_list : wildcard_name",
+"file_NAME_list : file_NAME_list opt_comma wildcard_spec",
+"file_NAME_list : wildcard_spec",
+"input_section_spec_no_keep : NAME",
+"input_section_spec_no_keep : '[' file_NAME_list ']'",
+"input_section_spec_no_keep : wildcard_spec '(' file_NAME_list ')'",
+"input_section_spec : input_section_spec_no_keep",
+"$$11 :",
+"input_section_spec : KEEP '(' $$11 input_section_spec_no_keep ')'",
+"statement : assignment end",
+"statement : CREATE_OBJECT_SYMBOLS",
+"statement : ';'",
+"statement : CONSTRUCTORS",
+"statement : SORT_BY_NAME '(' CONSTRUCTORS ')'",
+"statement : input_section_spec",
+"statement : length '(' mustbe_exp ')'",
+"statement : FILL '(' fill_exp ')'",
+"statement_list : statement_list statement",
+"statement_list : statement",
+"statement_list_opt :",
+"statement_list_opt : statement_list",
+"length : QUAD",
+"length : SQUAD",
+"length : LONG",
+"length : SHORT",
+"length : BYTE",
+"fill_exp : mustbe_exp",
+"fill_opt : '=' fill_exp",
+"fill_opt :",
+"assign_op : PLUSEQ",
+"assign_op : MINUSEQ",
+"assign_op : MULTEQ",
+"assign_op : DIVEQ",
+"assign_op : LSHIFTEQ",
+"assign_op : RSHIFTEQ",
+"assign_op : ANDEQ",
+"assign_op : OREQ",
+"end : ';'",
+"end : ','",
+"assignment : NAME '=' mustbe_exp",
+"assignment : NAME assign_op mustbe_exp",
+"assignment : PROVIDE '(' NAME '=' mustbe_exp ')'",
+"assignment : PROVIDE_HIDDEN '(' NAME '=' mustbe_exp ')'",
+"opt_comma : ','",
+"opt_comma :",
+"memory : MEMORY '{' memory_spec memory_spec_list '}'",
+"memory_spec_list : memory_spec_list memory_spec",
+"memory_spec_list : memory_spec_list ',' memory_spec",
+"memory_spec_list :",
+"$$12 :",
+"memory_spec : NAME $$12 attributes_opt ':' origin_spec opt_comma length_spec",
+"origin_spec : ORIGIN '=' mustbe_exp",
+"length_spec : LENGTH '=' mustbe_exp",
+"attributes_opt :",
+"attributes_opt : '(' attributes_list ')'",
+"attributes_list : attributes_string",
+"attributes_list : attributes_list attributes_string",
+"attributes_string : NAME",
+"attributes_string : '!' NAME",
+"startup : STARTUP '(' filename ')'",
+"high_level_library : HLL '(' high_level_library_NAME_list ')'",
+"high_level_library : HLL '(' ')'",
+"high_level_library_NAME_list : high_level_library_NAME_list opt_comma filename",
+"high_level_library_NAME_list : filename",
+"low_level_library : SYSLIB '(' low_level_library_NAME_list ')'",
+"low_level_library_NAME_list : low_level_library_NAME_list opt_comma filename",
+"low_level_library_NAME_list :",
+"floating_point_support : FLOAT",
+"floating_point_support : NOFLOAT",
+"nocrossref_list :",
+"nocrossref_list : NAME nocrossref_list",
+"nocrossref_list : NAME ',' nocrossref_list",
+"$$13 :",
+"mustbe_exp : $$13 exp",
+"exp : '-' exp",
+"exp : '(' exp ')'",
+"exp : NEXT '(' exp ')'",
+"exp : '!' exp",
+"exp : '+' exp",
+"exp : '~' exp",
+"exp : exp '*' exp",
+"exp : exp '/' exp",
+"exp : exp '%' exp",
+"exp : exp '+' exp",
+"exp : exp '-' exp",
+"exp : exp LSHIFT exp",
+"exp : exp RSHIFT exp",
+"exp : exp EQ exp",
+"exp : exp NE exp",
+"exp : exp LE exp",
+"exp : exp GE exp",
+"exp : exp '<' exp",
+"exp : exp '>' exp",
+"exp : exp '&' exp",
+"exp : exp '^' exp",
+"exp : exp '|' exp",
+"exp : exp '?' exp ':' exp",
+"exp : exp ANDAND exp",
+"exp : exp OROR exp",
+"exp : DEFINED '(' NAME ')'",
+"exp : INT",
+"exp : SIZEOF_HEADERS",
+"exp : SIZEOF '(' NAME ')'",
+"exp : ADDR '(' NAME ')'",
+"exp : LOADADDR '(' NAME ')'",
+"exp : ABSOLUTE '(' exp ')'",
+"exp : ALIGN_K '(' exp ')'",
+"exp : ALIGN_K '(' exp ',' exp ')'",
+"exp : DATA_SEGMENT_ALIGN '(' exp ',' exp ')'",
+"exp : DATA_SEGMENT_RELRO_END '(' exp ',' exp ')'",
+"exp : DATA_SEGMENT_END '(' exp ')'",
+"exp : SEGMENT_START '(' NAME ',' exp ')'",
+"exp : BLOCK '(' exp ')'",
+"exp : NAME",
+"exp : MAX_K '(' exp ',' exp ')'",
+"exp : MIN_K '(' exp ',' exp ')'",
+"exp : ASSERT_K '(' exp ',' NAME ')'",
+"exp : ORIGIN '(' NAME ')'",
+"exp : LENGTH '(' NAME ')'",
+"memspec_at_opt : AT '>' NAME",
+"memspec_at_opt :",
+"opt_at : AT '(' exp ')'",
+"opt_at :",
+"opt_align : ALIGN_K '(' exp ')'",
+"opt_align :",
+"opt_subalign : SUBALIGN '(' exp ')'",
+"opt_subalign :",
+"sect_constraint : ONLY_IF_RO",
+"sect_constraint : ONLY_IF_RW",
+"sect_constraint : SPECIAL",
+"sect_constraint :",
+"$$14 :",
+"$$15 :",
+"$$16 :",
+"$$17 :",
+"$$18 :",
+"section : NAME $$14 opt_exp_with_type opt_at opt_align opt_subalign $$15 sect_constraint '{' $$16 statement_list_opt '}' $$17 memspec_opt memspec_at_opt phdr_opt fill_opt $$18 opt_comma",
+"$$19 :",
+"$$20 :",
+"$$21 :",
+"$$22 :",
+"$$23 :",
+"section : OVERLAY $$19 opt_exp_without_type opt_nocrossrefs opt_at opt_subalign $$20 '{' $$21 overlay_section '}' $$22 memspec_opt memspec_at_opt phdr_opt fill_opt $$23 opt_comma",
+"$$24 :",
+"$$25 :",
+"section : GROUP $$24 opt_exp_with_type $$25 '{' sec_or_group_p1 '}'",
+"type : NOLOAD",
+"type : DSECT",
+"type : COPY",
+"type : INFO",
+"type : OVERLAY",
+"atype : '(' type ')'",
+"atype :",
+"atype : '(' ')'",
+"opt_exp_with_type : exp atype ':'",
+"opt_exp_with_type : atype ':'",
+"opt_exp_with_type : BIND '(' exp ')' atype ':'",
+"opt_exp_with_type : BIND '(' exp ')' BLOCK '(' exp ')' atype ':'",
+"opt_exp_without_type : exp ':'",
+"opt_exp_without_type : ':'",
+"opt_nocrossrefs :",
+"opt_nocrossrefs : NOCROSSREFS",
+"memspec_opt : '>' NAME",
+"memspec_opt :",
+"phdr_opt :",
+"phdr_opt : phdr_opt ':' NAME",
+"overlay_section :",
+"$$26 :",
+"$$27 :",
+"$$28 :",
+"overlay_section : overlay_section NAME $$26 '{' statement_list_opt '}' $$27 phdr_opt fill_opt $$28 opt_comma",
+"phdrs : PHDRS '{' phdr_list '}'",
+"phdr_list :",
+"phdr_list : phdr_list phdr",
+"$$29 :",
+"$$30 :",
+"phdr : NAME $$29 phdr_type phdr_qualifiers $$30 ';'",
+"phdr_type : exp",
+"phdr_qualifiers :",
+"phdr_qualifiers : NAME phdr_val phdr_qualifiers",
+"phdr_qualifiers : AT '(' exp ')' phdr_qualifiers",
+"phdr_val :",
+"phdr_val : '(' exp ')'",
+"$$31 :",
+"version_script_file : $$31 vers_nodes",
+"$$32 :",
+"version : $$32 VERSIONK '{' vers_nodes '}'",
+"vers_nodes : vers_node",
+"vers_nodes : vers_nodes vers_node",
+"vers_node : '{' vers_tag '}' ';'",
+"vers_node : VERS_TAG '{' vers_tag '}' ';'",
+"vers_node : VERS_TAG '{' vers_tag '}' verdep ';'",
+"verdep : VERS_TAG",
+"verdep : verdep VERS_TAG",
+"vers_tag :",
+"vers_tag : vers_defns ';'",
+"vers_tag : GLOBAL ':' vers_defns ';'",
+"vers_tag : LOCAL ':' vers_defns ';'",
+"vers_tag : GLOBAL ':' vers_defns ';' LOCAL ':' vers_defns ';'",
+"vers_defns : VERS_IDENTIFIER",
+"vers_defns : NAME",
+"vers_defns : vers_defns ';' VERS_IDENTIFIER",
+"vers_defns : vers_defns ';' NAME",
+"$$33 :",
+"vers_defns : vers_defns ';' EXTERN NAME '{' $$33 vers_defns opt_semicolon '}'",
+"$$34 :",
+"vers_defns : EXTERN NAME '{' $$34 vers_defns opt_semicolon '}'",
+"vers_defns : GLOBAL",
+"vers_defns : vers_defns ';' GLOBAL",
+"vers_defns : LOCAL",
+"vers_defns : vers_defns ';' LOCAL",
+"vers_defns : EXTERN",
+"vers_defns : vers_defns ';' EXTERN",
+"opt_semicolon :",
+"opt_semicolon : ';'",
+};
 #endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
-yystrlen (const char *yystr)
-#   else
-yystrlen (yystr)
-     const char *yystr;
-#   endif
-{
-  const char *yys = yystr;
-
-  while (*yys++ != '\0')
-    continue;
-
-  return yys - yystr - 1;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-#   if defined (__STDC__) || defined (__cplusplus)
-yystpcpy (char *yydest, const char *yysrc)
-#   else
-yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      size_t yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-#endif /* YYERROR_VERBOSE */
-
-
-
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH YYSTACKSIZE
 #else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 10000
+#define YYMAXDEPTH 10000
+#endif
 #endif
+#define YYINITSTACKSIZE 200
+/* LINTUSED */
+int yydebug;
+int yynerrs;
+int yyerrflag;
+int yychar;
+short *yyssp;
+YYSTYPE *yyvsp;
+YYSTYPE yyval;
+YYSTYPE yylval;
+short *yyss;
+short *yysslim;
+YYSTYPE *yyvs;
+int yystacksize;
+#line 1291 "ldgram.y"
+void
+yyerror(arg)
+     const char *arg;
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  if (ldfile_assumed_script)
+    einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
+	   ldfile_input_filename);
+  if (error_index > 0 && error_index < ERROR_NAME_MAX)
+     einfo ("%P%F:%S: %s in %s\n", arg, error_names[error_index-1]);
   else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  switch (yytype)
-    {
-      default:
-        break;
-    }
-  YYFPRINTF (yyoutput, ")");
+     einfo ("%P%F:%S: %s\n", arg);
 }
-
-#endif /* ! YYDEBUG */
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#line 1624 "ldgram.c"
+/* allocate initial stack or double stack size, up to YYMAXDEPTH */
+#if defined(__cplusplus) || defined(__STDC__)
+static int yygrowstack(void)
 #else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
+static int yygrowstack()
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
+    int newsize, i;
+    short *newss;
+    YYSTYPE *newvs;
+
+    if ((newsize = yystacksize) == 0)
+        newsize = YYINITSTACKSIZE;
+    else if (newsize >= YYMAXDEPTH)
+        return -1;
+    else if ((newsize *= 2) > YYMAXDEPTH)
+        newsize = YYMAXDEPTH;
+    i = yyssp - yyss;
+    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
+      (short *)malloc(newsize * sizeof *newss);
+    if (newss == NULL)
+        goto bail;
+    yyss = newss;
+    yyssp = newss + i;
+    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
+      (YYSTYPE *)malloc(newsize * sizeof *newvs);
+    if (newvs == NULL)
+        goto bail;
+    yyvs = newvs;
+    yyvsp = newvs + i;
+    yystacksize = newsize;
+    yysslim = yyss + newsize - 1;
+    return 0;
+bail:
+    if (yyss)
+            free(yyss);
+    if (yyvs)
+            free(yyvs);
+    yyss = yyssp = NULL;
+    yyvs = yyvsp = NULL;
+    yystacksize = 0;
+    return -1;
 }
 
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM);
-# else
-int yyparse ();
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The look-ahead symbol.  */
-int yychar;
-
-/* The semantic value of the look-ahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
-#else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#define YYABORT goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR goto yyerrlab
 int
-yyparse (void)
+#if defined(__cplusplus) || defined(__STDC__)
+yyparse(void)
 #else
-int
-yyparse ()
-    ;
-#endif
+yyparse()
 #endif
 {
+    int yym, yyn, yystate;
+#if YYDEBUG
+#if defined(__cplusplus) || defined(__STDC__)
+    const char *yys;
+#else /* !(defined(__cplusplus) || defined(__STDC__)) */
+    char *yys;
+#endif /* !(defined(__cplusplus) || defined(__STDC__)) */
+
+    if ((yys = getenv("YYDEBUG")))
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+#endif /* YYDEBUG */
   
-  int yystate;
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  short int yyssa[YYINITDEPTH];
-  short int *yyss = yyssa;
-  short int *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
+    yyerrflag = 0;
+    yychar = (-1);
 
+    if (yyss == NULL && yygrowstack()) goto yyoverflow;
   yyssp = yyss;
   yyvsp = yyvs;
+    *yyssp = yystate = 0;
 
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
+yyloop:
+    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yychar < 0)
     {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
+        if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+        if (yydebug)
       {
-	/* Give user a chance to reallocate the stack. Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	short int *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, reading %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
+#endif
+    }
+    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
       {
-	short int *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: state %d, shifting to state %d\n",
+                    YYPREFIX, yystate, yytable[yyn]);
+#endif
+        if (yyssp >= yysslim && yygrowstack())
+        {
+            goto yyoverflow;
       }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
+        *++yyssp = yystate = yytable[yyn];
+        *++yyvsp = yylval;
+        yychar = (-1);
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
     }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a look-ahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to look-ahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a look-ahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
-  if (yychar == YYEMPTY)
+    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
+        yyn = yytable[yyn];
+        goto yyreduce;
     }
-
-  if (yychar <= YYEOF)
+    if (yyerrflag) goto yyinrecovery;
+#if defined(lint) || defined(__GNUC__)
+    goto yynewerror;
+#endif
+yynewerror:
+    yyerror("syntax error");
+#if defined(lint) || defined(__GNUC__)
+    goto yyerrlab;
+#endif
+yyerrlab:
+    ++yynerrs;
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
     {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: state %d, error recovery shifting\
+ to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
+#endif
+                if (yyssp >= yysslim && yygrowstack())
+                {
+                    goto yyoverflow;
+                }
+                *++yyssp = yystate = yytable[yyn];
+                *++yyvsp = yylval;
+                goto yyloop;
     }
   else
     {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: error recovery discarding state %d\n",
+                            YYPREFIX, *yyssp);
+#endif
+                if (yyssp <= yyss) goto yyabort;
+                --yyssp;
+                --yyvsp;
     }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
+        }
+    }
+    else
     {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
+        if (yychar == 0) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+        yychar = (-1);
+        goto yyloop;
     }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the look-ahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
 yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
+                YYPREFIX, yystate, yyn, yyrule[yyn]);
+#endif
+    yym = yylen[yyn];
+    yyval = yyvsp[1-yym];
   switch (yyn)
     {
-        case 7:
+case 6:
 #line 173 "ldgram.y"
-    { ldlex_defsym(); }
-    break;
-
-  case 8:
+{ ldlex_defsym(); }
+break;
+case 7:
 #line 175 "ldgram.y"
-    {
+{
 		  ldlex_popstate();
-		  lang_add_assignment(exp_assop((yyvsp[-1].token),(yyvsp[-2].name),(yyvsp[0].etree)));
+		  lang_add_assignment(exp_assop(yyvsp[-1].token,yyvsp[-2].name,yyvsp[0].etree));
 		}
-    break;
-
-  case 9:
+break;
+case 8:
 #line 183 "ldgram.y"
-    {
+{
 		  ldlex_mri_script ();
 		  PUSH_ERROR (_("MRI style script"));
 		}
-    break;
-
-  case 10:
+break;
+case 9:
 #line 188 "ldgram.y"
-    {
+{
 		  ldlex_popstate ();
 		  mri_draw_tree ();
 		  POP_ERROR ();
 		}
-    break;
-
-  case 15:
+break;
+case 14:
 #line 203 "ldgram.y"
-    {
-			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),(yyvsp[0].name));
+{
+			einfo(_("%P%F: unrecognised keyword in MRI style script '%s'\n"),yyvsp[0].name);
 			}
-    break;
-
-  case 16:
+break;
+case 15:
 #line 206 "ldgram.y"
-    {
+{
 			config.map_filename = "-";
 			}
-    break;
-
-  case 19:
+break;
+case 18:
 #line 212 "ldgram.y"
-    { mri_public((yyvsp[-2].name), (yyvsp[0].etree)); }
-    break;
-
-  case 20:
+{ mri_public(yyvsp[-2].name, yyvsp[0].etree); }
+break;
+case 19:
 #line 214 "ldgram.y"
-    { mri_public((yyvsp[-2].name), (yyvsp[0].etree)); }
-    break;
-
-  case 21:
+{ mri_public(yyvsp[-2].name, yyvsp[0].etree); }
+break;
+case 20:
 #line 216 "ldgram.y"
-    { mri_public((yyvsp[-1].name), (yyvsp[0].etree)); }
-    break;
-
-  case 22:
+{ mri_public(yyvsp[-1].name, yyvsp[0].etree); }
+break;
+case 21:
 #line 218 "ldgram.y"
-    { mri_format((yyvsp[0].name)); }
-    break;
-
-  case 23:
+{ mri_format(yyvsp[0].name); }
+break;
+case 22:
 #line 220 "ldgram.y"
-    { mri_output_section((yyvsp[-2].name), (yyvsp[0].etree));}
-    break;
-
-  case 24:
+{ mri_output_section(yyvsp[-2].name, yyvsp[0].etree);}
+break;
+case 23:
 #line 222 "ldgram.y"
-    { mri_output_section((yyvsp[-1].name), (yyvsp[0].etree));}
-    break;
-
-  case 25:
-#line 224 "ldgram.y"
-    { mri_output_section((yyvsp[-2].name), (yyvsp[0].etree));}
-    break;
-
-  case 26:
+{ mri_output_section(yyvsp[-1].name, yyvsp[0].etree);}
+break;
+case 24:
+#line 224 "ldgram.y"
+{ mri_output_section(yyvsp[-2].name, yyvsp[0].etree);}
+break;
+case 25:
 #line 226 "ldgram.y"
-    { mri_align((yyvsp[-2].name),(yyvsp[0].etree)); }
-    break;
-
-  case 27:
+{ mri_align(yyvsp[-2].name,yyvsp[0].etree); }
+break;
+case 26:
 #line 228 "ldgram.y"
-    { mri_align((yyvsp[-2].name),(yyvsp[0].etree)); }
-    break;
-
-  case 28:
+{ mri_align(yyvsp[-2].name,yyvsp[0].etree); }
+break;
+case 27:
 #line 230 "ldgram.y"
-    { mri_alignmod((yyvsp[-2].name),(yyvsp[0].etree)); }
-    break;
-
-  case 29:
+{ mri_alignmod(yyvsp[-2].name,yyvsp[0].etree); }
+break;
+case 28:
 #line 232 "ldgram.y"
-    { mri_alignmod((yyvsp[-2].name),(yyvsp[0].etree)); }
-    break;
-
-  case 32:
+{ mri_alignmod(yyvsp[-2].name,yyvsp[0].etree); }
+break;
+case 31:
 #line 236 "ldgram.y"
-    { mri_name((yyvsp[0].name)); }
-    break;
-
-  case 33:
+{ mri_name(yyvsp[0].name); }
+break;
+case 32:
 #line 238 "ldgram.y"
-    { mri_alias((yyvsp[-2].name),(yyvsp[0].name),0);}
-    break;
-
-  case 34:
+{ mri_alias(yyvsp[-2].name,yyvsp[0].name,0);}
+break;
+case 33:
 #line 240 "ldgram.y"
-    { mri_alias ((yyvsp[-2].name), 0, (int) (yyvsp[0].bigint).integer); }
-    break;
-
-  case 35:
+{ mri_alias (yyvsp[-2].name, 0, (int) yyvsp[0].bigint.integer); }
+break;
+case 34:
 #line 242 "ldgram.y"
-    { mri_base((yyvsp[0].etree)); }
-    break;
-
-  case 36:
+{ mri_base(yyvsp[0].etree); }
+break;
+case 35:
 #line 244 "ldgram.y"
-    { mri_truncate ((unsigned int) (yyvsp[0].bigint).integer); }
-    break;
-
-  case 39:
+{ mri_truncate ((unsigned int) yyvsp[0].bigint.integer); }
+break;
+case 38:
 #line 248 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file((yyvsp[0].name)); }
-    break;
-
-  case 40:
+{ ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
+break;
+case 39:
 #line 250 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 41:
+{ ldlex_popstate (); }
+break;
+case 40:
 #line 252 "ldgram.y"
-    { lang_add_entry ((yyvsp[0].name), FALSE); }
-    break;
-
-  case 43:
+{ lang_add_entry (yyvsp[0].name, FALSE); }
+break;
+case 42:
 #line 257 "ldgram.y"
-    { mri_order((yyvsp[0].name)); }
-    break;
-
-  case 44:
+{ mri_order(yyvsp[0].name); }
+break;
+case 43:
 #line 258 "ldgram.y"
-    { mri_order((yyvsp[0].name)); }
-    break;
-
-  case 46:
+{ mri_order(yyvsp[0].name); }
+break;
+case 45:
 #line 264 "ldgram.y"
-    { mri_load((yyvsp[0].name)); }
-    break;
-
-  case 47:
+{ mri_load(yyvsp[0].name); }
+break;
+case 46:
 #line 265 "ldgram.y"
-    { mri_load((yyvsp[0].name)); }
-    break;
-
-  case 48:
+{ mri_load(yyvsp[0].name); }
+break;
+case 47:
 #line 270 "ldgram.y"
-    { mri_only_load((yyvsp[0].name)); }
-    break;
-
-  case 49:
+{ mri_only_load(yyvsp[0].name); }
+break;
+case 48:
 #line 272 "ldgram.y"
-    { mri_only_load((yyvsp[0].name)); }
-    break;
-
-  case 50:
+{ mri_only_load(yyvsp[0].name); }
+break;
+case 49:
 #line 276 "ldgram.y"
-    { (yyval.name) = NULL; }
-    break;
-
-  case 53:
+{ yyval.name = NULL; }
+break;
+case 52:
 #line 283 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[0].name)); }
-    break;
-
-  case 54:
+{ ldlang_add_undef (yyvsp[0].name); }
+break;
+case 53:
 #line 285 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[0].name)); }
-    break;
-
-  case 55:
+{ ldlang_add_undef (yyvsp[0].name); }
+break;
+case 54:
 #line 287 "ldgram.y"
-    { ldlang_add_undef ((yyvsp[0].name)); }
-    break;
-
-  case 56:
+{ ldlang_add_undef (yyvsp[0].name); }
+break;
+case 55:
 #line 291 "ldgram.y"
-    {
+{
 	 ldlex_both();
 	}
-    break;
-
-  case 57:
+break;
+case 56:
 #line 295 "ldgram.y"
-    {
+{
 	ldlex_popstate();
 	}
-    break;
-
-  case 70:
+break;
+case 69:
 #line 320 "ldgram.y"
-    { lang_add_target((yyvsp[-1].name)); }
-    break;
-
-  case 71:
+{ lang_add_target(yyvsp[-1].name); }
+break;
+case 70:
 #line 322 "ldgram.y"
-    { ldfile_add_library_path ((yyvsp[-1].name), FALSE); }
-    break;
-
-  case 72:
+{ ldfile_add_library_path (yyvsp[-1].name, FALSE); }
+break;
+case 71:
 #line 324 "ldgram.y"
-    { lang_add_output((yyvsp[-1].name), 1); }
-    break;
-
-  case 73:
+{ lang_add_output(yyvsp[-1].name, 1); }
+break;
+case 72:
 #line 326 "ldgram.y"
-    { lang_add_output_format ((yyvsp[-1].name), (char *) NULL,
+{ lang_add_output_format (yyvsp[-1].name, (char *) NULL,
 					    (char *) NULL, 1); }
-    break;
-
-  case 74:
+break;
+case 73:
 #line 329 "ldgram.y"
-    { lang_add_output_format ((yyvsp[-5].name), (yyvsp[-3].name), (yyvsp[-1].name), 1); }
-    break;
-
-  case 75:
+{ lang_add_output_format (yyvsp[-5].name, yyvsp[-3].name, yyvsp[-1].name, 1); }
+break;
+case 74:
 #line 331 "ldgram.y"
-    { ldfile_set_output_arch ((yyvsp[-1].name), bfd_arch_unknown); }
-    break;
-
-  case 76:
+{ ldfile_set_output_arch (yyvsp[-1].name, bfd_arch_unknown); }
+break;
+case 75:
 #line 333 "ldgram.y"
-    { command_line.force_common_definition = TRUE ; }
-    break;
-
-  case 77:
+{ command_line.force_common_definition = TRUE ; }
+break;
+case 76:
 #line 335 "ldgram.y"
-    { command_line.inhibit_common_definition = TRUE ; }
-    break;
-
-  case 79:
+{ command_line.inhibit_common_definition = TRUE ; }
+break;
+case 78:
 #line 338 "ldgram.y"
-    { lang_enter_group (); }
-    break;
-
-  case 80:
+{ lang_enter_group (); }
+break;
+case 79:
 #line 340 "ldgram.y"
-    { lang_leave_group (); }
-    break;
-
-  case 81:
+{ lang_leave_group (); }
+break;
+case 80:
 #line 342 "ldgram.y"
-    { lang_add_map((yyvsp[-1].name)); }
-    break;
-
-  case 82:
+{ lang_add_map(yyvsp[-1].name); }
+break;
+case 81:
 #line 344 "ldgram.y"
-    { ldlex_script (); ldfile_open_command_file((yyvsp[0].name)); }
-    break;
-
-  case 83:
+{ ldlex_script (); ldfile_open_command_file(yyvsp[0].name); }
+break;
+case 82:
 #line 346 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 84:
+{ ldlex_popstate (); }
+break;
+case 83:
 #line 348 "ldgram.y"
-    {
-		  lang_add_nocrossref ((yyvsp[-1].nocrossref));
+{
+		  lang_add_nocrossref (yyvsp[-1].nocrossref);
 		}
-    break;
-
-  case 86:
+break;
+case 85:
 #line 356 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
-    break;
-
-  case 87:
+break;
+case 86:
 #line 359 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
-    break;
-
-  case 88:
+break;
+case 87:
 #line 362 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_search_file_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_search_file_enum,
 				 (char *)NULL); }
-    break;
-
-  case 89:
+break;
+case 88:
 #line 365 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
 				 (char *)NULL); }
-    break;
-
-  case 90:
+break;
+case 89:
 #line 368 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
 				 (char *)NULL); }
-    break;
-
-  case 91:
+break;
+case 90:
 #line 371 "ldgram.y"
-    { lang_add_input_file((yyvsp[0].name),lang_input_file_is_l_enum,
+{ lang_add_input_file(yyvsp[0].name,lang_input_file_is_l_enum,
 				 (char *)NULL); }
-    break;
-
-  case 92:
+break;
+case 91:
 #line 374 "ldgram.y"
-    { (yyval.integer) = as_needed; as_needed = TRUE; }
-    break;
-
-  case 93:
+{ yyval.integer = as_needed; as_needed = TRUE; }
+break;
+case 92:
 #line 376 "ldgram.y"
-    { as_needed = (yyvsp[-2].integer); }
-    break;
-
-  case 94:
+{ as_needed = yyvsp[-2].integer; }
+break;
+case 93:
 #line 378 "ldgram.y"
-    { (yyval.integer) = as_needed; as_needed = TRUE; }
-    break;
-
-  case 95:
+{ yyval.integer = as_needed; as_needed = TRUE; }
+break;
+case 94:
 #line 380 "ldgram.y"
-    { as_needed = (yyvsp[-2].integer); }
-    break;
-
-  case 96:
+{ as_needed = yyvsp[-2].integer; }
+break;
+case 95:
 #line 382 "ldgram.y"
-    { (yyval.integer) = as_needed; as_needed = TRUE; }
-    break;
-
-  case 97:
+{ yyval.integer = as_needed; as_needed = TRUE; }
+break;
+case 96:
 #line 384 "ldgram.y"
-    { as_needed = (yyvsp[-2].integer); }
-    break;
-
-  case 102:
+{ as_needed = yyvsp[-2].integer; }
+break;
+case 101:
 #line 399 "ldgram.y"
-    { lang_add_entry ((yyvsp[-1].name), FALSE); }
-    break;
-
-  case 104:
+{ lang_add_entry (yyvsp[-1].name, FALSE); }
+break;
+case 103:
 #line 401 "ldgram.y"
-    {ldlex_expression ();}
-    break;
-
-  case 105:
+{ldlex_expression ();}
+break;
+case 104:
 #line 402 "ldgram.y"
-    { ldlex_popstate ();
-		  lang_add_assignment (exp_assert ((yyvsp[-3].etree), (yyvsp[-1].name))); }
-    break;
-
-  case 106:
+{ ldlex_popstate ();
+		  lang_add_assignment (exp_assert (yyvsp[-3].etree, yyvsp[-1].name)); }
+break;
+case 105:
 #line 410 "ldgram.y"
-    {
-			  (yyval.cname) = (yyvsp[0].name);
+{
+			  yyval.cname = yyvsp[0].name;
 			}
-    break;
-
-  case 107:
+break;
+case 106:
 #line 414 "ldgram.y"
-    {
-			  (yyval.cname) = "*";
+{
+			  yyval.cname = "*";
 			}
-    break;
-
-  case 108:
+break;
+case 107:
 #line 418 "ldgram.y"
-    {
-			  (yyval.cname) = "?";
+{
+			  yyval.cname = "?";
 			}
-    break;
-
-  case 109:
+break;
+case 108:
 #line 425 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[0].cname);
-			  (yyval.wildcard).sorted = none;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[0].cname;
+			  yyval.wildcard.sorted = none;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 110:
+break;
+case 109:
 #line 431 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[0].cname);
-			  (yyval.wildcard).sorted = none;
-			  (yyval.wildcard).exclude_name_list = (yyvsp[-2].name_list);
+{
+			  yyval.wildcard.name = yyvsp[0].cname;
+			  yyval.wildcard.sorted = none;
+			  yyval.wildcard.exclude_name_list = yyvsp[-2].name_list;
 			}
-    break;
-
-  case 111:
+break;
+case 110:
 #line 437 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-1].cname);
-			  (yyval.wildcard).sorted = by_name;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-1].cname;
+			  yyval.wildcard.sorted = by_name;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 112:
+break;
+case 111:
 #line 443 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-1].cname);
-			  (yyval.wildcard).sorted = by_alignment;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-1].cname;
+			  yyval.wildcard.sorted = by_alignment;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 113:
+break;
+case 112:
 #line 449 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-2].cname);
-			  (yyval.wildcard).sorted = by_name_alignment;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-2].cname;
+			  yyval.wildcard.sorted = by_name_alignment;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 114:
+break;
+case 113:
 #line 455 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-2].cname);
-			  (yyval.wildcard).sorted = by_name;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-2].cname;
+			  yyval.wildcard.sorted = by_name;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 115:
+break;
+case 114:
 #line 461 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-2].cname);
-			  (yyval.wildcard).sorted = by_alignment_name;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-2].cname;
+			  yyval.wildcard.sorted = by_alignment_name;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 116:
+break;
+case 115:
 #line 467 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-2].cname);
-			  (yyval.wildcard).sorted = by_alignment;
-			  (yyval.wildcard).exclude_name_list = NULL;
+{
+			  yyval.wildcard.name = yyvsp[-2].cname;
+			  yyval.wildcard.sorted = by_alignment;
+			  yyval.wildcard.exclude_name_list = NULL;
 			}
-    break;
-
-  case 117:
+break;
+case 116:
 #line 473 "ldgram.y"
-    {
-			  (yyval.wildcard).name = (yyvsp[-1].cname);
-			  (yyval.wildcard).sorted = by_name;
-			  (yyval.wildcard).exclude_name_list = (yyvsp[-3].name_list);
+{
+			  yyval.wildcard.name = yyvsp[-1].cname;
+			  yyval.wildcard.sorted = by_name;
+			  yyval.wildcard.exclude_name_list = yyvsp[-3].name_list;
 			}
-    break;
-
-  case 118:
+break;
+case 117:
 #line 482 "ldgram.y"
-    {
+{
 			  struct name_list *tmp;
 			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = (yyvsp[0].cname);
-			  tmp->next = (yyvsp[-1].name_list);
-			  (yyval.name_list) = tmp;
+			  tmp->name = yyvsp[0].cname;
+			  tmp->next = yyvsp[-1].name_list;
+			  yyval.name_list = tmp;
 			}
-    break;
-
-  case 119:
+break;
+case 118:
 #line 491 "ldgram.y"
-    {
+{
 			  struct name_list *tmp;
 			  tmp = (struct name_list *) xmalloc (sizeof *tmp);
-			  tmp->name = (yyvsp[0].cname);
+			  tmp->name = yyvsp[0].cname;
 			  tmp->next = NULL;
-			  (yyval.name_list) = tmp;
+			  yyval.name_list = tmp;
 			}
-    break;
-
-  case 120:
+break;
+case 119:
 #line 502 "ldgram.y"
-    {
+{
 			  struct wildcard_list *tmp;
 			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
-			  tmp->next = (yyvsp[-2].wildcard_list);
-			  tmp->spec = (yyvsp[0].wildcard);
-			  (yyval.wildcard_list) = tmp;
+			  tmp->next = yyvsp[-2].wildcard_list;
+			  tmp->spec = yyvsp[0].wildcard;
+			  yyval.wildcard_list = tmp;
 			}
-    break;
-
-  case 121:
+break;
+case 120:
 #line 511 "ldgram.y"
-    {
+{
 			  struct wildcard_list *tmp;
 			  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
 			  tmp->next = NULL;
-			  tmp->spec = (yyvsp[0].wildcard);
-			  (yyval.wildcard_list) = tmp;
+			  tmp->spec = yyvsp[0].wildcard;
+			  yyval.wildcard_list = tmp;
 			}
-    break;
-
-  case 122:
+break;
+case 121:
 #line 522 "ldgram.y"
-    {
+{
 			  struct wildcard_spec tmp;
-			  tmp.name = (yyvsp[0].name);
+			  tmp.name = yyvsp[0].name;
 			  tmp.exclude_name_list = NULL;
 			  tmp.sorted = none;
 			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
 			}
-    break;
-
-  case 123:
+break;
+case 122:
 #line 530 "ldgram.y"
-    {
-			  lang_add_wild (NULL, (yyvsp[-1].wildcard_list), ldgram_had_keep);
+{
+			  lang_add_wild (NULL, yyvsp[-1].wildcard_list, ldgram_had_keep);
 			}
-    break;
-
-  case 124:
+break;
+case 123:
 #line 534 "ldgram.y"
-    {
-			  lang_add_wild (&(yyvsp[-3].wildcard), (yyvsp[-1].wildcard_list), ldgram_had_keep);
+{
+			  lang_add_wild (&yyvsp[-3].wildcard, yyvsp[-1].wildcard_list, ldgram_had_keep);
 			}
-    break;
-
-  case 126:
+break;
+case 125:
 #line 542 "ldgram.y"
-    { ldgram_had_keep = TRUE; }
-    break;
-
-  case 127:
+{ ldgram_had_keep = TRUE; }
+break;
+case 126:
 #line 544 "ldgram.y"
-    { ldgram_had_keep = FALSE; }
-    break;
-
-  case 129:
+{ ldgram_had_keep = FALSE; }
+break;
+case 128:
 #line 550 "ldgram.y"
-    {
+{
  		lang_add_attribute(lang_object_symbols_statement_enum);
 	      	}
-    break;
-
-  case 131:
+break;
+case 130:
 #line 555 "ldgram.y"
-    {
+{
 
 		  lang_add_attribute(lang_constructors_statement_enum);
 		}
-    break;
-
-  case 132:
+break;
+case 131:
 #line 560 "ldgram.y"
-    {
+{
 		  constructors_sorted = TRUE;
 		  lang_add_attribute (lang_constructors_statement_enum);
 		}
-    break;
-
-  case 134:
+break;
+case 133:
 #line 566 "ldgram.y"
-    {
-			  lang_add_data ((int) (yyvsp[-3].integer), (yyvsp[-1].etree));
+{
+			  lang_add_data ((int) yyvsp[-3].integer, yyvsp[-1].etree);
 			}
-    break;
-
-  case 135:
+break;
+case 134:
 #line 571 "ldgram.y"
-    {
-			  lang_add_fill ((yyvsp[-1].fill));
+{
+			  lang_add_fill (yyvsp[-1].fill);
 			}
-    break;
-
-  case 140:
+break;
+case 139:
 #line 588 "ldgram.y"
-    { (yyval.integer) = (yyvsp[0].token); }
-    break;
-
-  case 141:
+{ yyval.integer = yyvsp[0].token; }
+break;
+case 140:
 #line 590 "ldgram.y"
-    { (yyval.integer) = (yyvsp[0].token); }
-    break;
-
-  case 142:
+{ yyval.integer = yyvsp[0].token; }
+break;
+case 141:
 #line 592 "ldgram.y"
-    { (yyval.integer) = (yyvsp[0].token); }
-    break;
-
-  case 143:
+{ yyval.integer = yyvsp[0].token; }
+break;
+case 142:
 #line 594 "ldgram.y"
-    { (yyval.integer) = (yyvsp[0].token); }
-    break;
-
-  case 144:
+{ yyval.integer = yyvsp[0].token; }
+break;
+case 143:
 #line 596 "ldgram.y"
-    { (yyval.integer) = (yyvsp[0].token); }
-    break;
-
-  case 145:
+{ yyval.integer = yyvsp[0].token; }
+break;
+case 144:
 #line 601 "ldgram.y"
-    {
-		  (yyval.fill) = exp_get_fill ((yyvsp[0].etree), 0, "fill value");
+{
+		  yyval.fill = exp_get_fill (yyvsp[0].etree, 0, "fill value");
 		}
-    break;
-
-  case 146:
+break;
+case 145:
 #line 608 "ldgram.y"
-    { (yyval.fill) = (yyvsp[0].fill); }
-    break;
-
-  case 147:
+{ yyval.fill = yyvsp[0].fill; }
+break;
+case 146:
 #line 609 "ldgram.y"
-    { (yyval.fill) = (fill_type *) 0; }
-    break;
-
-  case 148:
+{ yyval.fill = (fill_type *) 0; }
+break;
+case 147:
 #line 614 "ldgram.y"
-    { (yyval.token) = '+'; }
-    break;
-
-  case 149:
+{ yyval.token = '+'; }
+break;
+case 148:
 #line 616 "ldgram.y"
-    { (yyval.token) = '-'; }
-    break;
-
-  case 150:
+{ yyval.token = '-'; }
+break;
+case 149:
 #line 618 "ldgram.y"
-    { (yyval.token) = '*'; }
-    break;
-
-  case 151:
+{ yyval.token = '*'; }
+break;
+case 150:
 #line 620 "ldgram.y"
-    { (yyval.token) = '/'; }
-    break;
-
-  case 152:
+{ yyval.token = '/'; }
+break;
+case 151:
 #line 622 "ldgram.y"
-    { (yyval.token) = LSHIFT; }
-    break;
-
-  case 153:
+{ yyval.token = LSHIFT; }
+break;
+case 152:
 #line 624 "ldgram.y"
-    { (yyval.token) = RSHIFT; }
-    break;
-
-  case 154:
+{ yyval.token = RSHIFT; }
+break;
+case 153:
 #line 626 "ldgram.y"
-    { (yyval.token) = '&'; }
-    break;
-
-  case 155:
+{ yyval.token = '&'; }
+break;
+case 154:
 #line 628 "ldgram.y"
-    { (yyval.token) = '|'; }
-    break;
-
-  case 158:
+{ yyval.token = '|'; }
+break;
+case 157:
 #line 638 "ldgram.y"
-    {
-		  lang_add_assignment (exp_assop ((yyvsp[-1].token), (yyvsp[-2].name), (yyvsp[0].etree)));
+{
+		  lang_add_assignment (exp_assop (yyvsp[-1].token, yyvsp[-2].name, yyvsp[0].etree));
 		}
-    break;
-
-  case 159:
+break;
+case 158:
 #line 642 "ldgram.y"
-    {
-		  lang_add_assignment (exp_assop ('=', (yyvsp[-2].name),
-						  exp_binop ((yyvsp[-1].token),
+{
+		  lang_add_assignment (exp_assop ('=', yyvsp[-2].name,
+						  exp_binop (yyvsp[-1].token,
 							     exp_nameop (NAME,
-									 (yyvsp[-2].name)),
-							     (yyvsp[0].etree))));
-		}
-    break;
-
-  case 160:
+									 yyvsp[-2].name),
+							     yyvsp[0].etree)));
+		}
+break;
+case 159:
 #line 650 "ldgram.y"
-    {
-		  lang_add_assignment (exp_provide ((yyvsp[-3].name), (yyvsp[-1].etree), FALSE));
+{
+		  lang_add_assignment (exp_provide (yyvsp[-3].name, yyvsp[-1].etree, FALSE));
 		}
-    break;
-
-  case 161:
+break;
+case 160:
 #line 654 "ldgram.y"
-    {
-		  lang_add_assignment (exp_provide ((yyvsp[-3].name), (yyvsp[-1].etree), TRUE));
+{
+		  lang_add_assignment (exp_provide (yyvsp[-3].name, yyvsp[-1].etree, TRUE));
 		}
-    break;
-
-  case 168:
+break;
+case 167:
 #line 676 "ldgram.y"
-    { region = lang_memory_region_lookup ((yyvsp[0].name), TRUE); }
-    break;
-
-  case 169:
+{ region = lang_memory_region_lookup (yyvsp[0].name, TRUE); }
+break;
+case 168:
 #line 679 "ldgram.y"
-    {}
-    break;
-
-  case 170:
+{}
+break;
+case 169:
 #line 684 "ldgram.y"
-    {
-		  region->origin = exp_get_vma ((yyvsp[0].etree), 0, "origin");
+{
+		  region->origin = exp_get_vma (yyvsp[0].etree, 0, "origin");
 		  region->current = region->origin;
 		}
-    break;
-
-  case 171:
+break;
+case 170:
 #line 692 "ldgram.y"
-    {
-		  region->length = exp_get_vma ((yyvsp[0].etree), -1, "length");
+{
+		  region->length = exp_get_vma (yyvsp[0].etree, -1, "length");
 		}
-    break;
-
-  case 172:
+break;
+case 171:
 #line 699 "ldgram.y"
-    { /* dummy action to avoid bison 1.25 error message */ }
-    break;
-
-  case 176:
+{ /* dummy action to avoid bison 1.25 error message */ }
+break;
+case 175:
 #line 710 "ldgram.y"
-    { lang_set_flags (region, (yyvsp[0].name), 0); }
-    break;
-
-  case 177:
+{ lang_set_flags (region, yyvsp[0].name, 0); }
+break;
+case 176:
 #line 712 "ldgram.y"
-    { lang_set_flags (region, (yyvsp[0].name), 1); }
-    break;
-
-  case 178:
+{ lang_set_flags (region, yyvsp[0].name, 1); }
+break;
+case 177:
 #line 717 "ldgram.y"
-    { lang_startup((yyvsp[-1].name)); }
-    break;
-
-  case 180:
+{ lang_startup(yyvsp[-1].name); }
+break;
+case 179:
 #line 723 "ldgram.y"
-    { ldemul_hll((char *)NULL); }
-    break;
-
-  case 181:
+{ ldemul_hll((char *)NULL); }
+break;
+case 180:
 #line 728 "ldgram.y"
-    { ldemul_hll((yyvsp[0].name)); }
-    break;
-
-  case 182:
+{ ldemul_hll(yyvsp[0].name); }
+break;
+case 181:
 #line 730 "ldgram.y"
-    { ldemul_hll((yyvsp[0].name)); }
-    break;
-
-  case 184:
+{ ldemul_hll(yyvsp[0].name); }
+break;
+case 183:
 #line 738 "ldgram.y"
-    { ldemul_syslib((yyvsp[0].name)); }
-    break;
-
-  case 186:
+{ ldemul_syslib(yyvsp[0].name); }
+break;
+case 185:
 #line 744 "ldgram.y"
-    { lang_float(TRUE); }
-    break;
-
-  case 187:
+{ lang_float(TRUE); }
+break;
+case 186:
 #line 746 "ldgram.y"
-    { lang_float(FALSE); }
-    break;
-
-  case 188:
+{ lang_float(FALSE); }
+break;
+case 187:
 #line 751 "ldgram.y"
-    {
-		  (yyval.nocrossref) = NULL;
+{
+		  yyval.nocrossref = NULL;
 		}
-    break;
-
-  case 189:
+break;
+case 188:
 #line 755 "ldgram.y"
-    {
+{
 		  struct lang_nocrossref *n;
 
 		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = (yyvsp[-1].name);
-		  n->next = (yyvsp[0].nocrossref);
-		  (yyval.nocrossref) = n;
+		  n->name = yyvsp[-1].name;
+		  n->next = yyvsp[0].nocrossref;
+		  yyval.nocrossref = n;
 		}
-    break;
-
-  case 190:
+break;
+case 189:
 #line 764 "ldgram.y"
-    {
+{
 		  struct lang_nocrossref *n;
 
 		  n = (struct lang_nocrossref *) xmalloc (sizeof *n);
-		  n->name = (yyvsp[-2].name);
-		  n->next = (yyvsp[0].nocrossref);
-		  (yyval.nocrossref) = n;
+		  n->name = yyvsp[-2].name;
+		  n->next = yyvsp[0].nocrossref;
+		  yyval.nocrossref = n;
 		}
-    break;
-
-  case 191:
+break;
+case 190:
 #line 774 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 192:
+{ ldlex_expression (); }
+break;
+case 191:
 #line 776 "ldgram.y"
-    { ldlex_popstate (); (yyval.etree)=(yyvsp[0].etree);}
-    break;
-
-  case 193:
+{ ldlex_popstate (); yyval.etree=yyvsp[0].etree;}
+break;
+case 192:
 #line 781 "ldgram.y"
-    { (yyval.etree) = exp_unop ('-', (yyvsp[0].etree)); }
-    break;
-
-  case 194:
+{ yyval.etree = exp_unop ('-', yyvsp[0].etree); }
+break;
+case 193:
 #line 783 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-1].etree); }
-    break;
-
-  case 195:
+{ yyval.etree = yyvsp[-1].etree; }
+break;
+case 194:
 #line 785 "ldgram.y"
-    { (yyval.etree) = exp_unop ((int) (yyvsp[-3].integer),(yyvsp[-1].etree)); }
-    break;
-
-  case 196:
+{ yyval.etree = exp_unop ((int) yyvsp[-3].integer,yyvsp[-1].etree); }
+break;
+case 195:
 #line 787 "ldgram.y"
-    { (yyval.etree) = exp_unop ('!', (yyvsp[0].etree)); }
-    break;
-
-  case 197:
+{ yyval.etree = exp_unop ('!', yyvsp[0].etree); }
+break;
+case 196:
 #line 789 "ldgram.y"
-    { (yyval.etree) = (yyvsp[0].etree); }
-    break;
-
-  case 198:
+{ yyval.etree = yyvsp[0].etree; }
+break;
+case 197:
 #line 791 "ldgram.y"
-    { (yyval.etree) = exp_unop ('~', (yyvsp[0].etree));}
-    break;
-
-  case 199:
+{ yyval.etree = exp_unop ('~', yyvsp[0].etree);}
+break;
+case 198:
 #line 794 "ldgram.y"
-    { (yyval.etree) = exp_binop ('*', (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 200:
+{ yyval.etree = exp_binop ('*', yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 199:
 #line 796 "ldgram.y"
-    { (yyval.etree) = exp_binop ('/', (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 201:
+{ yyval.etree = exp_binop ('/', yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 200:
 #line 798 "ldgram.y"
-    { (yyval.etree) = exp_binop ('%', (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 202:
+{ yyval.etree = exp_binop ('%', yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 201:
 #line 800 "ldgram.y"
-    { (yyval.etree) = exp_binop ('+', (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 203:
+{ yyval.etree = exp_binop ('+', yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 202:
 #line 802 "ldgram.y"
-    { (yyval.etree) = exp_binop ('-' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 204:
+{ yyval.etree = exp_binop ('-' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 203:
 #line 804 "ldgram.y"
-    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 205:
+{ yyval.etree = exp_binop (LSHIFT , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 204:
 #line 806 "ldgram.y"
-    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 206:
+{ yyval.etree = exp_binop (RSHIFT , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 205:
 #line 808 "ldgram.y"
-    { (yyval.etree) = exp_binop (EQ , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 207:
+{ yyval.etree = exp_binop (EQ , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 206:
 #line 810 "ldgram.y"
-    { (yyval.etree) = exp_binop (NE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 208:
+{ yyval.etree = exp_binop (NE , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 207:
 #line 812 "ldgram.y"
-    { (yyval.etree) = exp_binop (LE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 209:
+{ yyval.etree = exp_binop (LE , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 208:
 #line 814 "ldgram.y"
-    { (yyval.etree) = exp_binop (GE , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 210:
+{ yyval.etree = exp_binop (GE , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 209:
 #line 816 "ldgram.y"
-    { (yyval.etree) = exp_binop ('<' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 211:
+{ yyval.etree = exp_binop ('<' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 210:
 #line 818 "ldgram.y"
-    { (yyval.etree) = exp_binop ('>' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 212:
+{ yyval.etree = exp_binop ('>' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 211:
 #line 820 "ldgram.y"
-    { (yyval.etree) = exp_binop ('&' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 213:
+{ yyval.etree = exp_binop ('&' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 212:
 #line 822 "ldgram.y"
-    { (yyval.etree) = exp_binop ('^' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 214:
+{ yyval.etree = exp_binop ('^' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 213:
 #line 824 "ldgram.y"
-    { (yyval.etree) = exp_binop ('|' , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 215:
+{ yyval.etree = exp_binop ('|' , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 214:
 #line 826 "ldgram.y"
-    { (yyval.etree) = exp_trinop ('?' , (yyvsp[-4].etree), (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 216:
+{ yyval.etree = exp_trinop ('?' , yyvsp[-4].etree, yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 215:
 #line 828 "ldgram.y"
-    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 217:
+{ yyval.etree = exp_binop (ANDAND , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 216:
 #line 830 "ldgram.y"
-    { (yyval.etree) = exp_binop (OROR , (yyvsp[-2].etree), (yyvsp[0].etree)); }
-    break;
-
-  case 218:
+{ yyval.etree = exp_binop (OROR , yyvsp[-2].etree, yyvsp[0].etree); }
+break;
+case 217:
 #line 832 "ldgram.y"
-    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[-1].name)); }
-    break;
-
-  case 219:
+{ yyval.etree = exp_nameop (DEFINED, yyvsp[-1].name); }
+break;
+case 218:
 #line 834 "ldgram.y"
-    { (yyval.etree) = exp_bigintop ((yyvsp[0].bigint).integer, (yyvsp[0].bigint).str); }
-    break;
-
-  case 220:
+{ yyval.etree = exp_bigintop (yyvsp[0].bigint.integer, yyvsp[0].bigint.str); }
+break;
+case 219:
 #line 836 "ldgram.y"
-    { (yyval.etree) = exp_nameop (SIZEOF_HEADERS,0); }
-    break;
-
-  case 221:
+{ yyval.etree = exp_nameop (SIZEOF_HEADERS,0); }
+break;
+case 220:
 #line 839 "ldgram.y"
-    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[-1].name)); }
-    break;
-
-  case 222:
+{ yyval.etree = exp_nameop (SIZEOF,yyvsp[-1].name); }
+break;
+case 221:
 #line 841 "ldgram.y"
-    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[-1].name)); }
-    break;
-
-  case 223:
+{ yyval.etree = exp_nameop (ADDR,yyvsp[-1].name); }
+break;
+case 222:
 #line 843 "ldgram.y"
-    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[-1].name)); }
-    break;
-
-  case 224:
+{ yyval.etree = exp_nameop (LOADADDR,yyvsp[-1].name); }
+break;
+case 223:
 #line 845 "ldgram.y"
-    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[-1].etree)); }
-    break;
-
-  case 225:
+{ yyval.etree = exp_unop (ABSOLUTE, yyvsp[-1].etree); }
+break;
+case 224:
 #line 847 "ldgram.y"
-    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[-1].etree)); }
-    break;
-
-  case 226:
+{ yyval.etree = exp_unop (ALIGN_K,yyvsp[-1].etree); }
+break;
+case 225:
 #line 849 "ldgram.y"
-    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[-3].etree),(yyvsp[-1].etree)); }
-    break;
-
-  case 227:
+{ yyval.etree = exp_binop (ALIGN_K,yyvsp[-3].etree,yyvsp[-1].etree); }
+break;
+case 226:
 #line 851 "ldgram.y"
-    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[-3].etree), (yyvsp[-1].etree)); }
-    break;
-
-  case 228:
+{ yyval.etree = exp_binop (DATA_SEGMENT_ALIGN, yyvsp[-3].etree, yyvsp[-1].etree); }
+break;
+case 227:
 #line 853 "ldgram.y"
-    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[-1].etree), (yyvsp[-3].etree)); }
-    break;
-
-  case 229:
+{ yyval.etree = exp_binop (DATA_SEGMENT_RELRO_END, yyvsp[-1].etree, yyvsp[-3].etree); }
+break;
+case 228:
 #line 855 "ldgram.y"
-    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[-1].etree)); }
-    break;
-
-  case 230:
+{ yyval.etree = exp_unop (DATA_SEGMENT_END, yyvsp[-1].etree); }
+break;
+case 229:
 #line 857 "ldgram.y"
-    { /* The operands to the expression node are
+{ /* The operands to the expression node are
 			     placed in the opposite order from the way
 			     in which they appear in the script as
 			     that allows us to reuse more code in
 			     fold_binary.  */
-			  (yyval.etree) = exp_binop (SEGMENT_START,
-					  (yyvsp[-1].etree),
-					  exp_nameop (NAME, (yyvsp[-3].name))); }
-    break;
-
-  case 231:
+			  yyval.etree = exp_binop (SEGMENT_START,
+					  yyvsp[-1].etree,
+					  exp_nameop (NAME, yyvsp[-3].name)); }
+break;
+case 230:
 #line 866 "ldgram.y"
-    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[-1].etree)); }
-    break;
-
-  case 232:
+{ yyval.etree = exp_unop (ALIGN_K,yyvsp[-1].etree); }
+break;
+case 231:
 #line 868 "ldgram.y"
-    { (yyval.etree) = exp_nameop (NAME,(yyvsp[0].name)); }
-    break;
-
-  case 233:
+{ yyval.etree = exp_nameop (NAME,yyvsp[0].name); }
+break;
+case 232:
 #line 870 "ldgram.y"
-    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[-3].etree), (yyvsp[-1].etree) ); }
-    break;
-
-  case 234:
+{ yyval.etree = exp_binop (MAX_K, yyvsp[-3].etree, yyvsp[-1].etree ); }
+break;
+case 233:
 #line 872 "ldgram.y"
-    { (yyval.etree) = exp_binop (MIN_K, (yyvsp[-3].etree), (yyvsp[-1].etree) ); }
-    break;
-
-  case 235:
+{ yyval.etree = exp_binop (MIN_K, yyvsp[-3].etree, yyvsp[-1].etree ); }
+break;
+case 234:
 #line 874 "ldgram.y"
-    { (yyval.etree) = exp_assert ((yyvsp[-3].etree), (yyvsp[-1].name)); }
-    break;
-
-  case 236:
+{ yyval.etree = exp_assert (yyvsp[-3].etree, yyvsp[-1].name); }
+break;
+case 235:
 #line 876 "ldgram.y"
-    { (yyval.etree) = exp_nameop (ORIGIN, (yyvsp[-1].name)); }
-    break;
-
-  case 237:
+{ yyval.etree = exp_nameop (ORIGIN, yyvsp[-1].name); }
+break;
+case 236:
 #line 878 "ldgram.y"
-    { (yyval.etree) = exp_nameop (LENGTH, (yyvsp[-1].name)); }
-    break;
-
-  case 238:
+{ yyval.etree = exp_nameop (LENGTH, yyvsp[-1].name); }
+break;
+case 237:
 #line 883 "ldgram.y"
-    { (yyval.name) = (yyvsp[0].name); }
-    break;
-
-  case 239:
+{ yyval.name = yyvsp[0].name; }
+break;
+case 238:
 #line 884 "ldgram.y"
-    { (yyval.name) = 0; }
-    break;
-
-  case 240:
+{ yyval.name = 0; }
+break;
+case 239:
 #line 888 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-1].etree); }
-    break;
-
-  case 241:
+{ yyval.etree = yyvsp[-1].etree; }
+break;
+case 240:
 #line 889 "ldgram.y"
-    { (yyval.etree) = 0; }
-    break;
-
-  case 242:
+{ yyval.etree = 0; }
+break;
+case 241:
 #line 893 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-1].etree); }
-    break;
-
-  case 243:
+{ yyval.etree = yyvsp[-1].etree; }
+break;
+case 242:
 #line 894 "ldgram.y"
-    { (yyval.etree) = 0; }
-    break;
-
-  case 244:
+{ yyval.etree = 0; }
+break;
+case 243:
 #line 898 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-1].etree); }
-    break;
-
-  case 245:
+{ yyval.etree = yyvsp[-1].etree; }
+break;
+case 244:
 #line 899 "ldgram.y"
-    { (yyval.etree) = 0; }
-    break;
-
-  case 246:
+{ yyval.etree = 0; }
+break;
+case 245:
 #line 903 "ldgram.y"
-    { (yyval.token) = ONLY_IF_RO; }
-    break;
-
-  case 247:
+{ yyval.token = ONLY_IF_RO; }
+break;
+case 246:
 #line 904 "ldgram.y"
-    { (yyval.token) = ONLY_IF_RW; }
-    break;
-
-  case 248:
+{ yyval.token = ONLY_IF_RW; }
+break;
+case 247:
 #line 905 "ldgram.y"
-    { (yyval.token) = SPECIAL; }
-    break;
-
-  case 249:
+{ yyval.token = SPECIAL; }
+break;
+case 248:
 #line 906 "ldgram.y"
-    { (yyval.token) = 0; }
-    break;
-
-  case 250:
+{ yyval.token = 0; }
+break;
+case 249:
 #line 909 "ldgram.y"
-    { ldlex_expression(); }
-    break;
-
-  case 251:
+{ ldlex_expression(); }
+break;
+case 250:
 #line 913 "ldgram.y"
-    { ldlex_popstate (); ldlex_script (); }
-    break;
-
-  case 252:
+{ ldlex_popstate (); ldlex_script (); }
+break;
+case 251:
 #line 916 "ldgram.y"
-    {
-			  lang_enter_output_section_statement((yyvsp[-8].name), (yyvsp[-6].etree),
+{
+			  lang_enter_output_section_statement(yyvsp[-8].name, yyvsp[-6].etree,
 							      sectype,
-							      (yyvsp[-4].etree), (yyvsp[-3].etree), (yyvsp[-5].etree), (yyvsp[-1].token));
+							      yyvsp[-4].etree, yyvsp[-3].etree, yyvsp[-5].etree, yyvsp[-1].token);
 			}
-    break;
-
-  case 253:
+break;
+case 252:
 #line 922 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 254:
+{ ldlex_popstate (); ldlex_expression (); }
+break;
+case 253:
 #line 924 "ldgram.y"
-    {
+{
 		  ldlex_popstate ();
-		  lang_leave_output_section_statement ((yyvsp[0].fill), (yyvsp[-3].name), (yyvsp[-1].section_phdr), (yyvsp[-2].name));
+		  lang_leave_output_section_statement (yyvsp[0].fill, yyvsp[-3].name, yyvsp[-1].section_phdr, yyvsp[-2].name);
 		}
-    break;
-
-  case 255:
+break;
+case 254:
 #line 929 "ldgram.y"
-    {}
-    break;
-
-  case 256:
+{}
+break;
+case 255:
 #line 931 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 257:
+{ ldlex_expression (); }
+break;
+case 256:
 #line 933 "ldgram.y"
-    { ldlex_popstate (); ldlex_script (); }
-    break;
-
-  case 258:
+{ ldlex_popstate (); ldlex_script (); }
+break;
+case 257:
 #line 935 "ldgram.y"
-    {
-			  lang_enter_overlay ((yyvsp[-5].etree), (yyvsp[-2].etree));
+{
+			  lang_enter_overlay (yyvsp[-5].etree, yyvsp[-2].etree);
 			}
-    break;
-
-  case 259:
+break;
+case 258:
 #line 940 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 260:
+{ ldlex_popstate (); ldlex_expression (); }
+break;
+case 259:
 #line 942 "ldgram.y"
-    {
+{
 			  ldlex_popstate ();
-			  lang_leave_overlay ((yyvsp[-11].etree), (int) (yyvsp[-12].integer),
-					      (yyvsp[0].fill), (yyvsp[-3].name), (yyvsp[-1].section_phdr), (yyvsp[-2].name));
+			  lang_leave_overlay (yyvsp[-11].etree, (int) yyvsp[-12].integer,
+					      yyvsp[0].fill, yyvsp[-3].name, yyvsp[-1].section_phdr, yyvsp[-2].name);
 			}
-    break;
-
-  case 262:
+break;
+case 261:
 #line 952 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 263:
+{ ldlex_expression (); }
+break;
+case 262:
 #line 954 "ldgram.y"
-    {
+{
 		  ldlex_popstate ();
-		  lang_add_assignment (exp_assop ('=', ".", (yyvsp[0].etree)));
+		  lang_add_assignment (exp_assop ('=', ".", yyvsp[0].etree));
 		}
-    break;
-
-  case 265:
+break;
+case 264:
 #line 962 "ldgram.y"
-    { sectype = noload_section; }
-    break;
-
-  case 266:
+{ sectype = noload_section; }
+break;
+case 265:
 #line 963 "ldgram.y"
-    { sectype = dsect_section; }
-    break;
-
-  case 267:
+{ sectype = dsect_section; }
+break;
+case 266:
 #line 964 "ldgram.y"
-    { sectype = copy_section; }
-    break;
-
-  case 268:
+{ sectype = copy_section; }
+break;
+case 267:
 #line 965 "ldgram.y"
-    { sectype = info_section; }
-    break;
-
-  case 269:
+{ sectype = info_section; }
+break;
+case 268:
 #line 966 "ldgram.y"
-    { sectype = overlay_section; }
-    break;
-
-  case 271:
+{ sectype = overlay_section; }
+break;
+case 270:
 #line 971 "ldgram.y"
-    { sectype = normal_section; }
-    break;
-
-  case 272:
+{ sectype = normal_section; }
+break;
+case 271:
 #line 972 "ldgram.y"
-    { sectype = normal_section; }
-    break;
-
-  case 273:
+{ sectype = normal_section; }
+break;
+case 272:
 #line 976 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-2].etree); }
-    break;
-
-  case 274:
+{ yyval.etree = yyvsp[-2].etree; }
+break;
+case 273:
 #line 977 "ldgram.y"
-    { (yyval.etree) = (etree_type *)NULL;  }
-    break;
-
-  case 275:
+{ yyval.etree = (etree_type *)NULL;  }
+break;
+case 274:
 #line 982 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-3].etree); }
-    break;
-
-  case 276:
+{ yyval.etree = yyvsp[-3].etree; }
+break;
+case 275:
 #line 984 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-7].etree); }
-    break;
-
-  case 277:
+{ yyval.etree = yyvsp[-7].etree; }
+break;
+case 276:
 #line 988 "ldgram.y"
-    { (yyval.etree) = (yyvsp[-1].etree); }
-    break;
-
-  case 278:
+{ yyval.etree = yyvsp[-1].etree; }
+break;
+case 277:
 #line 989 "ldgram.y"
-    { (yyval.etree) = (etree_type *) NULL;  }
-    break;
-
-  case 279:
+{ yyval.etree = (etree_type *) NULL;  }
+break;
+case 278:
 #line 994 "ldgram.y"
-    { (yyval.integer) = 0; }
-    break;
-
-  case 280:
+{ yyval.integer = 0; }
+break;
+case 279:
 #line 996 "ldgram.y"
-    { (yyval.integer) = 1; }
-    break;
-
-  case 281:
+{ yyval.integer = 1; }
+break;
+case 280:
 #line 1001 "ldgram.y"
-    { (yyval.name) = (yyvsp[0].name); }
-    break;
-
-  case 282:
+{ yyval.name = yyvsp[0].name; }
+break;
+case 281:
 #line 1002 "ldgram.y"
-    { (yyval.name) = DEFAULT_MEMORY_REGION; }
-    break;
-
-  case 283:
+{ yyval.name = DEFAULT_MEMORY_REGION; }
+break;
+case 282:
 #line 1007 "ldgram.y"
-    {
-		  (yyval.section_phdr) = NULL;
+{
+		  yyval.section_phdr = NULL;
 		}
-    break;
-
-  case 284:
+break;
+case 283:
 #line 1011 "ldgram.y"
-    {
+{
 		  struct lang_output_section_phdr_list *n;
 
 		  n = ((struct lang_output_section_phdr_list *)
 		       xmalloc (sizeof *n));
-		  n->name = (yyvsp[0].name);
+		  n->name = yyvsp[0].name;
 		  n->used = FALSE;
-		  n->next = (yyvsp[-2].section_phdr);
-		  (yyval.section_phdr) = n;
+		  n->next = yyvsp[-2].section_phdr;
+		  yyval.section_phdr = n;
 		}
-    break;
-
-  case 286:
+break;
+case 285:
 #line 1027 "ldgram.y"
-    {
+{
 			  ldlex_script ();
-			  lang_enter_overlay_section ((yyvsp[0].name));
+			  lang_enter_overlay_section (yyvsp[0].name);
 			}
-    break;
-
-  case 287:
+break;
+case 286:
 #line 1032 "ldgram.y"
-    { ldlex_popstate (); ldlex_expression (); }
-    break;
-
-  case 288:
+{ ldlex_popstate (); ldlex_expression (); }
+break;
+case 287:
 #line 1034 "ldgram.y"
-    {
+{
 			  ldlex_popstate ();
-			  lang_leave_overlay_section ((yyvsp[0].fill), (yyvsp[-1].section_phdr));
+			  lang_leave_overlay_section (yyvsp[0].fill, yyvsp[-1].section_phdr);
 			}
-    break;
-
-  case 293:
+break;
+case 292:
 #line 1051 "ldgram.y"
-    { ldlex_expression (); }
-    break;
-
-  case 294:
+{ ldlex_expression (); }
+break;
+case 293:
 #line 1052 "ldgram.y"
-    { ldlex_popstate (); }
-    break;
-
-  case 295:
+{ ldlex_popstate (); }
+break;
+case 294:
 #line 1054 "ldgram.y"
-    {
-		  lang_new_phdr ((yyvsp[-5].name), (yyvsp[-3].etree), (yyvsp[-2].phdr).filehdr, (yyvsp[-2].phdr).phdrs, (yyvsp[-2].phdr).at,
-				 (yyvsp[-2].phdr).flags);
+{
+		  lang_new_phdr (yyvsp[-5].name, yyvsp[-3].etree, yyvsp[-2].phdr.filehdr, yyvsp[-2].phdr.phdrs, yyvsp[-2].phdr.at,
+				 yyvsp[-2].phdr.flags);
 		}
-    break;
-
-  case 296:
+break;
+case 295:
 #line 1062 "ldgram.y"
-    {
-		  (yyval.etree) = (yyvsp[0].etree);
+{
+		  yyval.etree = yyvsp[0].etree;
 
-		  if ((yyvsp[0].etree)->type.node_class == etree_name
-		      && (yyvsp[0].etree)->type.node_code == NAME)
+		  if (yyvsp[0].etree->type.node_class == etree_name
+		      && yyvsp[0].etree->type.node_code == NAME)
 		    {
 		      const char *s;
 		      unsigned int i;
@@ -3597,567 +2980,316 @@
 			  "PT_PHDR", "PT_TLS"
 			};
 
-		      s = (yyvsp[0].etree)->name.name;
+		      s = yyvsp[0].etree->name.name;
 		      for (i = 0;
 			   i < sizeof phdr_types / sizeof phdr_types[0];
 			   i++)
 			if (strcmp (s, phdr_types[i]) == 0)
 			  {
-			    (yyval.etree) = exp_intop (i);
+			    yyval.etree = exp_intop (i);
 			    break;
 			  }
 		      if (i == sizeof phdr_types / sizeof phdr_types[0])
 			{
 			  if (strcmp (s, "PT_GNU_EH_FRAME") == 0)
-			    (yyval.etree) = exp_intop (0x6474e550);
+			    yyval.etree = exp_intop (0x6474e550);
 			  else if (strcmp (s, "PT_GNU_STACK") == 0)
-			    (yyval.etree) = exp_intop (0x6474e551);
+			    yyval.etree = exp_intop (0x6474e551);
 			  else
 			    {
 			      einfo (_("\
 %X%P:%S: unknown phdr type `%s' (try integer literal)\n"),
 				     s);
-			      (yyval.etree) = exp_intop (0);
+			      yyval.etree = exp_intop (0);
 			    }
 			}
 		    }
 		}
-    break;
-
-  case 297:
+break;
+case 296:
 #line 1106 "ldgram.y"
-    {
-		  memset (&(yyval.phdr), 0, sizeof (struct phdr_info));
+{
+		  memset (&yyval.phdr, 0, sizeof (struct phdr_info));
 		}
-    break;
-
-  case 298:
+break;
+case 297:
 #line 1110 "ldgram.y"
-    {
-		  (yyval.phdr) = (yyvsp[0].phdr);
-		  if (strcmp ((yyvsp[-2].name), "FILEHDR") == 0 && (yyvsp[-1].etree) == NULL)
-		    (yyval.phdr).filehdr = TRUE;
-		  else if (strcmp ((yyvsp[-2].name), "PHDRS") == 0 && (yyvsp[-1].etree) == NULL)
-		    (yyval.phdr).phdrs = TRUE;
-		  else if (strcmp ((yyvsp[-2].name), "FLAGS") == 0 && (yyvsp[-1].etree) != NULL)
-		    (yyval.phdr).flags = (yyvsp[-1].etree);
+{
+		  yyval.phdr = yyvsp[0].phdr;
+		  if (strcmp (yyvsp[-2].name, "FILEHDR") == 0 && yyvsp[-1].etree == NULL)
+		    yyval.phdr.filehdr = TRUE;
+		  else if (strcmp (yyvsp[-2].name, "PHDRS") == 0 && yyvsp[-1].etree == NULL)
+		    yyval.phdr.phdrs = TRUE;
+		  else if (strcmp (yyvsp[-2].name, "FLAGS") == 0 && yyvsp[-1].etree != NULL)
+		    yyval.phdr.flags = yyvsp[-1].etree;
 		  else
-		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), (yyvsp[-2].name));
+		    einfo (_("%X%P:%S: PHDRS syntax error at `%s'\n"), yyvsp[-2].name);
 		}
-    break;
-
-  case 299:
+break;
+case 298:
 #line 1122 "ldgram.y"
-    {
-		  (yyval.phdr) = (yyvsp[0].phdr);
-		  (yyval.phdr).at = (yyvsp[-2].etree);
+{
+		  yyval.phdr = yyvsp[0].phdr;
+		  yyval.phdr.at = yyvsp[-2].etree;
 		}
-    break;
-
-  case 300:
+break;
+case 299:
 #line 1130 "ldgram.y"
-    {
-		  (yyval.etree) = NULL;
+{
+		  yyval.etree = NULL;
 		}
-    break;
-
-  case 301:
+break;
+case 300:
 #line 1134 "ldgram.y"
-    {
-		  (yyval.etree) = (yyvsp[-1].etree);
+{
+		  yyval.etree = yyvsp[-1].etree;
 		}
-    break;
-
-  case 302:
+break;
+case 301:
 #line 1142 "ldgram.y"
-    {
+{
 		  ldlex_version_file ();
 		  PUSH_ERROR (_("VERSION script"));
 		}
-    break;
-
-  case 303:
+break;
+case 302:
 #line 1147 "ldgram.y"
-    {
+{
 		  ldlex_popstate ();
 		  POP_ERROR ();
 		}
-    break;
-
-  case 304:
+break;
+case 303:
 #line 1156 "ldgram.y"
-    {
+{
 		  ldlex_version_script ();
 		}
-    break;
-
-  case 305:
+break;
+case 304:
 #line 1160 "ldgram.y"
-    {
+{
 		  ldlex_popstate ();
 		}
-    break;
-
-  case 308:
+break;
+case 307:
 #line 1172 "ldgram.y"
-    {
-		  lang_register_vers_node (NULL, (yyvsp[-2].versnode), NULL);
+{
+		  lang_register_vers_node (NULL, yyvsp[-2].versnode, NULL);
 		}
-    break;
-
-  case 309:
+break;
+case 308:
 #line 1176 "ldgram.y"
-    {
-		  lang_register_vers_node ((yyvsp[-4].name), (yyvsp[-2].versnode), NULL);
+{
+		  lang_register_vers_node (yyvsp[-4].name, yyvsp[-2].versnode, NULL);
 		}
-    break;
-
-  case 310:
+break;
+case 309:
 #line 1180 "ldgram.y"
-    {
-		  lang_register_vers_node ((yyvsp[-5].name), (yyvsp[-3].versnode), (yyvsp[-1].deflist));
+{
+		  lang_register_vers_node (yyvsp[-5].name, yyvsp[-3].versnode, yyvsp[-1].deflist);
 		}
-    break;
-
-  case 311:
+break;
+case 310:
 #line 1187 "ldgram.y"
-    {
-		  (yyval.deflist) = lang_add_vers_depend (NULL, (yyvsp[0].name));
+{
+		  yyval.deflist = lang_add_vers_depend (NULL, yyvsp[0].name);
 		}
-    break;
-
-  case 312:
+break;
+case 311:
 #line 1191 "ldgram.y"
-    {
-		  (yyval.deflist) = lang_add_vers_depend ((yyvsp[-1].deflist), (yyvsp[0].name));
+{
+		  yyval.deflist = lang_add_vers_depend (yyvsp[-1].deflist, yyvsp[0].name);
 		}
-    break;
-
-  case 313:
+break;
+case 312:
 #line 1198 "ldgram.y"
-    {
-		  (yyval.versnode) = lang_new_vers_node (NULL, NULL);
+{
+		  yyval.versnode = lang_new_vers_node (NULL, NULL);
 		}
-    break;
-
-  case 314:
+break;
+case 313:
 #line 1202 "ldgram.y"
-    {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-1].versyms), NULL);
+{
+		  yyval.versnode = lang_new_vers_node (yyvsp[-1].versyms, NULL);
 		}
-    break;
-
-  case 315:
+break;
+case 314:
 #line 1206 "ldgram.y"
-    {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-1].versyms), NULL);
+{
+		  yyval.versnode = lang_new_vers_node (yyvsp[-1].versyms, NULL);
 		}
-    break;
-
-  case 316:
+break;
+case 315:
 #line 1210 "ldgram.y"
-    {
-		  (yyval.versnode) = lang_new_vers_node (NULL, (yyvsp[-1].versyms));
+{
+		  yyval.versnode = lang_new_vers_node (NULL, yyvsp[-1].versyms);
 		}
-    break;
-
-  case 317:
+break;
+case 316:
 #line 1214 "ldgram.y"
-    {
-		  (yyval.versnode) = lang_new_vers_node ((yyvsp[-5].versyms), (yyvsp[-1].versyms));
+{
+		  yyval.versnode = lang_new_vers_node (yyvsp[-5].versyms, yyvsp[-1].versyms);
 		}
-    break;
-
-  case 318:
+break;
+case 317:
 #line 1221 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[0].name), ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (NULL, yyvsp[0].name, ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 319:
+break;
+case 318:
 #line 1225 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, (yyvsp[0].name), ldgram_vers_current_lang, TRUE);
+{
+		  yyval.versyms = lang_new_vers_pattern (NULL, yyvsp[0].name, ldgram_vers_current_lang, TRUE);
 		}
-    break;
-
-  case 320:
+break;
+case 319:
 #line 1229 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), (yyvsp[0].name), ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, yyvsp[0].name, ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 321:
+break;
+case 320:
 #line 1233 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), (yyvsp[0].name), ldgram_vers_current_lang, TRUE);
+{
+		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, yyvsp[0].name, ldgram_vers_current_lang, TRUE);
 		}
-    break;
-
-  case 322:
+break;
+case 321:
 #line 1237 "ldgram.y"
-    {
-			  (yyval.name) = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = (yyvsp[-1].name);
+{
+			  yyval.name = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = yyvsp[-1].name;
 			}
-    break;
-
-  case 323:
+break;
+case 322:
 #line 1242 "ldgram.y"
-    {
+{
 			  struct bfd_elf_version_expr *pat;
-			  for (pat = (yyvsp[-2].versyms); pat->next != NULL; pat = pat->next);
-			  pat->next = (yyvsp[-8].versyms);
-			  (yyval.versyms) = (yyvsp[-2].versyms);
-			  ldgram_vers_current_lang = (yyvsp[-3].name);
+			  for (pat = yyvsp[-2].versyms; pat->next != NULL; pat = pat->next);
+			  pat->next = yyvsp[-8].versyms;
+			  yyval.versyms = yyvsp[-2].versyms;
+			  ldgram_vers_current_lang = yyvsp[-3].name;
 			}
-    break;
-
-  case 324:
+break;
+case 323:
 #line 1250 "ldgram.y"
-    {
-			  (yyval.name) = ldgram_vers_current_lang;
-			  ldgram_vers_current_lang = (yyvsp[-1].name);
+{
+			  yyval.name = ldgram_vers_current_lang;
+			  ldgram_vers_current_lang = yyvsp[-1].name;
 			}
-    break;
-
-  case 325:
+break;
+case 324:
 #line 1255 "ldgram.y"
-    {
-			  (yyval.versyms) = (yyvsp[-2].versyms);
-			  ldgram_vers_current_lang = (yyvsp[-3].name);
+{
+			  yyval.versyms = yyvsp[-2].versyms;
+			  ldgram_vers_current_lang = yyvsp[-3].name;
 			}
-    break;
-
-  case 326:
+break;
+case 325:
 #line 1260 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (NULL, "global", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 327:
+break;
+case 326:
 #line 1264 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "global", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "global", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 328:
+break;
+case 327:
 #line 1268 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (NULL, "local", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 329:
+break;
+case 328:
 #line 1272 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "local", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "local", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 330:
+break;
+case 329:
 #line 1276 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (NULL, "extern", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-  case 331:
+break;
+case 330:
 #line 1280 "ldgram.y"
-    {
-		  (yyval.versyms) = lang_new_vers_pattern ((yyvsp[-2].versyms), "extern", ldgram_vers_current_lang, FALSE);
+{
+		  yyval.versyms = lang_new_vers_pattern (yyvsp[-2].versyms, "extern", ldgram_vers_current_lang, FALSE);
 		}
-    break;
-
-
-      default: break;
+break;
+#line 3174 "ldgram.c"
     }
-
-/* Line 1126 of yacc.c.  */
-#line 3882 "ldgram.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
+    yyssp -= yym;
+    yystate = *yyssp;
+    yyvsp -= yym;
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
 	{
-	  int yytype = YYTRANSLATE (yychar);
-	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-	  YYSIZE_T yysize = yysize0;
-	  YYSIZE_T yysize1;
-	  int yysize_overflow = 0;
-	  char *yymsg = 0;
-#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
-	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-	  int yyx;
-
-#if 0
-	  /* This is so xgettext sees the translatable formats that are
-	     constructed on the fly.  */
-	  YY_("syntax error, unexpected %s");
-	  YY_("syntax error, unexpected %s, expecting %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: after reduction, shifting from state 0 to\
+ state %d\n", YYPREFIX, YYFINAL);
 #endif
-	  char *yyfmt;
-	  char const *yyf;
-	  static char const yyunexpected[] = "syntax error, unexpected %s";
-	  static char const yyexpecting[] = ", expecting %s";
-	  static char const yyor[] = " or %s";
-	  char yyformat[sizeof yyunexpected
-			+ sizeof yyexpecting - 1
-			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-			   * (sizeof yyor - 1))];
-	  char const *yyprefix = yyexpecting;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 1;
-
-	  yyarg[0] = yytname[yytype];
-	  yyfmt = yystpcpy (yyformat, yyunexpected);
-
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      {
-		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-		  {
-		    yycount = 1;
-		    yysize = yysize0;
-		    yyformat[sizeof yyunexpected - 1] = '\0';
-		    break;
-		  }
-		yyarg[yycount++] = yytname[yyx];
-		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-		yysize_overflow |= yysize1 < yysize;
-		yysize = yysize1;
-		yyfmt = yystpcpy (yyfmt, yyprefix);
-		yyprefix = yyor;
-	      }
-
-	  yyf = YY_(yyformat);
-	  yysize1 = yysize + yystrlen (yyf);
-	  yysize_overflow |= yysize1 < yysize;
-	  yysize = yysize1;
-
-	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
-	    yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg)
-	    {
-	      /* Avoid sprintf, as that infringes on the user's name space.
-		 Don't have undefined behavior even if the translation
-		 produced a string with the wrong number of "%s"s.  */
-	      char *yyp = yymsg;
-	      int yyi = 0;
-	      while ((*yyp = *yyf))
-		{
-		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		    {
-		      yyp += yytnamerr (yyp, yyarg[yyi++]);
-		      yyf += 2;
-		    }
-		  else
+        yystate = YYFINAL;
+        *++yyssp = YYFINAL;
+        *++yyvsp = yyval;
+        if (yychar < 0)
 		    {
-		      yyp++;
-		      yyf++;
-		    }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
+            if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+            if (yydebug)
 	    {
-	      yyerror (YY_("syntax error"));
-	      goto yyexhaustedlab;
-	    }
+                yys = 0;
+                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+                if (!yys) yys = "illegal-symbol";
+                printf("%sdebug: state %d, reading %d (%s)\n",
+                        YYPREFIX, YYFINAL, yychar, yys);
 	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror (YY_("syntax error"));
+#endif
     }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse look-ahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
+        if (yychar == 0) goto yyaccept;
+        goto yyloop;
         }
+    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
+        yystate = yytable[yyn];
       else
-	{
-	  yydestruct ("Error: discarding", yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
-
-  /* Else will try to reuse look-ahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (0)
-     goto yyerrorlab;
-
-yyvsp -= yylen;
-  yyssp -= yylen;
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-
-      yydestruct ("Error: popping", yystos[yystate], yyvsp);
-      YYPOPSTACK;
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  *++yyvsp = yylval;
-
-
-  /* Shift the error token. */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: after reduction, shifting from state %d \
+to state %d\n", YYPREFIX, *yyssp, yystate);
 #endif
-
-yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
-  while (yyssp != yyss)
+    if (yyssp >= yysslim && yygrowstack())
     {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK;
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-  return yyresult;
-}
-
-
-#line 1290 "ldgram.y"
-
-void
-yyerror(arg)
-     const char *arg;
-{
-  if (ldfile_assumed_script)
-    einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
-	   ldfile_input_filename);
-  if (error_index > 0 && error_index < ERROR_NAME_MAX)
-     einfo ("%P%F:%S: %s in %s\n", arg, error_names[error_index-1]);
-  else
-     einfo ("%P%F:%S: %s\n", arg);
+        goto yyoverflow;
+    }
+    *++yyssp = yystate;
+    *++yyvsp = yyval;
+    goto yyloop;
+yyoverflow:
+    yyerror("yacc stack overflow");
+yyabort:
+    if (yyss)
+            free(yyss);
+    if (yyvs)
+            free(yyvs);
+    yyss = yyssp = NULL;
+    yyvs = yyvsp = NULL;
+    yystacksize = 0;
+    return (1);
+yyaccept:
+    if (yyss)
+            free(yyss);
+    if (yyvs)
+            free(yyvs);
+    yyss = yyssp = NULL;
+    yyvs = yyvsp = NULL;
+    yystacksize = 0;
+    return (0);
 }
-
diff -ruNbB binutils-2.17/ld/ldgram.h binutils-2.17.sua/ld/ldgram.h
--- binutils-2.17/ld/ldgram.h	2006-04-16 20:36:47 +0200
+++ binutils-2.17.sua/ld/ldgram.h	2008-04-01 09:03:30 +0200
@@ -1,272 +1,120 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
-
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     INT = 258,
-     NAME = 259,
-     LNAME = 260,
-     OREQ = 261,
-     ANDEQ = 262,
-     RSHIFTEQ = 263,
-     LSHIFTEQ = 264,
-     DIVEQ = 265,
-     MULTEQ = 266,
-     MINUSEQ = 267,
-     PLUSEQ = 268,
-     OROR = 269,
-     ANDAND = 270,
-     NE = 271,
-     EQ = 272,
-     GE = 273,
-     LE = 274,
-     RSHIFT = 275,
-     LSHIFT = 276,
-     UNARY = 277,
-     END = 278,
-     ALIGN_K = 279,
-     BLOCK = 280,
-     BIND = 281,
-     QUAD = 282,
-     SQUAD = 283,
-     LONG = 284,
-     SHORT = 285,
-     BYTE = 286,
-     SECTIONS = 287,
-     PHDRS = 288,
-     DATA_SEGMENT_ALIGN = 289,
-     DATA_SEGMENT_RELRO_END = 290,
-     DATA_SEGMENT_END = 291,
-     SORT_BY_NAME = 292,
-     SORT_BY_ALIGNMENT = 293,
-     SIZEOF_HEADERS = 294,
-     OUTPUT_FORMAT = 295,
-     FORCE_COMMON_ALLOCATION = 296,
-     OUTPUT_ARCH = 297,
-     INHIBIT_COMMON_ALLOCATION = 298,
-     SEGMENT_START = 299,
-     INCLUDE = 300,
-     MEMORY = 301,
-     DEFSYMEND = 302,
-     NOLOAD = 303,
-     DSECT = 304,
-     COPY = 305,
-     INFO = 306,
-     OVERLAY = 307,
-     DEFINED = 308,
-     TARGET_K = 309,
-     SEARCH_DIR = 310,
-     MAP = 311,
-     ENTRY = 312,
-     NEXT = 313,
-     SIZEOF = 314,
-     ADDR = 315,
-     LOADADDR = 316,
-     MAX_K = 317,
-     MIN_K = 318,
-     STARTUP = 319,
-     HLL = 320,
-     SYSLIB = 321,
-     FLOAT = 322,
-     NOFLOAT = 323,
-     NOCROSSREFS = 324,
-     ORIGIN = 325,
-     FILL = 326,
-     LENGTH = 327,
-     CREATE_OBJECT_SYMBOLS = 328,
-     INPUT = 329,
-     GROUP = 330,
-     OUTPUT = 331,
-     CONSTRUCTORS = 332,
-     ALIGNMOD = 333,
-     AT = 334,
-     SUBALIGN = 335,
-     PROVIDE = 336,
-     PROVIDE_HIDDEN = 337,
-     AS_NEEDED = 338,
-     CHIP = 339,
-     LIST = 340,
-     SECT = 341,
-     ABSOLUTE = 342,
-     LOAD = 343,
-     NEWLINE = 344,
-     ENDWORD = 345,
-     ORDER = 346,
-     NAMEWORD = 347,
-     ASSERT_K = 348,
-     FORMAT = 349,
-     PUBLIC = 350,
-     BASE = 351,
-     ALIAS = 352,
-     TRUNCATE = 353,
-     REL = 354,
-     INPUT_SCRIPT = 355,
-     INPUT_MRI_SCRIPT = 356,
-     INPUT_DEFSYM = 357,
-     CASE = 358,
-     EXTERN = 359,
-     START = 360,
-     VERS_TAG = 361,
-     VERS_IDENTIFIER = 362,
-     GLOBAL = 363,
-     LOCAL = 364,
-     VERSIONK = 365,
-     INPUT_VERSION_SCRIPT = 366,
-     KEEP = 367,
-     ONLY_IF_RO = 368,
-     ONLY_IF_RW = 369,
-     SPECIAL = 370,
-     EXCLUDE_FILE = 371
-   };
-#endif
-/* Tokens.  */
-#define INT 258
-#define NAME 259
-#define LNAME 260
-#define OREQ 261
-#define ANDEQ 262
-#define RSHIFTEQ 263
+#define INT 257
+#define NAME 258
+#define LNAME 259
+#define PLUSEQ 260
+#define MINUSEQ 261
+#define MULTEQ 262
+#define DIVEQ 263
 #define LSHIFTEQ 264
-#define DIVEQ 265
-#define MULTEQ 266
-#define MINUSEQ 267
-#define PLUSEQ 268
-#define OROR 269
-#define ANDAND 270
+#define RSHIFTEQ 265
+#define ANDEQ 266
+#define OREQ 267
+#define OROR 268
+#define ANDAND 269
+#define EQ 270
 #define NE 271
-#define EQ 272
+#define LE 272
 #define GE 273
-#define LE 274
+#define LSHIFT 274
 #define RSHIFT 275
-#define LSHIFT 276
-#define UNARY 277
-#define END 278
-#define ALIGN_K 279
-#define BLOCK 280
-#define BIND 281
-#define QUAD 282
-#define SQUAD 283
-#define LONG 284
-#define SHORT 285
-#define BYTE 286
-#define SECTIONS 287
-#define PHDRS 288
-#define DATA_SEGMENT_ALIGN 289
-#define DATA_SEGMENT_RELRO_END 290
-#define DATA_SEGMENT_END 291
-#define SORT_BY_NAME 292
-#define SORT_BY_ALIGNMENT 293
-#define SIZEOF_HEADERS 294
-#define OUTPUT_FORMAT 295
-#define FORCE_COMMON_ALLOCATION 296
-#define OUTPUT_ARCH 297
-#define INHIBIT_COMMON_ALLOCATION 298
-#define SEGMENT_START 299
-#define INCLUDE 300
-#define MEMORY 301
-#define DEFSYMEND 302
-#define NOLOAD 303
-#define DSECT 304
-#define COPY 305
-#define INFO 306
-#define OVERLAY 307
-#define DEFINED 308
-#define TARGET_K 309
-#define SEARCH_DIR 310
-#define MAP 311
-#define ENTRY 312
-#define NEXT 313
-#define SIZEOF 314
-#define ADDR 315
-#define LOADADDR 316
-#define MAX_K 317
-#define MIN_K 318
-#define STARTUP 319
-#define HLL 320
-#define SYSLIB 321
-#define FLOAT 322
-#define NOFLOAT 323
-#define NOCROSSREFS 324
-#define ORIGIN 325
-#define FILL 326
-#define LENGTH 327
-#define CREATE_OBJECT_SYMBOLS 328
-#define INPUT 329
-#define GROUP 330
-#define OUTPUT 331
-#define CONSTRUCTORS 332
-#define ALIGNMOD 333
-#define AT 334
-#define SUBALIGN 335
-#define PROVIDE 336
-#define PROVIDE_HIDDEN 337
-#define AS_NEEDED 338
-#define CHIP 339
-#define LIST 340
-#define SECT 341
-#define ABSOLUTE 342
-#define LOAD 343
-#define NEWLINE 344
-#define ENDWORD 345
-#define ORDER 346
-#define NAMEWORD 347
-#define ASSERT_K 348
-#define FORMAT 349
-#define PUBLIC 350
-#define BASE 351
-#define ALIAS 352
-#define TRUNCATE 353
-#define REL 354
-#define INPUT_SCRIPT 355
-#define INPUT_MRI_SCRIPT 356
-#define INPUT_DEFSYM 357
-#define CASE 358
-#define EXTERN 359
-#define START 360
-#define VERS_TAG 361
-#define VERS_IDENTIFIER 362
-#define GLOBAL 363
-#define LOCAL 364
-#define VERSIONK 365
-#define INPUT_VERSION_SCRIPT 366
-#define KEEP 367
-#define ONLY_IF_RO 368
-#define ONLY_IF_RW 369
-#define SPECIAL 370
-#define EXCLUDE_FILE 371
-
-
-
-
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 65 "ldgram.y"
-typedef union YYSTYPE {
+#define UNARY 276
+#define END 277
+#define ALIGN_K 278
+#define BLOCK 279
+#define BIND 280
+#define QUAD 281
+#define SQUAD 282
+#define LONG 283
+#define SHORT 284
+#define BYTE 285
+#define SECTIONS 286
+#define PHDRS 287
+#define DATA_SEGMENT_ALIGN 288
+#define DATA_SEGMENT_RELRO_END 289
+#define DATA_SEGMENT_END 290
+#define SORT_BY_NAME 291
+#define SORT_BY_ALIGNMENT 292
+#define SIZEOF_HEADERS 293
+#define OUTPUT_FORMAT 294
+#define FORCE_COMMON_ALLOCATION 295
+#define OUTPUT_ARCH 296
+#define INHIBIT_COMMON_ALLOCATION 297
+#define SEGMENT_START 298
+#define INCLUDE 299
+#define MEMORY 300
+#define DEFSYMEND 301
+#define NOLOAD 302
+#define DSECT 303
+#define COPY 304
+#define INFO 305
+#define OVERLAY 306
+#define DEFINED 307
+#define TARGET_K 308
+#define SEARCH_DIR 309
+#define MAP 310
+#define ENTRY 311
+#define NEXT 312
+#define SIZEOF 313
+#define ADDR 314
+#define LOADADDR 315
+#define MAX_K 316
+#define MIN_K 317
+#define STARTUP 318
+#define HLL 319
+#define SYSLIB 320
+#define FLOAT 321
+#define NOFLOAT 322
+#define NOCROSSREFS 323
+#define ORIGIN 324
+#define FILL 325
+#define LENGTH 326
+#define CREATE_OBJECT_SYMBOLS 327
+#define INPUT 328
+#define GROUP 329
+#define OUTPUT 330
+#define CONSTRUCTORS 331
+#define ALIGNMOD 332
+#define AT 333
+#define SUBALIGN 334
+#define PROVIDE 335
+#define PROVIDE_HIDDEN 336
+#define AS_NEEDED 337
+#define CHIP 338
+#define LIST 339
+#define SECT 340
+#define ABSOLUTE 341
+#define LOAD 342
+#define NEWLINE 343
+#define ENDWORD 344
+#define ORDER 345
+#define NAMEWORD 346
+#define ASSERT_K 347
+#define FORMAT 348
+#define PUBLIC 349
+#define BASE 350
+#define ALIAS 351
+#define TRUNCATE 352
+#define REL 353
+#define INPUT_SCRIPT 354
+#define INPUT_MRI_SCRIPT 355
+#define INPUT_DEFSYM 356
+#define CASE 357
+#define EXTERN 358
+#define START 359
+#define VERS_TAG 360
+#define VERS_IDENTIFIER 361
+#define GLOBAL 362
+#define LOCAL 363
+#define VERSIONK 364
+#define INPUT_VERSION_SCRIPT 365
+#define KEEP 366
+#define ONLY_IF_RO 367
+#define ONLY_IF_RW 368
+#define SPECIAL 369
+#define EXCLUDE_FILE 370
+#ifndef YYSTYPE_DEFINED
+#define YYSTYPE_DEFINED
+typedef union {
   bfd_vma integer;
   struct big_int
     {
@@ -294,14 +142,5 @@
   struct bfd_elf_version_expr *versyms;
   struct bfd_elf_version_tree *versnode;
 } YYSTYPE;
-/* Line 1447 of yacc.c.  */
-#line 299 "ldgram.h"
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
+#endif /* YYSTYPE_DEFINED */
 extern YYSTYPE yylval;
-
-
-
diff -ruNbB binutils-2.17/ld/ldlang.c binutils-2.17.sua/ld/ldlang.c
--- binutils-2.17/ld/ldlang.c	2006-06-12 15:05:04 +0200
+++ binutils-2.17.sua/ld/ldlang.c	2008-04-01 09:03:30 +0200
@@ -155,6 +155,64 @@
 
   return FALSE;
 }
+void count_entry_idata(lang_statement_union_type *s);
+
+void count_entry_idata2(lang_statement_union_type *s);
+int count_global = 0;
+void count_entry_idata(lang_statement_union_type *s)
+{
+  lang_output_section_statement_type *os;
+  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
+    {
+      switch (s->header.type)
+	{
+	case lang_output_section_statement_enum:
+		os = &s->output_section_statement;
+		if(os->name[1]=='i' && os->name[2]=='d') 
+			count_entry_idata2(os->children.head);
+		break;
+	default:
+		break;
+	}
+   }
+}
+void count_entry_idata2(lang_statement_union_type *s)
+{
+  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
+    {
+      switch (s->header.type)
+	{
+	case lang_wild_statement_enum:
+	 	count_entry_idata2(s->wild_statement.children.head);
+	 	break;
+	case lang_input_section_enum:
+	case lang_data_statement_enum:
+		count_global++;
+		break;
+	default:
+		break;
+	}
+   }
+}
+void count_out_sec_exist(void);
+int count_failures = 0;
+void count_out_sec_exist(void)
+{
+    asection *s;
+    char *sname;
+
+    LANG_FOR_EACH_INPUT_STATEMENT (f) {
+      	if(f->filename[0]=='P') {
+	    for(s = f->the_bfd->sections; s != NULL; s = s->next) {
+                sname = (char *)bfd_get_section_name (file->the_bfd, s);
+		if(sname[7]=='4' && s->output_section == NULL) {
+                    count_failures++;
+                }
+	    }
+        }
+    }
+}
+
 
 /* Generic traversal routines for finding matching sections.  */
 
@@ -223,6 +281,9 @@
 
   for (s = file->the_bfd->sections; s != NULL; s = s->next)
     {
+  	  count_global=0;
+  	  count_entry_idata(statement_list.head);
+
       sec = ptr->section_list;
       if (sec == NULL)
 	(*callback) (ptr, sec, s, file, data);
@@ -245,6 +306,9 @@
 	    walk_wild_consider_section (ptr, file, s, sec, callback, data);
 
 	  sec = sec->next;
+  	  count_global=0;
+  	  count_entry_idata(statement_list.head);
+
 	}
     }
 }
@@ -1393,7 +1457,7 @@
 
   if (add_child == NULL)
     add_child = &os->children;
-  lang_add_section (add_child, s, os);
+  lang_add_section (add_child, s, os, FALSE);
 
   lang_leave_output_section_statement (0, "*default*", NULL, NULL);
 
@@ -1728,7 +1792,7 @@
 /* Initialize an output section.  */
 
 static void
-init_os (lang_output_section_statement_type *s, asection *isec)
+init_os (lang_output_section_statement_type *s, asection *isec, bfd_boolean newsec)
 {
   if (s->bfd_section != NULL)
     return;
@@ -1736,9 +1800,19 @@
   if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
     einfo (_("%P%F: Illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
 
+  /* If we're forcing a new section (for ld -r that wants to preserve
+     sections, e.g. PE comdat), then just make a new output section from
+     scratch, unconditionally. Otherwise, find a match if there is one. */
+  if (newsec) 
+    {
+      s->bfd_section = bfd_make_section_anyway (output_bfd, s->name);
+    }
+  else
+    {
   s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
   if (s->bfd_section == NULL)
     s->bfd_section = bfd_make_section (output_bfd, s->name);
+    }
   if (s->bfd_section == NULL)
     {
       einfo (_("%P%F: output format %s cannot represent section called %s\n"),
@@ -1816,7 +1890,7 @@
 
 	    os = lang_output_section_find (exp->name.name);
 	    if (os != NULL && os->bfd_section == NULL)
-	      init_os (os, NULL);
+	      init_os (os, NULL, FALSE);
 	  }
 	}
       break;
@@ -1856,7 +1930,7 @@
 void
 lang_add_section (lang_statement_list_type *ptr,
 		  asection *section,
-		  lang_output_section_statement_type *output)
+		  lang_output_section_statement_type *output, bfd_boolean newsec)
 {
   flagword flags = section->flags;
   bfd_boolean discard;
@@ -1892,7 +1966,7 @@
       flagword flags;
 
       if (output->bfd_section == NULL)
-	init_os (output, section);
+	init_os (output, section, newsec);
 
       first = ! output->bfd_section->linker_has_input;
       output->bfd_section->linker_has_input = 1;
@@ -2157,7 +2231,7 @@
 
   if (before == NULL)
     lang_add_section (&ptr->children, section,
-		      (lang_output_section_statement_type *) output);
+		      (lang_output_section_statement_type *) output, FALSE);
   else
     {
       lang_statement_list_type list;
@@ -2165,7 +2239,7 @@
 
       lang_list_init (&list);
       lang_add_section (&list, section,
-			(lang_output_section_statement_type *) output);
+			(lang_output_section_statement_type *) output, FALSE);
 
       /* If we are discarding the section, LIST.HEAD will
 	 be NULL.  */
@@ -3113,6 +3187,9 @@
 	{
 	case lang_wild_statement_enum:
 	  wild (&s->wild_statement, target, os);
+  	  count_global=0;
+  	  count_entry_idata(statement_list.head);
+
 	  break;
 	case lang_constructors_statement_enum:
 	  map_input_to_output_sections (constructor_list.head,
@@ -3157,7 +3234,7 @@
 	     are initialized.  */
 	  exp_init_os (s->data_statement.exp);
 	  if (os != NULL && os->bfd_section == NULL)
-	    init_os (os, NULL);
+	    init_os (os, NULL, FALSE);
 	  /* The output section gets contents, and then we inspect for
 	     any flags set in the input script which override any ALLOC.  */
 	  os->bfd_section->flags |= SEC_HAS_CONTENTS;
@@ -3171,11 +3248,14 @@
 	case lang_padding_statement_enum:
 	case lang_input_statement_enum:
 	  if (os != NULL && os->bfd_section == NULL)
-	    init_os (os, NULL);
+	    init_os (os, NULL, FALSE);
+  	  count_global=0;
+  	  count_entry_idata(statement_list.head);
+
 	  break;
 	case lang_assignment_statement_enum:
 	  if (os != NULL && os->bfd_section == NULL)
-	    init_os (os, NULL);
+	    init_os (os, NULL, FALSE);
 
 	  /* Make sure that any sections mentioned in the assignment
 	     are initialized.  */
@@ -3203,7 +3283,7 @@
 		   (s->address_statement.section_name));
 	      
 	      if (aos->bfd_section == NULL)
-		init_os (aos, NULL);
+		init_os (aos, NULL, FALSE);
 	      aos->addr_tree = s->address_statement.address;
 	    }
 	  break;
@@ -3559,7 +3639,7 @@
 	      --len;
 	    }
 
-	  minfo (_("%W (size before relaxing)\n"), i->rawsize);
+	  minfo (_("%W (size before relaxing)\n"), i->size);
 	}
 
       if (i->output_section != NULL && i->output_section->owner == output_bfd)
@@ -3949,6 +4029,52 @@
   lang_input_section_type *is = &((*this_ptr)->input_section);
   asection *i = is->section;
 
+	/*
+	 * mayank@10th August, 2007
+	 * HACK: Two .text sections with lma=4096 and size = 275408
+	 * are getting introduced somehow. FIX This.
+	 * GOT IT !!!!!!!!!!!
+	 * all these are sections from dynamic object(here libc.so) 
+	 * which ideally should not be included in the executable.
+	 * This should be automatically take care in _bfd_coff_link_input_bfd
+	 * where in the beginning only, we bail out if the input_bfd
+	 * is dynamic. But that doesnt seem to work now.
+	 */
+  if ( i->owner->flags &DYNAMIC )
+  {
+	 i->flags |=SEC_EXCLUDE;
+  }
+#if 0
+  if (!strncmp(i->name,".text",5) && i->size == 275408)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+
+  if (!strncmp(i->name,".data",5) && i->size == 36628)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+
+ if (!strncmp(i->name,".dynsym",7) && i->size == 54036)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+
+ if (!strncmp(i->name,".rdata",6) && i->size == 25796)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+
+ if (!strncmp(i->name,".bss",4) && i->size == 16632)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+
+ if (!strncmp(i->name,".dynstr",7) && i->size == 26155)
+  {
+	  i->flags |=SEC_EXCLUDE;
+  }
+#endif
   if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
       && (i->flags & SEC_EXCLUDE) == 0)
     {
@@ -4141,15 +4267,26 @@
 	    if (os->addr_tree != NULL)
 	      {
 		os->processed = FALSE;
-		exp_fold_tree (os->addr_tree, bfd_abs_section_ptr, &dot);
+		exp_fold_tree (s->output_section_statement.addr_tree, bfd_abs_section_ptr, &dot);
 
 		if (!expld.result.valid_p
 		    && expld.phase != lang_mark_phase_enum)
 		  einfo (_("%F%S: non constant or forward reference"
 			   " address expression for section %s\n"),
 			 os->name);
-
-		dot = expld.result.value + expld.result.section->vma;
+		#if 0
+		/*
+		 * mayank@15th June, 2007
+		 * This was a temporary hack for the section vma issue where
+		 * the vma always had the image_base added. But this hack 
+		 * didnt work for programs compiled with --image-base option 
+		 * to linker.
+		 * Hence a more general fix is in ldexp.c (fold_name)
+		 */
+		if (expld.result.value >0x400000)
+			expld.result.value-=0x400000;
+		#endif
+		dot = (expld.result.value) + expld.result.section->vma;
 	      }
 
 	    if (os->bfd_section == NULL)
@@ -4189,10 +4326,22 @@
 	      }
 	    else
 	      {
-		int align;
+		int align=-1;
 
 		if (os->addr_tree == NULL)
 		  {
+		     if (link_info.relocatable)
+		       {
+			 /* relocateable links start each section at zero; this
+			    could be done in the script, but that requires that
+			    we know, a-priori, the names of all the sections.
+			    This works regardless of section names.  However, if
+			    the link script wants to specify something, we need to
+			    let it */
+			 dot = 0;
+		       }
+		     else 
+			{
 		    /* No address specified for this section, get one
 		       from the region specification.  */
 		    if (os->region == NULL
@@ -4242,6 +4391,7 @@
 		    newdot = os->region->current;
 		    align = os->bfd_section->alignment_power;
 		  }
+		  }
 		else
 		  align = os->section_alignment;
 
@@ -4268,8 +4418,8 @@
 	    lang_size_sections_1 (os->children.head, os, &os->children.head,
 				  os->fill, newdot, relax, check_regions);
 
-	    os->processed = TRUE;
 
+	    os->processed = TRUE;
 	    if (bfd_is_abs_section (os->bfd_section) || os->ignored)
 	      {
 		ASSERT (os->bfd_section->size == 0);
@@ -5113,7 +5262,7 @@
 
 			}
 		      lang_add_section (&default_common_section->children, s,
-					default_common_section);
+					default_common_section, FALSE);
 		    }
 		}
 	      else if (ldemul_place_orphan (s))
@@ -5123,7 +5272,7 @@
 		  lang_output_section_statement_type *os;
 
 		  os = lang_output_section_statement_lookup (s->name);
-		  lang_add_section (&os->children, s, os);
+		  lang_add_section (&os->children, s, os, FALSE);
 		}
 	    }
 	}
@@ -5200,11 +5349,16 @@
 ldlang_add_file (lang_input_statement_type *entry)
 {
   bfd **pp;
+  count_failures = 0;
+  count_out_sec_exist();
 
   lang_statement_append (&file_chain,
 			 (lang_statement_union_type *) entry,
 			 &entry->next);
 
+  count_failures = 0;
+  count_out_sec_exist();
+
   /* The BFD linker needs to have a list of all input BFDs involved in
      a link.  */
   ASSERT (entry->the_bfd->link_next == NULL);
@@ -5226,6 +5380,9 @@
      this, we should probably handle SEC_EXCLUDE in the same way.  */
 
   bfd_map_over_sections (entry->the_bfd, section_already_linked, entry);
+  count_failures = 0;
+  count_out_sec_exist();
+
 }
 
 void
@@ -5460,6 +5617,9 @@
 
   /* Open the output file.  */
   lang_for_each_statement (ldlang_open_output);
+  count_global=0;
+  count_entry_idata(statement_list.head);
+
   init_opb ();
 
   ldemul_create_output_section_statements ();
@@ -5472,8 +5632,18 @@
 
   /* Create a bfd for each input file.  */
   current_target = default_target;
+  count_global=0;
+  count_entry_idata(statement_list.head);
+  count_failures = 0;
+  count_out_sec_exist();
+
   open_input_bfds (statement_list.head, FALSE);
 
+  count_failures = 0;
+  count_out_sec_exist();
+  count_global=0;
+  count_entry_idata(statement_list.head);
+
   link_info.gc_sym_list = &entry_symbol;
   if (entry_symbol.name == NULL)
     link_info.gc_sym_list = ldlang_undef_chain_list_head;
@@ -5498,17 +5668,28 @@
   ldctor_build_sets ();
 
   /* Remove unreferenced sections if asked to.  */
+  count_failures = 0;
+  count_out_sec_exist();
   lang_gc_sections ();
+  count_failures = 0;
+  count_out_sec_exist();
 
   /* Size up the common data.  */
   lang_common ();
 
   /* Update wild statements.  */
   update_wild_statements (statement_list.head);
+  count_failures = 0;
+  count_out_sec_exist();
 
   /* Run through the contours of the script and attach input sections
      to the correct output sections.  */
+  count_global=0;
+  count_entry_idata(statement_list.head);
+
   map_input_to_output_sections (statement_list.head, NULL, NULL);
+  count_global=0;
+  count_entry_idata(statement_list.head);
 
   /* Find any sections not attached explicitly and handle them.  */
   lang_place_orphans ();
@@ -5544,6 +5725,9 @@
   lang_record_phdrs ();
 
   /* Size up the sections.  */
+  count_global=0;
+  count_entry_idata(statement_list.head);
+
   lang_size_sections (NULL, !command_line.relax);
 
   /* Now run around and relax if we can.  */
diff -ruNbB binutils-2.17/ld/ldlang.h binutils-2.17.sua/ld/ldlang.h
--- binutils-2.17/ld/ldlang.h	2006-06-12 15:05:04 +0200
+++ binutils-2.17.sua/ld/ldlang.h	2008-04-01 09:03:30 +0200
@@ -566,7 +566,8 @@
   (void);
 extern void lang_add_section
   (lang_statement_list_type *, asection *,
-   lang_output_section_statement_type *);
+   lang_output_section_statement_type *,
+   bfd_boolean newsec);
 extern void lang_new_phdr
   (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
    etree_type *);
diff -ruNbB binutils-2.17/ld/ldmain.c binutils-2.17.sua/ld/ldmain.c
--- binutils-2.17/ld/ldmain.c	2006-04-06 20:52:45 +0200
+++ binutils-2.17.sua/ld/ldmain.c	2008-04-01 09:03:30 +0200
@@ -48,10 +48,19 @@
 #endif
 
 #include <string.h>
+/*
+ * FIXME
+ * mayank@15th June, 2007
+ * declarations in Interix headers dont get recognized in configure
+ * and hence this HACK
+ */
+extern int       __cdecl strcasecmp (const char *, const char *);
+extern int       __cdecl strncasecmp (const char *, const char *, size_t);
+
 
 #ifdef HAVE_SBRK
 #if !HAVE_DECL_SBRK
-extern void *sbrk ();
+extern void *sbrk (int incr);
 #endif
 #endif
 
diff -ruNbB binutils-2.17/ld/ldwrite.c binutils-2.17.sua/ld/ldwrite.c
--- binutils-2.17/ld/ldwrite.c	2005-11-17 01:10:05 +0100
+++ binutils-2.17.sua/ld/ldwrite.c	2008-04-01 09:03:30 +0200
@@ -540,20 +539,44 @@
     }
   sanity_check (abfd);
 }
+int count_idata(bfd *abfd);
+int count_idata(bfd *abfd)
+{
+  struct bfd_link_order *p;
+  asection *o;
+
+  int count_sec = 0;
+  for (o = abfd->sections; o != NULL; o = o->next)
+    {
+	if(o->name[1]=='i') {
+     		 for (p = o->map_head.link_order; p != NULL; p = p->next) {
+			count_sec++;
+		  }
+	}
+  }
+return count_sec;
+}
 
 /* Call BFD to write out the linked file.  */
 
 void
 ldwrite (void)
 {
+int count =0;
+
   /* Reset error indicator, which can typically something like invalid
      format from opening up the .o files.  */
   bfd_set_error (bfd_error_no_error);
+count = count_idata(output_bfd);
+
   lang_for_each_statement (build_link_order);
+count = count_idata(output_bfd);
 
   if (config.split_by_reloc != (unsigned) -1
       || config.split_by_file != (bfd_size_type) -1)
     split_sections (output_bfd, &link_info);
+count = count_idata(output_bfd);
+
   if (!bfd_final_link (output_bfd, &link_info))
     {
       /* If there was an error recorded, print it out.  Otherwise assume
diff -ruNbB binutils-2.17/ld/lexsup.c binutils-2.17.sua/ld/lexsup.c
--- binutils-2.17/ld/lexsup.c	2005-10-30 19:08:52 +0100
+++ binutils-2.17.sua/ld/lexsup.c	2008-04-01 09:03:30 +0200
@@ -328,14 +328,19 @@
     '\0', N_("KEYWORD"), N_("Ignored for SunOS compatibility"), ONE_DASH },
   { {"Bdynamic", no_argument, NULL, OPTION_CALL_SHARED},
     '\0', NULL, N_("Link against shared libraries"), ONE_DASH },
+/* Conflicts with dynamic-linker below... suppressed (use specs?) // Check out experimentally later.
   { {"dy", no_argument, NULL, OPTION_CALL_SHARED},
     '\0', NULL, NULL, ONE_DASH },
+*/
+
   { {"call_shared", no_argument, NULL, OPTION_CALL_SHARED},
     '\0', NULL, NULL, ONE_DASH },
   { {"Bstatic", no_argument, NULL, OPTION_NON_SHARED},
     '\0', NULL, N_("Do not link against shared libraries"), ONE_DASH },
+/* for symmetry
   { {"dn", no_argument, NULL, OPTION_NON_SHARED},
     '\0', NULL, NULL, ONE_DASH },
+*/
   { {"non_shared", no_argument, NULL, OPTION_NON_SHARED},
     '\0', NULL, NULL, ONE_DASH },
   { {"static", no_argument, NULL, OPTION_NON_SHARED},
diff -ruNbB binutils-2.17/ld/scripttempl/pe.sc binutils-2.17.sua/ld/scripttempl/pe.sc
--- binutils-2.17/ld/scripttempl/pe.sc	2005-10-05 10:07:51 +0200
+++ binutils-2.17.sua/ld/scripttempl/pe.sc	2008-04-01 09:03:30 +0200
@@ -16,7 +16,7 @@
   R_DATA='*(SORT(.data$*))'
   R_RDATA='*(SORT(.rdata$*))'
   R_IDATA='
-    SORT(*)(.idata$2)
+    SORT(*)(.idata$2)  /* here we sort by filename! */
     SORT(*)(.idata$3)
     /* These zeroes mark the end of the import list.  */
     LONG (0); LONG (0); LONG (0); LONG (0); LONG (0);
@@ -43,6 +43,11 @@
   R_RSRC=
 fi
 
+# if DYNAMIC_LINKING [
+# // Note XXX below; needs work. 
+LINKERSECTS="${RELOCATING-0} ${RELOCATXXX+\(NOLOAD\)} ${RELOCATING+ BLOCK(__section_alignment__) }"
+# ] 
+
 cat <<EOF
 ${RELOCATING+OUTPUT_FORMAT(${OUTPUT_FORMAT})}
 ${RELOCATING-OUTPUT_FORMAT(${RELOCATEABLE_OUTPUT_FORMAT})}
@@ -50,6 +55,15 @@
 
 ${LIB_SEARCH_DIRS}
 
+ENTRY(${ENTRY})
+/* if DYNAMIC_LINKING [ */
+/* Not sure yet */
+${RELOCATING+/* Do we need any of these for elf?
+   __DYNAMIC = 0; ${STACKZERO+${STACKZERO}} ${SHLIB_PATH+${SHLIB_PATH}}  */}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+/* end DYNAMIC_LINKING ] */
+
+
 SECTIONS
 {
   ${RELOCATING+/* Make the virtual address and file offset synced if the alignment is}
@@ -63,6 +77,25 @@
     ${R_TEXT}
     *(.glue_7t)
     *(.glue_7)
+    ${RELOCATING+. = ALIGN(4);}
+ 
+    /* collect constructors only for final links */
+    ${RELOCATING+
+        LONG (-1)
+        KEEP (*(.ctor_head))
+	KEEP (*(SORT(.ctors.*)))   /* Here we sort by section name! */
+        KEEP (*(.ctors))
+        KEEP (*(.ctor))
+        LONG (0)
+
+        LONG (-1)
+        KEEP (*(.dtor_head))
+	KEEP (*(SORT(.dtors.*)))
+        KEEP (*(.dtors))
+        KEEP (*(.dtor))
+        LONG (0)
+    }
+
     ${CONSTRUCTING+ ___CTOR_LIST__ = .; __CTOR_LIST__ = . ; 
 			LONG (-1);*(.ctors); *(.ctor); *(SORT(.ctors.*));  LONG (0); }
     ${CONSTRUCTING+ ___DTOR_LIST__ = .; __DTOR_LIST__ = . ; 
@@ -96,6 +129,10 @@
     *(.rdata)
     ${R_RDATA}
     *(.eh_frame)
+    /* DYNAMIC_LINKING [ */
+    *(.hash)
+    *(.interp)
+    /* ] */
     ${RELOCATING+___RUNTIME_PSEUDO_RELOC_LIST__ = .;}
     ${RELOCATING+__RUNTIME_PSEUDO_RELOC_LIST__ = .;}
     *(.rdata_runtime_pseudo_reloc)
@@ -108,9 +145,29 @@
     *(.pdata)
   }
 
+/* if DYNAMIC_LINKING [ */
+  .got ${RELOCATING-0} ${RELOCATING+ BLOCK(__section_alignment__) } :
+  { 
+     *(.got.plt) 
+     *(.got)
+  }
+/* end DYNAMIC_LINKING ] */
+
+/* .idata must precede bss so file and code offsets remain the same for .sos */
+/* (At least for now... using Ldr* routines may fix.) */
+  .idata ${RELOCATING+BLOCK(__section_alignment__)} :
+  {
+    /* This cannot currently be handled with grouped sections.
+	See pe.em:sort_sections.  */
+    ${R_IDATA}
+  }
+
   .bss ${RELOCATING+BLOCK(__section_alignment__)} :
   {
     ${RELOCATING+__bss_start__ = . ;}
+/* DYNAMIC_LINKING */
+    *(.dynbss)
+/* end DYNAMIC_LINKING */
     *(.bss)
     *(COMMON)
     ${RELOCATING+__bss_end__ = . ;}
@@ -129,12 +186,6 @@
     *(.drectve)
   }
 
-  .idata ${RELOCATING+BLOCK(__section_alignment__)} :
-  {
-    /* This cannot currently be handled with grouped sections.
-	See pe.em:sort_sections.  */
-    ${R_IDATA}
-  }
   .CRT ${RELOCATING+BLOCK(__section_alignment__)} :
   { 					
     ${RELOCATING+___crt_xc_start__ = . ;}
@@ -169,6 +220,50 @@
     ${RELOCATING+ __end__ = .;}
   }
 
+/* DYNAMIC_LINKING [  // XXX below, rela??? */
+  /* // ??? .dynamic ${RELOCATING-0} ${RELOCATXXX+"(NOLOAD)"} : { */
+  .dynamic $LINKERSECTS: {
+    *(.dynamic)
+  }
+
+  .dynsym $LINKERSECTS : { 
+    *(.dynsym)	
+  }
+
+  .dynstr $LINKERSECTS : { 
+    *(.dynstr)
+  }
+
+  .gnu.version $LINKERSECTS : {
+    *(.gnu.version)
+  }
+
+  .gnu.version_d $LINKERSECTS : {
+    *(.gnu.version_d)
+  }
+
+  .gnu.version_r $LINKERSECTS : {
+    *(.gnu.version_r)
+  }
+
+  .rel.dyn $LINKERSECTS :
+  { 
+    *(.rel.internal)
+    *(.rel.got)
+    *(.rel.plt)
+  }
+
+  .rela.dyn $LINKERSECTS :
+  { 
+    *(.rela.*)
+  }
+
+  .init $LINKERSECTS : { 
+    *(.init)
+  } =${NOP-0}
+
+/* end DYNAMIC_LINKING ] */
+
   .rsrc ${RELOCATING+BLOCK(__section_alignment__)} :
   { 					
     *(.rsrc)
diff -ruNbB binutils-2.17/ld/sysdep.h binutils-2.17.sua/ld/sysdep.h
--- binutils-2.17/ld/sysdep.h	2005-06-09 20:39:34 +0200
+++ binutils-2.17.sua/ld/sysdep.h	2008-04-01 09:03:30 +0200
@@ -93,4 +93,8 @@
 extern char **environ;
 #endif
 
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+
 #endif /* ! defined (LD_SYSDEP_H) */
