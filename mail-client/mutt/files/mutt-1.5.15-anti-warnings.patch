--- mutt-1.5.15/copy.c
+++ mutt-1.5.15/copy.c
@@ -56,7 +56,7 @@
   int hdr_count;
   int x;
   char *this_one = NULL;
-  size_t this_one_len;
+  size_t this_one_len = 0;
   int error;
 
   if (ftello (in) != off_start)
@@ -851,7 +851,7 @@
   char buf[HUGE_STRING];
   char cbuf[STRING];
   char c2buf[STRING];
-  char *p;
+  char *p = NULL;
   int l, linelen, buflen, count, cbuflen, c2buflen, plen;
 
   linelen = mutt_strlen (*h);
--- mutt-1.5.15/hcache.c
+++ mutt-1.5.15/hcache.c
@@ -296,8 +296,11 @@
   restore_char(&(*b)->data, d, off);
   restore_int(&offset, d, off);
   (*b)->dptr = (*b)->data + offset;
-  restore_int((unsigned int *) &(*b)->dsize, d, off);
-  restore_int((unsigned int *) &(*b)->destroy, d, off);
+  /* reuse used to do proper (value) casts here */
+  restore_int(&used, d, off);
+  (*b)->dsize = used;
+  restore_int(&used, d, off);
+  (*b)->destroy = used;
 }
 
 static unsigned char *
--- mutt-1.5.15/imap/message.c
+++ mutt-1.5.15/imap/message.c
@@ -154,7 +154,7 @@
         rc = imap_cmd_step (idata);
         if (rc != IMAP_CMD_CONTINUE)
 	{
-	  imap_free_header_data ((void**) &h.data);
+	  imap_free_header_data ((void**) (void*) &h.data);
           break;
 	}
 
@@ -162,7 +162,7 @@
           continue;
         else if (mfhrc < 0)
 	{
-	  imap_free_header_data ((void**) &h.data);
+	  imap_free_header_data ((void**) (void*) &h.data);
           break;
 	}
 
@@ -189,7 +189,7 @@
 	else
 	  /* bad header in the cache, we'll have to refetch.
 	   * TODO: consider the possibility of a holey cache. */
-          imap_free_header_data((void**) &h.data);
+          imap_free_header_data((void**) (void*) &h.data);
       }
       while (rc != IMAP_CMD_OK && mfhrc == -1);
       if (rc == IMAP_CMD_OK)
@@ -197,7 +197,7 @@
       if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))
       {
         if (h.data)
-          imap_free_header_data ((void**) &h.data);
+          imap_free_header_data ((void**) (void*) &h.data);
         fclose (fp);
         return -1;
       }
@@ -298,7 +298,7 @@
     if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))
     {
       if (h.data)
-        imap_free_header_data ((void**) &h.data);
+        imap_free_header_data ((void**) (void*) &h.data);
       fclose (fp);
       return -1;
     }
--- mutt-1.5.15/muttlib.c
+++ mutt-1.5.15/muttlib.c
@@ -1602,7 +1602,7 @@
   {
     offset = buf->dptr - buf->data;
     buf->dsize += len < 128 ? 128 : len + 1;
-    safe_realloc ((void**) &buf->data, buf->dsize);
+    safe_realloc ((void**) (void*) &buf->data, buf->dsize);
     buf->dptr = buf->data + offset;
   }
   memcpy (buf->dptr, s, len);
--- mutt-1.5.15/regex.c
+++ mutt-1.5.15/regex.c
@@ -2197,7 +2197,20 @@
                       {
                         PATFETCH (c);
                         if (c == ':' || c == ']' || p == pend
-                            || c1 == (unsigned char)CHAR_CLASS_MAX_LENGTH)
+                            /* http://comments.gmane.org/gmane.mail.mutt.devel/11804
+                             * the compiler generates a warning if
+                             * CHAR_CLASS_MAX_LENGTH is > 255, which is
+                             * valid.  Since it is a constant which may
+                             * come from anywhere casting it or
+                             * subtracting 1 is not a solution.  The
+                             * check is pretty obscure as in most cases
+                             * it will be pretty much void.  Silence the
+                             * compiler by using its own logic against
+                             * it. */
+#ifndef CHAR_CLASS_MAX_LENGTH > 255 /* unsigned char should be 0-255 */
+                            || c1 == CHAR_CLASS_MAX_LENGTH
+#endif
+                           )
                           break;
                         str[c1++] = c;
                       }
@@ -3117,9 +3130,6 @@
 #ifndef REGEX_MALLOC
   char *destination;
 #endif
-  /* We don't push any register information onto the failure stack.  */
-  unsigned num_regs = 0;
-
   register char *fastmap = bufp->fastmap;
   unsigned char *pattern = bufp->buffer;
   unsigned char *p = pattern;
