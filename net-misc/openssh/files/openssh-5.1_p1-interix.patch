http://bugs.gentoo.org/show_bug.cgi?id=235149

diff --git a/auth-passwd.c b/auth-passwd.c
index 9683325..c2ce065 100644
--- a/auth-passwd.c
+++ b/auth-passwd.c
@@ -55,6 +55,10 @@
 #include "auth-options.h"
 #include "misc.h"
 
+#ifdef __INTERIX
+# include <interix/security.h>
+#endif
+
 extern Buffer loginmsg;
 extern ServerOptions options;
 
@@ -113,6 +117,9 @@ auth_password(Authctxt *authctxt, const char *password)
 		return ok;
 	}
 #endif
+#ifdef __INTERIX
+	return (setuser(authctxt->user, password, SU_CHECK) == 0) ? ok : 0;
+#endif
 #ifdef USE_PAM
 	if (options.use_pam)
 		return (sshpam_auth_passwd(authctxt, password) && ok);
diff --git a/configure.ac b/configure.ac
index fcf7e41..3773509 100644
--- a/configure.ac
+++ b/configure.ac
@@ -445,6 +445,23 @@ int main(void) { exit(0); }
 		[Define if your platform needs to skip post auth
 		file descriptor passing])
 	;;
+*-*-interix*)
+	AC_DEFINE(MISSING_HOWMANY, 1, [howmany macro is missing])
+	AC_DEFINE(USE_PIPES, 1, [Use PIPES instead of a socketpair()])
+	AC_DEFINE(DISABLE_LOGIN, 1,
+		[Define if you don't want to use your system's login() call])
+	AC_DEFINE(DISABLE_SHADOW, 1,
+	    [Define if you want to disable shadow passwords])
+	AC_DEFINE(IP_TOS_IS_BROKEN, 1,
+	    [Define if your system choked on IP TOS setting])
+	AC_DEFINE(NO_IPPORT_RESERVED_CONCEPT, 1,
+	    [Define if the concept of ports only accessible to
+		superusers isn't known])
+	AC_DEFINE(DISABLE_FD_PASSING, 1,
+		[Define if your platform needs to skip post auth
+		file descriptor passing])
+	SSHDLIBS="$SSHDLIBS -lcrypt"
+	;;
 *-*-dgux*)
 	AC_DEFINE(IP_TOS_IS_BROKEN)
 	AC_DEFINE(SETEUID_BREAKS_SETUID)
diff --git a/defines.h b/defines.h
index a8203eb..7c6e47f 100644
--- a/defines.h
+++ b/defines.h
@@ -725,7 +725,11 @@ struct winsize {
 #endif
 
 #ifndef IOV_MAX
-# if defined(_XOPEN_IOV_MAX)
+# if defined(__INTERIX)
+   // Interix: has _XOPEN_IOV_MAX = INT_MAX which breaks
+   // the compilation, since an iovec array of INT_MAX is too large
+#  define	IOV_MAX		_SC_IOV_MAX
+# elif defined(_XOPEN_IOV_MAX)
 #  define	IOV_MAX		_XOPEN_IOV_MAX
 # elif defined(DEF_IOV_MAX)
 #  define	IOV_MAX		DEF_IOV_MAX
diff --git a/hostfile.c b/hostfile.c
index 2cceb35..57bdcd5 100644
--- a/hostfile.c
+++ b/hostfile.c
@@ -45,7 +45,9 @@
 #include <openssl/hmac.h>
 #include <openssl/sha.h>
 
-#include <resolv.h>
+#ifndef __INTERIX
+# include <resolv.h>
+#endif
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/openbsd-compat/bsd-misc.h b/openbsd-compat/bsd-misc.h
index b61ec42..6d28f8e 100644
--- a/openbsd-compat/bsd-misc.h
+++ b/openbsd-compat/bsd-misc.h
@@ -68,12 +68,14 @@ int truncate (const char *, off_t);
 #endif /* HAVE_TRUNCATE */
 
 #if !defined(HAVE_NANOSLEEP) && !defined(HAVE_NSLEEP)
+#ifndef __INTERIX
 #ifndef HAVE_STRUCT_TIMESPEC
 struct timespec {
 	time_t	tv_sec;
 	long	tv_nsec;
 };
 #endif
+#endif
 int nanosleep(const struct timespec *, struct timespec *);
 #endif
 
diff --git a/openbsd-compat/getrrsetbyname.c b/openbsd-compat/getrrsetbyname.c
index 785b225..4dbfd4e 100644
--- a/openbsd-compat/getrrsetbyname.c
+++ b/openbsd-compat/getrrsetbyname.c
@@ -61,6 +61,10 @@
 extern int h_errno;
 #endif
 
+/* on interix, all this stuff won't work that easy
+ * so we skip it for now. */
+#if !defined(__INTERIX)
+
 /* We don't need multithread support here */
 #ifdef _THREAD_PRIVATE
 # undef _THREAD_PRIVATE
@@ -182,11 +186,16 @@ static void free_dns_response(struct dns_response *);
 
 static int count_dns_rr(struct dns_rr *, u_int16_t, u_int16_t);
 
+#endif /* __INTERIX */
+
 int
 getrrsetbyname(const char *hostname, unsigned int rdclass,
     unsigned int rdtype, unsigned int flags,
     struct rrsetinfo **res)
 {
+#if defined(__INTERIX)
+	return (ERRSET_FAIL);
+#else
 	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
 	int result;
 	struct rrsetinfo *rrset = NULL;
@@ -343,6 +352,7 @@ fail:
 	if (response != NULL)
 		free_dns_response(response);
 	return (result);
+#endif
 }
 
 void
@@ -376,6 +386,8 @@ freerrset(struct rrsetinfo *rrset)
 	free(rrset);
 }
 
+#if !defined(__INTERIX)
+
 /*
  * DNS response parsing routines
  */
@@ -607,4 +619,6 @@ count_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)
 	return (n);
 }
 
+#endif /* __INTERIX */
+
 #endif /* !defined(HAVE_GETRRSETBYNAME) */
diff --git a/openbsd-compat/getrrsetbyname.h b/openbsd-compat/getrrsetbyname.h
index 1283f55..3befd41 100644
--- a/openbsd-compat/getrrsetbyname.h
+++ b/openbsd-compat/getrrsetbyname.h
@@ -54,9 +54,11 @@
 
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <arpa/nameser.h>
+#ifndef __INTERIX
+# include <arpa/nameser.h>
+# include <resolv.h>
+#endif
 #include <netdb.h>
-#include <resolv.h>
 
 #ifndef HFIXEDSZ
 #define HFIXEDSZ 12
diff --git a/openbsd-compat/inet_ntop.c b/openbsd-compat/inet_ntop.c
index e7ca4b7..4cf9200 100644
--- a/openbsd-compat/inet_ntop.c
+++ b/openbsd-compat/inet_ntop.c
@@ -27,7 +27,9 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-#include <arpa/nameser.h>
+#ifndef __INTERIX
+# include <arpa/nameser.h>
+#endif
 #include <string.h>
 #include <errno.h>
 #include <stdio.h>
diff --git a/session.c b/session.c
index b3c5bc2..74258d6 100644
--- a/session.c
+++ b/session.c
@@ -1133,6 +1133,123 @@ do_setup_env(Session *s, const char *shell)
 	}
 #endif
 
+#ifdef __INTERIX
+	{
+		char *tmp = NULL;
+
+		if((tmp = getenv("ALLUSERSPROFILE")) != NULL)
+			child_set_env(&env, &envsize, "ALLUSERSPROFILE", tmp);
+		if((tmp = getenv("COMMONPROGRAMFILES")) != NULL)
+			child_set_env(&env, &envsize, "COMMONPROGRAMFILES", tmp);
+		if((tmp = getenv("COMPUTERNAME")) != NULL)
+			child_set_env(&env, &envsize, "COMPUTERNAME", tmp);
+		if((tmp = getenv("COMSPEC")) != NULL)
+			child_set_env(&env, &envsize, "COMSPEC", tmp);
+		if((tmp = getenv("NUMBER_OF_PROCESSORS")) != NULL)
+			child_set_env(&env, &envsize, "NUMBER_OF_PROCESSORS", tmp);
+		if((tmp = getenv("OS")) != NULL)
+			child_set_env(&env, &envsize, "OS", tmp);
+		if((tmp = getenv("PATHEXT")) != NULL)
+			child_set_env(&env, &envsize, "PATHEXT", tmp);
+		if((tmp = getenv("PROCESSOR_ARCHITECTURE")) != NULL)
+			child_set_env(&env, &envsize, "PROCESSOR_ARCHITECTURE", tmp);
+		if((tmp = getenv("PROCESSOR_IDENTIFIER")) != NULL)
+			child_set_env(&env, &envsize, "PROCESSOR_IDENTIFIER", tmp);
+		if((tmp = getenv("PROCESSOR_LEVEL")) != NULL)
+			child_set_env(&env, &envsize, "PROCESSOR_LEVEL", tmp);
+		if((tmp = getenv("PROCESSOR_REVISION")) != NULL)
+			child_set_env(&env, &envsize, "PROCESSOR_REVISION", tmp);
+		if((tmp = getenv("PROGRAMFILES")) != NULL)
+			child_set_env(&env, &envsize, "PROGRAMFILES", tmp);
+		if((tmp = getenv("SYSTEMDRIVE")) != NULL)
+			child_set_env(&env, &envsize, "SYSTEMDRIVE", tmp);
+		if((tmp = getenv("SYSTEMROOT")) != NULL)
+			child_set_env(&env, &envsize, "SYSTEMROOT", tmp);
+		if((tmp = getenv("TMP")) != NULL)
+			child_set_env(&env, &envsize, "TMP", tmp);
+		if((tmp = getenv("TEMP")) != NULL)
+			child_set_env(&env, &envsize, "TEMP", tmp);
+		if((tmp = getenv("WINDIR")) != NULL)
+			child_set_env(&env, &envsize, "WINDIR", tmp);
+
+		/* these are required to detect visual studio */
+		if((tmp = getenv("VS70COMNTOOLS")) != NULL)
+			child_set_env(&env, &envsize, "VS70COMNTOOLS", tmp);
+		if((tmp = getenv("VS71COMNTOOLS")) != NULL)
+			child_set_env(&env, &envsize, "VS71COMNTOOLS", tmp);
+		if((tmp = getenv("VS80COMNTOOLS")) != NULL)
+			child_set_env(&env, &envsize, "VS80COMNTOOLS", tmp);
+		if((tmp = getenv("VS90COMNTOOLS")) != NULL)
+			child_set_env(&env, &envsize, "VS90COMNTOOLS", tmp);
+
+		/* these are the interix directory variables... */
+		if((tmp = getenv("INTERIX_ROOT")) != NULL)
+			child_set_env(&env, &envsize, "INTERIX_ROOT", tmp);
+		if((tmp = getenv("INTERIX_ROOT_WIN")) != NULL)
+			child_set_env(&env, &envsize, "INTERIX_ROOT_WIN", tmp);
+		if((tmp = getenv("SFUDIR")) != NULL)
+			child_set_env(&env, &envsize, "SFUDIR", tmp);
+		if((tmp = getenv("SFUDIR_WIN")) != NULL)
+			child_set_env(&env, &envsize, "SFUDIR_WIN", tmp);
+		if((tmp = getenv("SUA_ROOT")) != NULL)
+			child_set_env(&env, &envsize, "SUA_ROOT", tmp);
+		if((tmp = getenv("SUA_ROOT_WIN")) != NULL)
+			child_set_env(&env, &envsize, "SUA_ROOT_WIN", tmp);
+		if((tmp = getenv("OPENNT_ROOT")) != NULL)
+			child_set_env(&env, &envsize, "OPENNT_ROOT", tmp);
+
+		/* LD_LIBRARY_PATH required? */
+	}
+	{
+		/* does this really work? */
+		struct passwd* fullpw = getpwuid_ex(pw->pw_uid, PW_FULLNAME);
+		char* pos_enddomain = NULL;
+
+		if(fullpw) {
+			char* domain = strdup(fullpw->pw_name);
+			pos_enddomain = strchr(domain, '+');
+
+			if(!pos_enddomain)
+				pos_enddomain = strchr(domain, '\\');
+
+			if(pos_enddomain) {
+				*pos_enddomain = '\0';
+				child_set_env(&env, &envsize, "USERDOMAIN", domain);
+				child_set_env(&env, &envsize, "USERNAME", ++pos_enddomain);
+			}
+
+			free(domain);
+		} else
+			debug2("cannot determine user information by uid %d", pw->pw_uid);
+
+		if(!pos_enddomain) {
+			char* pdomain;
+			int pdomain_size;
+
+			debug2("cannot find domain, using principal domain");
+			
+			pdomain_size = getpdomain(NULL, 0);
+
+			if(pdomain_size > 0)
+			{
+				pdomain = malloc(pdomain_size);
+				if(getpdomain(pdomain, pdomain_size) != 0) {
+					debug2("cannot get principal domain!");
+				} else {
+					/* ok, set... */
+					child_set_env(&env, &envsize, "USERDOMAIN", pdomain);
+					child_set_env(&env, &envsize, "USERNAME", pw->pw_name);
+				}
+				free(pdomain);
+			} else {
+				debug2("cannot determine principal domain size");
+			}
+		}
+	}
+
+	/* also USERPROFILE would be good, but thats a hard one. */
+#endif
+
 #ifdef GSSAPI
 	/* Allow any GSSAPI methods that we've used to alter
 	 * the childs environment as they see fit
@@ -1494,11 +1611,13 @@ do_setusercontext(struct passwd *pw)
 			perror("setgid");
 			exit(1);
 		}
+#ifndef __INTERIX
 		/* Initialize the group list. */
 		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
 			perror("initgroups");
 			exit(1);
 		}
+#endif
 		endgrent();
 # ifdef USE_PAM
 		/*
diff --git a/sshd.c b/sshd.c
index d9fe0c5..cf3865b 100644
--- a/sshd.c
+++ b/sshd.c
@@ -606,8 +606,10 @@ privsep_preauth_child(void)
 	do_setusercontext(privsep_pw);
 #else
 	gidset[0] = privsep_pw->pw_gid;
+#ifndef __INTERIX
 	if (setgroups(1, gidset) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 	permanently_set_uid(privsep_pw);
 #endif
 }
@@ -1257,8 +1259,10 @@
 	av = saved_argv;
 #endif
 
+#ifndef __INTERIX
 	if (geteuid() == ROOT_UID && setgroups(0, NULL) == -1)
 		debug("setgroups(): %.200s", strerror(errno));
+#endif
 
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
@@ -1577,6 +1579,10 @@ main(int ac, char **av)
 		if (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&
 		    (st.st_uid != getuid () ||
 		    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))
+#elif defined(__INTERIX)
+		/* allow any user, changing personality for unpriviledged use isn't
+		 * possible anyway. */
+		if ((st.st_uid != getuid() && st.st_uid != ROOT_UID) || (st.st_mode & (S_IWGRP | S_IWOTH)) != 0)
 #else
 		if (st.st_uid != ROOT_UID || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
 #endif
@@ -1602,8 +1608,10 @@ main(int ac, char **av)
 	 * to create a file, and we can't control the code in every
 	 * module which might be used).
 	 */
+#ifndef __INTERIX
 	if (setgroups(0, NULL) < 0)
 		debug("setgroups() failed: %.200s", strerror(errno));
+#endif
 
 	if (rexec_flag) {
 		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
diff --git a/uidswap.c b/uidswap.c
index 81e48ec..e5b0f94 100644
--- a/uidswap.c
+++ b/uidswap.c
@@ -82,6 +82,7 @@ temporarily_use_uid(struct passwd *pw)
 	privileged = 1;
 	temporarily_use_uid_effective = 1;
 
+#ifndef __INTERIX
 	saved_egroupslen = getgroups(0, NULL);
 	if (saved_egroupslen < 0)
 		fatal("getgroups: %.100s", strerror(errno));
@@ -117,6 +118,7 @@ temporarily_use_uid(struct passwd *pw)
 	/* Set the effective uid to the given (unprivileged) uid. */
 	if (setgroups(user_groupslen, user_groups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 #ifndef SAVED_IDS_WORK_WITH_SETEUID
 	/* Propagate the privileged gid to all of our gids. */
 	if (setgid(getegid()) < 0)
@@ -154,7 +156,7 @@ permanently_drop_suid(uid_t uid)
 		fatal("setuid %u: %.100s", (u_int)uid, strerror(errno));
 #endif
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of UID if changed (test clearing of saved uid) */
 	if (old_uid != uid &&
 	    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))
@@ -199,8 +201,10 @@ restore_uid(void)
 	setgid(getgid());
 #endif /* SAVED_IDS_WORK_WITH_SETEUID */
 
+#ifndef __INTERIX
 	if (setgroups(saved_egroupslen, saved_egroups) < 0)
 		fatal("setgroups: %.100s", strerror(errno));
+#endif
 	temporarily_use_uid_effective = 0;
 }
 
@@ -249,7 +253,7 @@ permanently_set_uid(struct passwd *pw)
 		fatal("setuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
 #endif
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of GID if changed (test clearing of saved gid) */
 	if (old_gid != pw->pw_gid && pw->pw_uid != ROOT_UID &&
 	    (setgid(old_gid) != -1 || setegid(old_gid) != -1))
@@ -263,7 +267,7 @@ permanently_set_uid(struct passwd *pw)
 		    (u_int)pw->pw_gid);
 	}
 
-#ifndef HAVE_CYGWIN
+#if !defined(HAVE_CYGWIN) && !defined(__INTERIX)
 	/* Try restoration of UID if changed (test clearing of saved uid) */
 	if (old_uid != pw->pw_uid &&
 	    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))
diff --git a/uuencode.c b/uuencode.c
index a139495..d5204b2 100644
--- a/uuencode.c
+++ b/uuencode.c
@@ -27,7 +27,9 @@
 
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <resolv.h>
+#ifndef __INTERIX
+# include <resolv.h>
+#endif
 #include <stdio.h>
 
 #include "xmalloc.h"
