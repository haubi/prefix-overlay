diff -ru -x '*.Po' -x '*.Plo' gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-dns-sd.c gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-dns-sd.c
--- gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-dns-sd.c	2008-03-20 14:23:05 +0100
+++ gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-dns-sd.c	2008-03-20 12:10:07 +0100
@@ -29,13 +29,16 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <arpa/nameser.h>
-#include <resolv.h>
 #include <string.h>
 #include "gnome-vfs-dns-sd.h"
 #include <gconf/gconf-client.h>
 #include <unistd.h>
 
+#ifndef __INTERIX /* this comments out _much_, be carfull! */
+
+#include <arpa/nameser.h>
+#include <resolv.h>
+
 #ifdef HAVE_AVAHI
 #include <avahi-client/client.h>
 #include <avahi-client/lookup.h>
@@ -92,6 +95,8 @@
 	guint16 rdlength;
 } dns_message_rr;
 
+#endif /* __INTERIX */
+
 /* Normally, this would be autogenerated by glib-mkenums, but in this case it
    has no way to guess correctly. */
 GType
@@ -109,6 +114,8 @@
   return etype;
 }
 
+#ifndef __INTERIX /* this comments out _much_, be carfull! */
+
 static GHashTable *
 decode_txt_record (char *raw_txt,
 		   int raw_txt_len)
@@ -1112,6 +1119,8 @@
 
 #endif /* HAVE_HOWL */
 
+#endif /* __INTERIX */
+
 /**
  * gnome_vfs_dns_sd_browse:
  * @handle: pointer to a pointer to a #GnomeVFSDNSSDBrowseHandle object.
@@ -1142,6 +1151,7 @@
 			 gpointer callback_data,
 			 GDestroyNotify callback_data_destroy_func)
 {
+#ifndef __INTERIX
 	GnomeVFSDNSSDBrowseHandle *handle;
 
 	*handle_out = NULL;
@@ -1210,6 +1220,9 @@
 		*handle_out = handle;
 		return GNOME_VFS_OK;
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 /**
@@ -1223,6 +1236,7 @@
 GnomeVFSResult
 gnome_vfs_dns_sd_stop_browse (GnomeVFSDNSSDBrowseHandle *handle)
 {
+#ifndef __INTERIX
 	if (handle->is_local) {
 #ifdef HAVE_AVAHI
 		handle->cancelled = TRUE;
@@ -1245,8 +1259,13 @@
 			handle->cancelled = TRUE;
 		return GNOME_VFS_OK;
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
+#ifndef __INTERIX
+
 struct GnomeVFSDNSSDResolveHandle {
 	char *name;
 	char *domain;
@@ -1671,6 +1690,8 @@
 
 #endif
 
+#endif /* __INTERIX */
+
 /**
  * gnome_vfs_dns_sd_resolve:
  * @handle: pointer to a pointer to a #GnomeVFSDNSSDResolveHandle object.
@@ -1705,6 +1726,7 @@
 			  gpointer callback_data,
 			  GDestroyNotify callback_data_destroy_func)
 {
+#ifndef __INTERIX
 	GnomeVFSDNSSDResolveHandle *handle;
 
 	*handle_out = NULL;
@@ -1779,6 +1801,9 @@
 		*handle_out = handle;
 		return GNOME_VFS_OK;
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 /**
@@ -1792,6 +1817,7 @@
 GnomeVFSResult
 gnome_vfs_dns_sd_cancel_resolve (GnomeVFSDNSSDResolveHandle *handle)
 {
+#ifndef __INTERIX
 	if (handle->is_local) {
 #ifdef HAVE_AVAHI
 		avahi_service_resolver_free (handle->avahi_sr);
@@ -1817,6 +1843,9 @@
 		handle->cancelled = TRUE;
 		return GNOME_VFS_OK;
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 #if defined(HAVE_AVAHI) || defined(HAVE_HOWL)
@@ -2019,6 +2048,7 @@
 			      int *n_services,
 			      GnomeVFSDNSSDService **services)
 {
+#ifndef __INTERIX
 	*n_services = 0;
 	*services = NULL;
 	
@@ -2149,6 +2179,9 @@
 					    n_services,
 					    services);
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 #ifdef HAVE_AVAHI
@@ -2255,6 +2288,7 @@
 			       int *text_raw_len_out,
 			       char **text_raw_out)
 {
+#ifndef __INTERIX
 	int text_raw_len;
 	char *text_raw;
 	GnomeVFSResult res;
@@ -2423,6 +2457,9 @@
 
 		return res;
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 /**
@@ -2464,12 +2501,16 @@
 					   int timeout_msec,
 					   GList **domains)
 {
+#ifndef __INTERIX
 	if (strcmp (domain, "local") == 0) {
 		/* TODO: Not supported at the moment */
 		return GNOME_VFS_ERROR_NOT_SUPPORTED;
 	} else {
 		return unicast_list_domains_sync (domain, domains);
 	}
+#else /* __INTERIX */
+	return GNOME_VFS_ERROR_NOT_SUPPORTED;
+#endif /* __INTERIX */
 }
 
 /**
@@ -2491,6 +2532,7 @@
 GList *
 gnome_vfs_get_default_browse_domains (void)
 {
+#ifndef __INTERIX
 	char hostname[256];
 	char *domain, *dot;
 	GList *domains;
@@ -2542,4 +2584,7 @@
 	g_object_unref (G_OBJECT (client));
 
 	return domains;
+#else /* __INTERIX */
+	return NULL;
+#endif /* __INTERIX */
 }
diff -ru -x '*.Po' -x '*.Plo' gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-unix-mounts.c gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-unix-mounts.c
--- gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-unix-mounts.c	2008-03-20 13:22:59 +0100
+++ gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-unix-mounts.c	2008-03-20 14:16:36 +0100
@@ -83,6 +83,11 @@
 #endif
 #endif
 
+#if defined(__INTERIX)
+# include <sys/statvfs.h>
+# include <dirent.h>
+#endif
+
 #define STAT_TIMEOUT_SECONDS 3
 
 
@@ -503,6 +508,59 @@
 
 	return TRUE;
 }
+#elif defined(__INTERIX)
+
+static char *
+get_mtab_monitor_file (void)
+{
+	return NULL;
+}
+
+gboolean
+_gnome_vfs_get_current_unix_mounts (GList **return_list)
+{
+	DIR* dirp = opendir("/dev/fs");
+
+	if(!dirp) {
+		g_warning("unable to read /dev/fs!");
+		return FALSE;
+	} else {
+		char filename[9 + NAME_MAX];
+
+		while(1) {
+			struct statvfs statbuf;
+			struct dirent entry;
+			struct dirent* result;
+
+			if(readdir_r(dirp, &entry, &result) || result == NULL) {
+				break;
+			}
+
+			strcpy(filename, "/dev/fs/");
+			strcat(filename, entry.d_name);
+
+			if(statvfs(filename, &statbuf) == 0) {
+				GnomeVFSUnixMount* mount_entry = g_new0(GnomeVFSUnixMount, 1);
+
+				mount_entry->mount_path = g_strdup(statbuf.f_mntonname);
+				mount_entry->device_path = g_strdup(statbuf.f_mntfromname);
+				mount_entry->filesystem_type = g_strdup(statbuf.f_fstypename);
+
+				if(statbuf.f_flag & ST_RDONLY) {
+					mount_entry->is_read_only = TRUE;
+				}
+
+				*return_list = g_list_prepend(*return_list, mount_entry);
+			}
+		}
+
+		*return_list = g_list_reverse(*return_list);
+
+		closedir(dirp);
+	}
+
+	return TRUE;
+}
 #else
 #error No _gnome_vfs_get_current_unix_mounts() implementation for system
 #endif
@@ -954,6 +1012,12 @@
 
 	return TRUE;
 }
+#elif defined(__INTERIX)
+gboolean
+_gnome_vfs_get_unix_mount_table (GList **return_list)
+{
+	return _gnome_vfs_get_current_unix_mounts(return_list);
+}
 #else
 #error No _gnome_vfs_get_mount_table() implementation for system
 #endif
diff -ru -x '*.Po' -x '*.Plo' gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-volume-ops.c gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-volume-ops.c
--- gnome-vfs-2.20.1.orig/libgnomevfs/gnome-vfs-volume-ops.c	2008-03-20 13:22:59 +0100
+++ gnome-vfs-2.20.1/libgnomevfs/gnome-vfs-volume-ops.c	2008-03-20 13:25:54 +0100
@@ -35,6 +35,10 @@
 #include <pthread.h>
 #endif
 
+#ifdef __INTERIX
+# include <sys/time.h>
+#endif
+
 #include <gconf/gconf-client.h>
 #include "gnome-vfs-volume-monitor-private.h"
 #include "gnome-vfs-volume.h"
diff -ru -x '*.Po' -x '*.Plo' gnome-vfs-2.20.1.orig/modules/http-proxy.c gnome-vfs-2.20.1/modules/http-proxy.c
--- gnome-vfs-2.20.1.orig/modules/http-proxy.c	2008-03-20 13:23:00 +0100
+++ gnome-vfs-2.20.1/modules/http-proxy.c	2008-03-20 14:13:04 +0100
@@ -25,6 +25,11 @@
 #include <unistd.h>
 #include <netdb.h>
 
+#if defined(__INTERIX)
+// doesn't have INET_ADDRSTRLEN, taken from linux
+# define INET_ADDRSTRLEN 16
+#endif
+
 #include "http-proxy.h"
 
 /* #define DEBUG_HTTP(x) (g_print x) */
